<input id="file" type="file" />

<script>

function utf8_decode (str_data) {
  // http://kevin.vanzonneveld.net
  // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
  // +      input by: Aman Gupta
  // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
  // +   improved by: Norman "zEh" Fuchs
  // +   bugfixed by: hitwork
  // +   bugfixed by: Onno Marsman
  // +      input by: Brett Zamir (http://brett-zamir.me)
  // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
  // +   bugfixed by: kirilloid
  // *     example 1: utf8_decode('Kevin van Zonneveld');
  // *     returns 1: 'Kevin van Zonneveld'

  var tmp_arr = [],
    i = 0,
    ac = 0,
    c1 = 0,
    c2 = 0,
    c3 = 0,
    c4 = 0;

  str_data += '';

  while (i < str_data.length) {
    c1 = str_data.charCodeAt(i);
    if (c1 <= 191) {
      tmp_arr[ac++] = String.fromCharCode(c1);
      i++;
    } else if (c1 <= 223) {
      c2 = str_data.charCodeAt(i + 1);
      tmp_arr[ac++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));
      i += 2;
    } else if (c1 <= 239) {
      // http://en.wikipedia.org/wiki/UTF-8#Codepage_layout
      c2 = str_data.charCodeAt(i + 1);
      c3 = str_data.charCodeAt(i + 2);
      tmp_arr[ac++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
      i += 3;
    } else {
      c2 = str_data.charCodeAt(i + 1);
      c3 = str_data.charCodeAt(i + 2);
      c4 = str_data.charCodeAt(i + 3);
      c1 = ((c1 & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63);
      c1 -= 0x10000;
      tmp_arr[ac++] = String.fromCharCode(0xD800 | ((c1>>10) & 0x3FF));
      tmp_arr[ac++] = String.fromCharCode(0xDC00 | (c1 & 0x3FF));
      i += 4;
    }
  }

  return tmp_arr.join('');
}


/*

Tester ceci, en envoyant le résultat à node qui va écrire le fichier
on va commencer avec un zip contenant juste le index.html


*/

var zip;

var request = new XMLHttpRequest();
request.open('GET', 'http://127.0.0.1/butler/test.zip');
// retrieve data unprocessed as a binary string
request.overrideMimeType('text/plain; charset=x-user-defined');
request.onload = function(){
	zip = new Zip(this.responseText);
	zip.read();

	//console.log(zip.entries);

	var content = zip.entries[0].read();
	//content = utf8_decode(content);

	console.log(content);
	var json = JSON.stringify(['./cordova.png', content, 'binary']);
	var link = new XMLHttpRequest();
	link.open(
		'POST',
		'http://127.0.0.1:8124/action/filesystem/write'
	);
	link.onload = function(){
		console.log(this.responseText);
	};
	link.send('format=json&json=' + json);

	/*
	jsunzip = new JSUnzip();
	jsunzip.open(this.responseText);

	file = jsunzip.files['test/index.html'];
	console.log(file);
	*/
};
request.onerror = function(){
	terminal.log('ajax error');
};
request.send();

$('file').addEventListener('drop', function(e){
	var reader = new FileReader();

	reader.onload = function(e){
		zip = new Zip(e.target.result);
		console.log(zip.read());

		jsunzip = new JSUnzip();
		jsunzip.open(e.target.result);
		console.log(jsunzip.files);
	};

	var file = e.dataTransfer.files[0];

	reader.readAsBinaryString(file);
});

</script>

<script>
function JSUnzip() {

    this.getInt = function(offset, size) {
        switch (size) {
        case 4:
            return  (this.data.charCodeAt(offset + 3) & 0xff) << 24 |
                    (this.data.charCodeAt(offset + 2) & 0xff) << 16 |
                    (this.data.charCodeAt(offset + 1) & 0xff) << 8 |
                    (this.data.charCodeAt(offset + 0) & 0xff);
            break;
        case 2:
            return  (this.data.charCodeAt(offset + 1) & 0xff) << 8 |
                    (this.data.charCodeAt(offset + 0) & 0xff);
            break;
        default:
            return this.data.charCodeAt(offset) & 0xff;
            break;
        }
    };

    this.getDOSDate = function(dosdate, dostime) {
        var day = dosdate & 0x1f;
        var month = ((dosdate >> 5) & 0xf) - 1;
        var year = 1980 + ((dosdate >> 9) & 0x7f)
        var second = (dostime & 0x1f) * 2;
        var minute = (dostime >> 5) & 0x3f;
        hour = (dostime >> 11) & 0x1f;
        return new Date(year, month, day, hour, minute, second);
    }

    this.open = function(data) {
        this.data = data;
        this.files = [];

        if (this.data.length < 22)
            return { 'status' : false, 'error' : 'Invalid data' };
        var endOfCentralDirectory = this.data.length - 22;
        while (endOfCentralDirectory >= 0 && this.getInt(endOfCentralDirectory, 4) != 0x06054b50)
            --endOfCentralDirectory;
        if (endOfCentralDirectory < 0)
            return { 'status' : false, 'error' : 'Invalid data' };
        if (this.getInt(endOfCentralDirectory + 4, 2) != 0 || this.getInt(endOfCentralDirectory + 6, 2) != 0)
            return { 'status' : false, 'error' : 'No multidisk support' };

        var entriesInThisDisk = this.getInt(endOfCentralDirectory + 8, 2);
        var centralDirectoryOffset = this.getInt(endOfCentralDirectory + 16, 4);
        var globalCommentLength = this.getInt(endOfCentralDirectory + 20, 2);
        this.comment = this.data.slice(endOfCentralDirectory + 22, endOfCentralDirectory + 22 + globalCommentLength);

        var fileOffset = centralDirectoryOffset;

        for (var i = 0; i < entriesInThisDisk; ++i) {
            console.log('signature', this.getInt(fileOffset + 0, 4), 'at', fileOffset);

            if (this.getInt(fileOffset + 0, 4) != 0x02014b50)
                return { 'status' : false, 'error' : 'Invalid data' };
            console.log('version', this.getInt(fileOffset + 6, 2), 'at', fileOffset + 6);
            if (this.getInt(fileOffset + 6, 2) > 20)
                return { 'status' : false, 'error' : 'Unsupported version' };
            if (this.getInt(fileOffset + 8, 2) & 1)
                return { 'status' : false, 'error' : 'Encryption not implemented' };

            var compressionMethod = this.getInt(fileOffset + 10, 2);
            console.log('compressionMethod', compressionMethod, 'at', fileOffset + 10);
            if (compressionMethod != 0 && compressionMethod != 8)
                return { 'status' : false, 'error' : 'Unsupported compression method' };

            var lastModFileTime = this.getInt(fileOffset + 12, 2);
            var lastModFileDate = this.getInt(fileOffset + 14, 2);
            var lastModifiedDate = this.getDOSDate(lastModFileDate, lastModFileTime);

            var crc = this.getInt(fileOffset + 16, 4);
            // TODO: crc

            var compressedSize = this.getInt(fileOffset + 20, 4);
            console.log('compressedSize', compressedSize, 'at', fileOffset + 20);
            var uncompressedSize = this.getInt(fileOffset + 24, 4);

            var fileNameLength = this.getInt(fileOffset + 28, 2);
            var extraFieldLength = this.getInt(fileOffset + 30, 2);
            var fileCommentLength = this.getInt(fileOffset + 32, 2);

            console.log('fileCommentLength', fileCommentLength, 'at', fileOffset + 32);

            var relativeOffsetOfLocalHeader = this.getInt(fileOffset + 42, 4);

            var fileName = this.data.slice(fileOffset + 46, fileOffset + 46 + fileNameLength);

            console.log('fileName', fileName, 'at', fileOffset + 46);

            var fileComment = this.data.slice(fileOffset + 46 + fileNameLength + extraFieldLength, fileOffset + 46 + fileNameLength + extraFieldLength + fileCommentLength);

            if (this.getInt(relativeOffsetOfLocalHeader + 0, 4) != 0x04034b50)
                return { 'status' : false, 'error' : 'Invalid data' };
            var localFileNameLength = this.getInt(relativeOffsetOfLocalHeader + 26, 2);
            var localExtraFieldLength = this.getInt(relativeOffsetOfLocalHeader + 28, 2);
            var localFileContent = relativeOffsetOfLocalHeader + 30 + localFileNameLength + localExtraFieldLength;

            this.files[fileName] =
            {
                'fileComment' : fileComment,
                'compressionMethod' : compressionMethod,
                'compressedSize' : compressedSize,
                'uncompressedSize' : uncompressedSize,
                'localFileContent' : localFileContent,
                'lastModifiedDate' : lastModifiedDate
            };

            fileOffset += 46 + fileNameLength + extraFieldLength + fileCommentLength;

            console.log('final index', fileOffset);
        }
        return { 'status' : true }
    };


    this.read = function(fileName) {
        var fileInfo = this.files[fileName];
        if (fileInfo) {
            if (fileInfo.compressionMethod == 8) {
                if (!tinf) {
                    tinf = new TINF();
                    tinf.init();
                }
                var result = tinf.uncompress(this.data, fileInfo.localFileContent);
                if (result.status == tinf.OK)
                    return { 'status' : true, 'data' : result.data };
                else
                    return { 'status' : false, 'error' : result.error };
            } else {
                return { 'status' : true, 'data' : this.data.slice(fileInfo.localFileContent, fileInfo.localFileContent + fileInfo.uncompressedSize) };
            }
        }
        return { 'status' : false, 'error' : "File '" + fileName + "' doesn't exist in zip" };
    };

};
</script>

<script>
function BigEndianBinaryStream(data){
	this.data = data;
	this.reset();
};

BigEndianBinaryStream.prototype = {
	// The index of the current byte, used when we step through the byte with getNextBytesAs*.
	reset: function(){
		this.index = 0;
	},

	getCharCodeAt: function(index){
		return this.data.charCodeAt(index);
	},

	getByteAt: function(index){
		return this.getCharCodeAt(index) & 0xff;
	},

	// Big endian, so we're going backwards.
	getByteRangeAsNumber: function(index, count){
		var result = 0;

		while( count-- ){
			result = (result << 8) + this.getByteAt(index + count);
		}

		return result;
	},

	getByteRangeAsString: function(index, count){
		var result = '', max = index + count, i = index, charCode;

		while( i < max ){
			charCode = this.getCharCodeAt(i);
			result+= String.fromCharCode(charCode);
			// Accounting for multi-byte strings.
			//max-= Math.floor(charCode / 0x100);
			i++;
		}

		return result;
	},

	getNextBytesAsNumber: function(count){
		var res = this.getByteRangeAsNumber(this.index, count);
		this.index+= count;
		return res;
	},

	getNextBytesAsString: function(count){
		var res = this.getByteRangeAsString(this.index, count);
		this.index+= count;
		return res;
	}
};

function Zip(data){
	this.stream = new BigEndianBinaryStream(data);
};

Zip.prototype = {
	getStartIndex: function(){
		var stream = this.stream, length = stream.data.length, index;

		if( length < 22 ){
			throw new Error('Invalid data');
		}

		index = length - 22;

		while( index >= 0 && stream.getByteRangeAsNumber(index, 4) != 0x06054b50 ){
			index--;
		}

		if( index < 0 ){
        	throw new Error('Invalid data');
        }

        if( stream.getByteRangeAsNumber(index + 4, 2) != 0 || stream.getByteRangeAsNumber(index + 6, 2) != 0 ){
         	 throw new Error('No multidisk support');
        }

        return index;
	},

	read: function(){
		var start = this.getStartIndex();
		var entryCount = this.stream.getByteRangeAsNumber(start + 8, 2);
		var offset = this.stream.getByteRangeAsNumber(start + 16, 4);
        var commentLength = this.stream.getByteRangeAsNumber(start + 20, 2);
        var i = 0, j = entryCount;

        this.comment = this.stream.data.slice(start + 22, start + 22 + commentLength);
        this.stream.index = offset;
        this.entries = [];

        for(;i<j;i++){
        	this.entries.push(new ZipEntry(this.stream));
        }

        return this.entries;
	},

	isZipFile: function () {
		return this.stream.getByteRangeAsNumber(0, 4) === Zip.LOCAL_HEADER;
	}
};

Zip.HEADER = 0x02014b50;
Zip.LOCAL_HEADER = 0x04034b50;

function ZipEntry(stream){
	this.stream = stream;
	this.signature          = stream.getNextBytesAsNumber(4);

	console.log('zipentry signature', this.signature, 'at', stream.index - 4);

	if( this.signature !== Zip.HEADER ){
		return;
		//throw new Error('invalid data');
	}

	// what is there?
	stream.index+=2;

	this.versionNeeded      = stream.getNextBytesAsNumber(2);
	console.log('version', this.versionNeeded, 'at', stream.index - 2);
	this.bitFlag            = stream.getNextBytesAsNumber(2);
	this.compressionMethod  = stream.getNextBytesAsNumber(2);
	console.log('compressionMethod', this.compressionMethod, 'at', stream.index - 2);
	this.timeBlob           = stream.getNextBytesAsNumber(4);

	if( this.isEncrypted() ){
		throw new Error('File contains encrypted entry. Not supported.');
	}

	if ( this.isUsingUtf8() ){
		throw new Error('File is using UTF8. Not supported.');
	}

	this.crc32              = stream.getNextBytesAsNumber(4);
	this.compressedSize     = stream.getNextBytesAsNumber(4);
	console.log('compressedsize', this.compressedSize, 'at', stream.index - 4);
	this.uncompressedSize   = stream.getNextBytesAsNumber(4);

	if( this.isUsingZip64() ){
		throw new Error('File is using Zip64 (4gb+ file size). Not supported');
	}

	this.fileNameLength     = stream.getNextBytesAsNumber(2);
	this.extraFieldLength   = stream.getNextBytesAsNumber(2);
	this.fileCommentLength  = stream.getNextBytesAsNumber(2);

	console.log('fileCommentLength', this.fileCommentLength, 'at', stream.index - 2);

	// what is there?
	stream.index+= 8;

	this.relativeOffset 	= stream.getNextBytesAsNumber(4);
	this.fileName  			= stream.getNextBytesAsString(this.fileNameLength);

	console.log('fileName', this.fileName, 'at', stream.index - this.fileNameLength);

	this.extra  			= stream.getNextBytesAsString(this.extraFieldLength);
	this.comment 			= stream.getNextBytesAsString(this.fileCommentLength);

	if( this.isUsingBit3TrailingDataDescriptor() ){
		if( typeof(console) !== 'undefined' ){
			console.log('File is using bit 3 trailing data descriptor. Not supported.');
		}
		// Skip the descriptor and move to beginning of next ZipEntry
		stream.index+= 16;
	}

	console.log('final index', stream.index);
};

ZipEntry.prototype = {
	isEncrypted: function () {
		return (this.bitFlag & 0x01) === 0x01;
	},

	isUsingUtf8: function () {
		return (this.bitFlag & 0x0800) === 0x0800;
	},

	isUsingBit3TrailingDataDescriptor: function () {
		return (this.bitFlag & 0x0008) === 0x0008;
	},

	isUsingZip64: function () {
		return this.compressedSize === 0xFFFFFFFF || this.uncompressedSize === 0xFFFFFFFF;
	},

	read: function(){
		if( this.stream.getByteRangeAsNumber(this.relativeOffset, 4) != Zip.LOCAL_HEADER ){
			throw new Error('invalid data');
	    }

	    var localFileNameLength = this.stream.getByteRangeAsNumber(this.relativeOffset + 26, 2);
	    var localExtraFieldLength = this.stream.getByteRangeAsNumber(this.relativeOffset + 28, 2);
	    var dataStart = this.relativeOffset + 30 + localFileNameLength + localExtraFieldLength;
	    var data;

	    if( this.compressionMethod == 0 ){
	    	data = this.stream.data.slice(dataStart, dataStart + this.compressedSize);
	    }
	    else{
	    	data = this.stream.getByteRangeAsString(dataStart, dataStart + this.compressedSize);
	    	//data = this.stream.data.slice(dataStart, dataStart + this.compressedSize);
	    	data = JSInflate.inflate(data);
	    }

	    //data = utf8_decode(data);

	    return data;
	}
};

</script>

<script>
// JSINFLATE
(function (GLOBAL) {
	/*
	 * Port of script by Masanao Izumo.
	 *
	 * Wrapped all the variables in a function, created a
	 * constructor for interacting with the lib. Everything
	 * else was written by M. Izumo.
	 *
	 * Original code can be found here: http://www.onicos.com/staff/iz/amuse/javascript/expert/inflate.txt
	 *
	 */

	var zip_WSIZE = 32768;      // Sliding Window size
	var zip_STORED_BLOCK = 0;
	var zip_STATIC_TREES = 1;
	var zip_DYN_TREES    = 2;

	/* for inflate */
	var zip_lbits = 9;      // bits in base literal/length lookup table
	var zip_dbits = 6;      // bits in base distance lookup table
	var zip_INBUFSIZ = 32768;   // Input buffer size
	var zip_INBUF_EXTRA = 64;   // Extra buffer

	/* variables (inflate) */
	var zip_slide;
	var zip_wp;         // current position in slide
	var zip_fixed_tl = null;    // inflate static
	var zip_fixed_td;       // inflate static
	var zip_fixed_bl, fixed_bd; // inflate static
	var zip_bit_buf;        // bit buffer
	var zip_bit_len;        // bits in bit buffer
	var zip_method;
	var zip_eof;
	var zip_copy_leng;
	var zip_copy_dist;
	var zip_tl, zip_td; // literal/length and distance decoder tables
	var zip_bl, zip_bd; // number of bits decoded by tl and td

	var zip_inflate_data;
	var zip_inflate_pos;


	/* constant tables (inflate) */
	var zip_MASK_BITS = new Array(
		0x0000,
		0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
		0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff);
	// Tables for deflate from PKZIP's appnote.txt.
	var zip_cplens = new Array( // Copy lengths for literal codes 257..285
		3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
		35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0);
	/* note: see note #13 above about the 258 in this list. */
	var zip_cplext = new Array( // Extra bits for literal codes 257..285
		0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
		3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99); // 99==invalid
	var zip_cpdist = new Array( // Copy offsets for distance codes 0..29
		1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
		257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
		8193, 12289, 16385, 24577);
	var zip_cpdext = new Array( // Extra bits for distance codes
		0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
		7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
		12, 12, 13, 13);
	var zip_border = new Array(  // Order of the bit length code lengths
		16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15);
	/* objects (inflate) */

	function zip_HuftList() {
		this.next = null;
		this.list = null;
	}

	function zip_HuftNode() {
		this.e = 0; // number of extra bits or operation
		this.b = 0; // number of bits in this code or subcode

		// union
		this.n = 0; // literal, length base, or distance base
		this.t = null; // (zip_HuftNode) pointer to next level of table
	}

	function zip_HuftBuild(b,   // code lengths in bits (all assumed <= BMAX)
						   n,   // number of codes (assumed <= N_MAX)
						   s,   // number of simple-valued codes (0..s-1)
						   d,   // list of base values for non-simple codes
						   e,   // list of extra bits for non-simple codes
						   mm   // maximum lookup bits
						  ) {
		this.BMAX = 16;   // maximum bit length of any code
		this.N_MAX = 288; // maximum number of codes in any set
		this.status = 0;    // 0: success, 1: incomplete table, 2: bad input
		this.root = null;   // (zip_HuftList) starting table
		this.m = 0;     // maximum lookup bits, returns actual

		/* Given a list of code lengths and a maximum table size, make a set of
		   tables to decode that set of codes.  Return zero on success, one if
		   the given code set is incomplete (the tables are still built in this
		   case), two if the input is invalid (all zero length codes or an
		   oversubscribed set of lengths), and three if not enough memory.
		   The code with value 256 is special, and the tables are constructed
		   so that no bits beyond that code are fetched when that code is
		   decoded. */
		{
			var a;          // counter for codes of length k
			var c = new Array(this.BMAX+1); // bit length count table
			var el;         // length of EOB code (value 256)
			var f;          // i repeats in table every f entries
			var g;          // maximum code length
			var h;          // table level
			var i;          // counter, current code
			var j;          // counter
			var k;          // number of bits in current code
			var lx = new Array(this.BMAX+1);    // stack of bits per table
			var p;          // pointer into c[], b[], or v[]
			var pidx;       // index of p
			var q;          // (zip_HuftNode) points to current table
			var r = new zip_HuftNode(); // table entry for structure assignment
			var u = new Array(this.BMAX); // zip_HuftNode[BMAX][]  table stack
			var v = new Array(this.N_MAX); // values in order of bit length
			var w;
			var x = new Array(this.BMAX+1);// bit offsets, then code stack
			var xp;         // pointer into x or c
			var y;          // number of dummy codes added
			var z;          // number of entries in current table
			var o;
			var tail;       // (zip_HuftList)

			tail = this.root = null;
			for(i = 0; i < c.length; i++)
				c[i] = 0;
			for(i = 0; i < lx.length; i++)
				lx[i] = 0;
			for(i = 0; i < u.length; i++)
				u[i] = null;
			for(i = 0; i < v.length; i++)
				v[i] = 0;
			for(i = 0; i < x.length; i++)
				x[i] = 0;

			// Generate counts for each bit length
			el = n > 256 ? b[256] : this.BMAX; // set length of EOB code, if any
			p = b; pidx = 0;
			i = n;
			do {
				c[p[pidx]]++;   // assume all entries <= BMAX
				pidx++;
			} while(--i > 0);
			if(c[0] == n) { // null input--all zero length codes
				this.root = null;
				this.m = 0;
				this.status = 0;
				return;
			}

			// Find minimum and maximum length, bound *m by those
			for(j = 1; j <= this.BMAX; j++)
				if(c[j] != 0)
					break;
			k = j;          // minimum code length
			if(mm < j)
				mm = j;
			for(i = this.BMAX; i != 0; i--)
				if(c[i] != 0)
					break;
			g = i;          // maximum code length
			if(mm > i)
				mm = i;

			// Adjust last length count to fill out codes, if needed
			for(y = 1 << j; j < i; j++, y <<= 1)
				if((y -= c[j]) < 0) {
					this.status = 2;    // bad input: more codes than bits
					this.m = mm;
					return;
				}
			if((y -= c[i]) < 0) {
				this.status = 2;
				this.m = mm;
				return;
			}
			c[i] += y;

			// Generate starting offsets into the value table for each length
			x[1] = j = 0;
			p = c;
			pidx = 1;
			xp = 2;
			while(--i > 0)      // note that i == g from above
				x[xp++] = (j += p[pidx++]);

			// Make a table of values in order of bit lengths
			p = b; pidx = 0;
			i = 0;
			do {
				if((j = p[pidx++]) != 0)
					v[x[j]++] = i;
			} while(++i < n);
			n = x[g];           // set n to length of v

			// Generate the Huffman codes and for each, make the table entries
			x[0] = i = 0;       // first Huffman code is zero
			p = v; pidx = 0;        // grab values in bit order
			h = -1;         // no tables yet--level -1
			w = lx[0] = 0;      // no bits decoded yet
			q = null;           // ditto
			z = 0;          // ditto

			// go through the bit lengths (k already is bits in shortest code)
			for(; k <= g; k++) {
				a = c[k];
				while(a-- > 0) {
					// here i is the Huffman code of length k bits for value p[pidx]
					// make tables up to required level
					while(k > w + lx[1 + h]) {
						w += lx[1 + h]; // add bits already decoded
						h++;

						// compute minimum size table less than or equal to *m bits
						z = (z = g - w) > mm ? mm : z; // upper limit
						if((f = 1 << (j = k - w)) > a + 1) { // try a k-w bit table
							// too few codes for k-w bit table
							f -= a + 1; // deduct codes from patterns left
							xp = k;
							while(++j < z) { // try smaller tables up to z bits
								if((f <<= 1) <= c[++xp])
									break;  // enough codes to use up j bits
								f -= c[xp]; // else deduct codes from patterns
							}
						}
						if(w + j > el && w < el)
							j = el - w; // make EOB code end at table
						z = 1 << j; // table entries for j-bit table
						lx[1 + h] = j; // set table size in stack

						// allocate and link in new table
						q = new Array(z);
						for(o = 0; o < z; o++) {
							q[o] = new zip_HuftNode();
						}

						if(tail == null)
							tail = this.root = new zip_HuftList();
						else
							tail = tail.next = new zip_HuftList();
						tail.next = null;
						tail.list = q;
						u[h] = q;   // table starts after link

						/* connect to last table, if there is one */
						if(h > 0) {
							x[h] = i;       // save pattern for backing up
							r.b = lx[h];    // bits to dump before this table
							r.e = 16 + j;   // bits in this table
							r.t = q;        // pointer to this table
							j = (i & ((1 << w) - 1)) >> (w - lx[h]);
							u[h-1][j].e = r.e;
							u[h-1][j].b = r.b;
							u[h-1][j].n = r.n;
							u[h-1][j].t = r.t;
						}
					}

					// set up table entry in r
					r.b = k - w;
					if(pidx >= n)
						r.e = 99;       // out of values--invalid code
					else if(p[pidx] < s) {
						r.e = (p[pidx] < 256 ? 16 : 15); // 256 is end-of-block code
						r.n = p[pidx++];    // simple code is just the value
					} else {
						r.e = e[p[pidx] - s];   // non-simple--look up in lists
						r.n = d[p[pidx++] - s];
					}

					// fill code-like entries with r //
					f = 1 << (k - w);
					for(j = i >> w; j < z; j += f) {
						q[j].e = r.e;
						q[j].b = r.b;
						q[j].n = r.n;
						q[j].t = r.t;
					}

					// backwards increment the k-bit code i
					for(j = 1 << (k - 1); (i & j) != 0; j >>= 1)
						i ^= j;
					i ^= j;

					// backup over finished tables
					while((i & ((1 << w) - 1)) != x[h]) {
						w -= lx[h];     // don't need to update q
						h--;
					}
				}
			}

			/* return actual size of base table */
			this.m = lx[1];

			/* Return true (1) if we were given an incomplete table */
			this.status = ((y != 0 && g != 1) ? 1 : 0);
		} /* end of constructor */
	}


	/* routines (inflate) */

	function zip_GET_BYTE() {
		if(zip_inflate_data.length == zip_inflate_pos)
			return -1;
		return zip_inflate_data.charCodeAt(zip_inflate_pos++) & 0xff;
	}

	function zip_NEEDBITS(n) {
		while(zip_bit_len < n) {
			zip_bit_buf |= zip_GET_BYTE() << zip_bit_len;
			zip_bit_len += 8;
		}
	}

	function zip_GETBITS(n) {
		return zip_bit_buf & zip_MASK_BITS[n];
	}

	function zip_DUMPBITS(n) {
		zip_bit_buf >>= n;
		zip_bit_len -= n;
	}

	function zip_inflate_codes(buff, off, size) {
		/* inflate (decompress) the codes in a deflated (compressed) block.
		   Return an error code or zero if it all goes ok. */
		var e;      // table entry flag/number of extra bits
		var t;      // (zip_HuftNode) pointer to table entry
		var n;

		if(size == 0)
			return 0;

		// inflate the coded data
		n = 0;
		for(;;) {           // do until end of block
			zip_NEEDBITS(zip_bl);
			t = zip_tl.list[zip_GETBITS(zip_bl)];
			e = t.e;
			while(e > 16) {
				if(e == 99)
					return -1;
				zip_DUMPBITS(t.b);
				e -= 16;
				zip_NEEDBITS(e);
				t = t.t[zip_GETBITS(e)];
				e = t.e;
			}
			zip_DUMPBITS(t.b);

			if(e == 16) {       // then it's a literal
				zip_wp &= zip_WSIZE - 1;
				buff[off + n++] = zip_slide[zip_wp++] = t.n;
				if(n == size)
					return size;
				continue;
			}

			// exit if end of block
			if(e == 15)
				break;

			// it's an EOB or a length

			// get length of block to copy
			zip_NEEDBITS(e);
			zip_copy_leng = t.n + zip_GETBITS(e);
			zip_DUMPBITS(e);

			// decode distance of block to copy
			zip_NEEDBITS(zip_bd);
			t = zip_td.list[zip_GETBITS(zip_bd)];
			e = t.e;

			while(e > 16) {
				if(e == 99)
					return -1;
				zip_DUMPBITS(t.b);
				e -= 16;
				zip_NEEDBITS(e);
				t = t.t[zip_GETBITS(e)];
				e = t.e;
			}
			zip_DUMPBITS(t.b);
			zip_NEEDBITS(e);
			zip_copy_dist = zip_wp - t.n - zip_GETBITS(e);
			zip_DUMPBITS(e);

			// do the copy
			while(zip_copy_leng > 0 && n < size) {
				zip_copy_leng--;
				zip_copy_dist &= zip_WSIZE - 1;
				zip_wp &= zip_WSIZE - 1;
				buff[off + n++] = zip_slide[zip_wp++]
					= zip_slide[zip_copy_dist++];
			}

			if(n == size)
				return size;
		}

		zip_method = -1; // done
		return n;
	}

	function zip_inflate_stored(buff, off, size) {
		/* "decompress" an inflated type 0 (stored) block. */
		var n;

		// go to byte boundary
		n = zip_bit_len & 7;
		zip_DUMPBITS(n);

		// get the length and its complement
		zip_NEEDBITS(16);
		n = zip_GETBITS(16);
		zip_DUMPBITS(16);
		zip_NEEDBITS(16);
		if(n != ((~zip_bit_buf) & 0xffff))
			return -1;          // error in compressed data
		zip_DUMPBITS(16);

		// read and output the compressed data
		zip_copy_leng = n;

		n = 0;
		while(zip_copy_leng > 0 && n < size) {
			zip_copy_leng--;
			zip_wp &= zip_WSIZE - 1;
			zip_NEEDBITS(8);
			buff[off + n++] = zip_slide[zip_wp++] =
				zip_GETBITS(8);
			zip_DUMPBITS(8);
		}

		if(zip_copy_leng == 0)
			zip_method = -1; // done
		return n;
	}

	function zip_inflate_fixed(buff, off, size) {
		/* decompress an inflated type 1 (fixed Huffman codes) block.  We should
		   either replace this with a custom decoder, or at least precompute the
		   Huffman tables. */

		// if first time, set up tables for fixed blocks
		if(zip_fixed_tl == null) {
			var i;          // temporary variable
			var l = new Array(288); // length list for huft_build
			var h;  // zip_HuftBuild

			// literal table
			for(i = 0; i < 144; i++)
				l[i] = 8;
			for(; i < 256; i++)
				l[i] = 9;
			for(; i < 280; i++)
				l[i] = 7;
			for(; i < 288; i++) // make a complete, but wrong code set
				l[i] = 8;
			zip_fixed_bl = 7;

			h = new zip_HuftBuild(l, 288, 257, zip_cplens, zip_cplext,
								  zip_fixed_bl);
			if(h.status != 0) {
				alert("HufBuild error: "+h.status);
				return -1;
			}
			zip_fixed_tl = h.root;
			zip_fixed_bl = h.m;

			// distance table
			for(i = 0; i < 30; i++) // make an incomplete code set
				l[i] = 5;
			zip_fixed_bd = 5;

			h = new zip_HuftBuild(l, 30, 0, zip_cpdist, zip_cpdext, zip_fixed_bd);
			if(h.status > 1) {
				zip_fixed_tl = null;
				alert("HufBuild error: "+h.status);
				return -1;
			}
			zip_fixed_td = h.root;
			zip_fixed_bd = h.m;
		}

		zip_tl = zip_fixed_tl;
		zip_td = zip_fixed_td;
		zip_bl = zip_fixed_bl;
		zip_bd = zip_fixed_bd;
		return zip_inflate_codes(buff, off, size);
	}

	function zip_inflate_dynamic(buff, off, size) {
		// decompress an inflated type 2 (dynamic Huffman codes) block.
		var i;      // temporary variables
		var j;
		var l;      // last length
		var n;      // number of lengths to get
		var t;      // (zip_HuftNode) literal/length code table
		var nb;     // number of bit length codes
		var nl;     // number of literal/length codes
		var nd;     // number of distance codes
		var ll = new Array(286+30); // literal/length and distance code lengths
		var h;      // (zip_HuftBuild)

		for(i = 0; i < ll.length; i++)
			ll[i] = 0;

		// read in table lengths
		zip_NEEDBITS(5);
		nl = 257 + zip_GETBITS(5);  // number of literal/length codes
		zip_DUMPBITS(5);
		zip_NEEDBITS(5);
		nd = 1 + zip_GETBITS(5);    // number of distance codes
		zip_DUMPBITS(5);
		zip_NEEDBITS(4);
		nb = 4 + zip_GETBITS(4);    // number of bit length codes
		zip_DUMPBITS(4);
		if(nl > 286 || nd > 30)
			return -1;      // bad lengths

		// read in bit-length-code lengths
		for(j = 0; j < nb; j++)
		{
			zip_NEEDBITS(3);
			ll[zip_border[j]] = zip_GETBITS(3);
			zip_DUMPBITS(3);
		}
		for(; j < 19; j++)
			ll[zip_border[j]] = 0;

		// build decoding table for trees--single level, 7 bit lookup
		zip_bl = 7;
		h = new zip_HuftBuild(ll, 19, 19, null, null, zip_bl);
		if(h.status != 0)
			return -1;  // incomplete code set

		zip_tl = h.root;
		zip_bl = h.m;

		// read in literal and distance code lengths
		n = nl + nd;
		i = l = 0;
		while(i < n) {
			zip_NEEDBITS(zip_bl);
			t = zip_tl.list[zip_GETBITS(zip_bl)];
			j = t.b;
			zip_DUMPBITS(j);
			j = t.n;
			if(j < 16)      // length of code in bits (0..15)
				ll[i++] = l = j;    // save last length in l
			else if(j == 16) {  // repeat last length 3 to 6 times
				zip_NEEDBITS(2);
				j = 3 + zip_GETBITS(2);
				zip_DUMPBITS(2);
				if(i + j > n)
					return -1;
				while(j-- > 0)
					ll[i++] = l;
			} else if(j == 17) {    // 3 to 10 zero length codes
				zip_NEEDBITS(3);
				j = 3 + zip_GETBITS(3);
				zip_DUMPBITS(3);
				if(i + j > n)
					return -1;
				while(j-- > 0)
					ll[i++] = 0;
				l = 0;
			} else {        // j == 18: 11 to 138 zero length codes
				zip_NEEDBITS(7);
				j = 11 + zip_GETBITS(7);
				zip_DUMPBITS(7);
				if(i + j > n)
					return -1;
				while(j-- > 0)
					ll[i++] = 0;
				l = 0;
			}
		}

		// build the decoding tables for literal/length and distance codes
		zip_bl = zip_lbits;
		h = new zip_HuftBuild(ll, nl, 257, zip_cplens, zip_cplext, zip_bl);
		if(zip_bl == 0) // no literals or lengths
			h.status = 1;
		if(h.status != 0) {
			if(h.status == 1)
				;// **incomplete literal tree**
			return -1;      // incomplete code set
		}
		zip_tl = h.root;
		zip_bl = h.m;

		for(i = 0; i < nd; i++)
			ll[i] = ll[i + nl];
		zip_bd = zip_dbits;
		h = new zip_HuftBuild(ll, nd, 0, zip_cpdist, zip_cpdext, zip_bd);
		zip_td = h.root;
		zip_bd = h.m;

		if(zip_bd == 0 && nl > 257) {   // lengths but no distances
			// **incomplete distance tree**
			return -1;
		}

		if(h.status == 1) {
			;// **incomplete distance tree**
		}
		if(h.status != 0)
			return -1;

		// decompress until an end-of-block code
		return zip_inflate_codes(buff, off, size);
	}

	function zip_inflate_start() {
		var i;

		if(zip_slide == null)
			zip_slide = new Array(2 * zip_WSIZE);
		zip_wp = 0;
		zip_bit_buf = 0;
		zip_bit_len = 0;
		zip_method = -1;
		zip_eof = false;
		zip_copy_leng = zip_copy_dist = 0;
		zip_tl = null;
	}

	function zip_inflate_internal(buff, off, size) {
		// decompress an inflated entry
		var n, i;

		n = 0;
		while(n < size) {
			if(zip_eof && zip_method == -1)
				return n;

			if(zip_copy_leng > 0) {
				if(zip_method != zip_STORED_BLOCK) {
					// STATIC_TREES or DYN_TREES
					while(zip_copy_leng > 0 && n < size) {
						zip_copy_leng--;
						zip_copy_dist &= zip_WSIZE - 1;
						zip_wp &= zip_WSIZE - 1;
						buff[off + n++] = zip_slide[zip_wp++] =
							zip_slide[zip_copy_dist++];
					}
				} else {
					while(zip_copy_leng > 0 && n < size) {
						zip_copy_leng--;
						zip_wp &= zip_WSIZE - 1;
						zip_NEEDBITS(8);
						buff[off + n++] = zip_slide[zip_wp++] = zip_GETBITS(8);
						zip_DUMPBITS(8);
					}
					if(zip_copy_leng == 0)
						zip_method = -1; // done
				}
				if(n == size)
					return n;
			}

			if(zip_method == -1) {
				if(zip_eof)
					break;

				// read in last block bit
				zip_NEEDBITS(1);
				if(zip_GETBITS(1) != 0)
					zip_eof = true;
				zip_DUMPBITS(1);

				// read in block type
				zip_NEEDBITS(2);
				zip_method = zip_GETBITS(2);
				zip_DUMPBITS(2);
				zip_tl = null;
				zip_copy_leng = 0;
			}

			switch(zip_method) {
			case 0: // zip_STORED_BLOCK
				i = zip_inflate_stored(buff, off + n, size - n);
				break;

			case 1: // zip_STATIC_TREES
				if(zip_tl != null)
					i = zip_inflate_codes(buff, off + n, size - n);
				else
					i = zip_inflate_fixed(buff, off + n, size - n);
				break;

			case 2: // zip_DYN_TREES
				if(zip_tl != null)
					i = zip_inflate_codes(buff, off + n, size - n);
				else
					i = zip_inflate_dynamic(buff, off + n, size - n);
				break;

			default: // error
				i = -1;
				break;
			}

			if(i == -1) {
				if(zip_eof)
					return 0;
				return -1;
			}
			n += i;
		}
		return n;
	}


	var JSInflate = {};
	if (typeof(module) == "object") {
		module.exports = JSInflate;
		var fs = require("fs");
	} else {
		GLOBAL.JSInflate = JSInflate;
	}

	JSInflate.inflate = function (data) {
		var out, buff;
		var i, j;

		zip_inflate_start();
		zip_inflate_data = data;
		zip_inflate_pos = 0;

		buff = new Array(1024);
		out = "";
		while((i = zip_inflate_internal(buff, 0, buff.length)) > 0) {
			for(j = 0; j < i; j++)
				out += String.fromCharCode(buff[j]);
		}
		zip_inflate_data = null; // G.C.

		return out;
	};

	function write_inflated_internal(ws, buff) {
		var bytesInflated = zip_inflate_internal(buff, 0, buff.length);
		if (bytesInflated > 0) {
			var out = "";
			for(j = 0; j < bytesInflated; j++) {
				out += String.fromCharCode(buff[j]);
			}
			ws.write(out);
		}
		return bytesInflated;
	};

	JSInflate.inflateStream = function(data, unzipFile, callback) {
		var out, buff, bytesWritten;

		zip_inflate_start();
		zip_inflate_data = data;
		zip_inflate_pos = 0;
		bytesWritten = 0;

		var ws = fs.createWriteStream(unzipFile);
		buff = new Array(1024);
		var bytesInflated = 0;

		ws.on('drain', function() {
			bytesInflated = write_inflated_internal(ws, buff);
			if (bytesInflated > 0) {
				bytesWritten += bytesInflated;
			} else {
				zip_inflate_data = null;
				callback(bytesWritten);
			}
		});

		bytesWritten += write_inflated_internal(ws, buff);
	};
}(this));

</script>
