<script>

/*
Limitations

Cant catch the following:

- delete array[index] due to ObjectChangeEmitter limitations (Object.watch cant detect delete)
- array[index] = value where index is greater than array.length, value and previous values to array.length will be ignored
- array.length = Number where Number != array.length, thus adding or removing entries without being notified

*/

var ArrayObserver = {
	mutators: {
		push: function(){
			var length = this.applyMethod('push', arguments), i = 0, j = arguments.length, index;

			for(;i<j;i++){
				index = i + length - j;
				this.observeValueAt(index);
				this.notify({
					type: 'add',
					index: index,
					value: this.array[index]
				});
			}
		},

		unshift: function(){
			var length = this.applyMethod('unshift', arguments), i = 0, j = arguments.length, index;

			for(;i<j;i++){
				index = i + length - j;
				// observe value at the end
				this.observeValueAt(index);
				// notify the add value at the beginning
				this.notify({
					type: 'add',
					index: i,
					value: this.array[i]
				});
			}	
		},

		pop: function(){
			var value = this.applyMethod('pop'), index = this.array.length;

			this.unobserveValueAt(index);
			this.notify({
				type: 'remove',
				index: index,
				value: value
			});
		},

		shift: function(){
			var value = this.applyMethod('shift'), index = this.array.length;

			this.unobserveValueAt(index);
			this.notify({
				type: 'remove',
				index: 0,
				value: value
			});
		},

		splice: function(index, length){
			var removed = this.applyMethod('splice', arguments), inserted = Array.slice(arguments, 2), i, j;

			// from spec, negative index are computed as follow
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2Fsplice
			if( index < 0 ){
				index+= this.array.length;
			}
			
			i = 0;
			j = removed.length;
			for(;i<j;i++){
				this.notify({
					type: 'remove',
					index: index + i,
					value: removed[i]
				});
			}
			i = 0;
			j = inserted.length;
			for(;i<j;i++){
				this.notify({
					type: 'add',
					index: index + i,
					value: inserted[i]
				});
			}
		},

		reverse: function(){
			this.applyMethod('reverse', arguments);

			var i = 0, j = this.array.length, index;
			for(;i<j;i++){
				index = j - i - 1;
				if( i != index ){
					this.notify({
						type: 'move',
						oldIndex: i,
						index: index,
						value: this.array[index]
					});
				}
			}	
		},

		sort: function(){
			this.valueChangedType = 'move';
			this.applyMethod('sort', arguments, true);
			this.valueChangedType = 'update';	
		}
	},
	delayed: false,
	closed: false,
	valueChangedType: 'update',

	create: function(array, listener, bind){
		this.array = array;
		this.listener = listener;
		this.bind = bind || this;
		this.methods = {};
		this.observer = ObjectChangeEmitter.newSingleton(array);

		var i = 0, j = array.length;
		for(;i<j;i++){
			this.observeValueAt(i);	
			this.notify({
				type: 'add',
				index: i,
				value: this.array[i]
			});
		}
		this.wrapAll();
	},

	close: function(){
		if( this.closed == false ){
			this.unwrapAll();

			var i = this.array.length;
			while(i--) this.unobserveValueAt(i);		
			this.observer = null;

			this.array = null;
			this.listener = null;
			this.bind = null;
			this.methods = null;

			this.closed = true;
		}		
	},

	notify: function(change){
		if( typeof this.listener == 'function' ){
			if( this.delayed == false ){
				this.listener.call(this.bind, change);
			}			
		}
	},

	observeValueAt: function(index){
		this.observer.on(index, this);
	},

	unobserveValueAt: function(index){
		this.observer.off(index, this);
	},

	wrapAll: function(){
		for(var method in this.mutators ){
			this.wrap(method);
		}
	},

	unwrapAll: function(){
		for(var method in this.methods ){
			this.unwrap(method);
		}
	},

	wrap: function(method){
		this.methods[method] = this.array[method];
		this.array[method] = this.mutators[method].bind(this);
	},

	unwrap: function(){
		this.array[method] = this.methods[method];
	},

	applyMethod: function(method, args, supressDelay){
		if( !supressDelay ) this.delayed = true;
		var result = this.methods[method].apply(this.array, args);
		if( !supressDelay ) this.delayed = false;
		return result;
	},

	handleEvent: function(name, args){
		this.valueChanged.apply(this, args);
	},

	valueChanged: function(index, oldValue, value){
		this.notify({
			type: this.valueChangedType,
			index: index,
			oldValue: oldValue,
			value: value
		});
	}
};

// this array stay in sync with supplied array
Array.prototype.sync = function(array){
	ArrayObserver.new(array, function(change){
		if( change.type == 'move' ){
			this[change.index] = change.value;
		}
		else if( change.type == 'add' ){
			this[change.index] = change.value;
		}
		else if( change.type == 'update' ){
			this[change.index] = change.value;
		}
		else if( change.type == 'remove' ){
			this.splice(change.index, 1);
		}
	}, this);

	return this;
};

var array = ['a', 'b', 'c'];
var observer = ArrayObserver.new(array, function(change){
	if( change.type == 'move' ){
		console.log('"' + change.value + '"', 'moved to', change.index, 'from', change.oldIndex);
	}
	else if( change.type == 'add' ){
		console.log('"' + change.value + '"', 'added at ', change.index);
	}
	else if( change.type == 'update' ){
		console.log('"' + change.oldValue + '"', 'updated to', '"' + change.value + '"', 'at', change.index);
	}
	else if( change.type == 'remove' ){
		console.log('"' + change.value + '"', 'removed at',  change.index);
	}
});

//array.reverse();
//array.sort();

array.push('d');
array.pop();
array.shift();
array.unshift('a');

array.splice(1, 1, 'coucou');

//var array = ['a', 'b', 'c'];
//var syncArray = [].sync(array);



</script>