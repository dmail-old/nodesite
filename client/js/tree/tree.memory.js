/*---name: memorydescription: Garde une trace des actions effectuées afin de pouvoir les annuler/refairerequire: demon...*/Tree.definePlugin('memory', {	require: 'demon',		init: function(){		if( this.hasPlugin('ajax') ) throw new Error('memory must be added before ajax');		if( this.hasPlugin('problems') ) throw new Error('memory must be added before problems');				Object.eachPair({			// annulation d'un update, remet l'ancienne valeur			update: function(key){ return ['update', this, [key, this.getProperty(key)]]; },			// annulation d'un move: réinsère le noeud à sa place			move: function(into, index){				var currentIndex = this.getIndex();				if( this.parentNode == into && index <= currentIndex ) currentIndex++;				return ['move', this, [this.parentNode, currentIndex]];			},			// annulation d'un remove: réinsère le noeud à sa place			remove: function(fromcopy){				if( fromcopy == 'fromcopy' ) return ['copy', this, [this.parentNode, this.getIndex()]];				return ['insert', this.parentNode, [this, this.getIndex()]];			},			// annulation de copy: remove la copie créé			copy: function(into, index, clone){ return ['remove', clone, ['fromcopy']]; },			// annulation d'un insert: remove du noeud ajouté			insert: function(child){ return ['remove', child]; }		}, function(key, value){			this.setAction(key, 'reverse', value);		}, this);				this.memory = new Memory(10);		this.memory.tree = this;		this.memory.restore = function(stack, mode){			// donne à cette pile d'appel la propriété 'memoryMode' pour que quand on la traite on sait qu'elle vient d'un undo,redo			stack.memoryMode = mode;			this.tree.demon.start(stack);		};				function cancelStack(stack){						// remet le undo/redo d'ou il vient il n'a pas pu se faire			if( stack.memoryMode ) this.tree.memory.from(stack.memoryMode).push(stack);		}								Object.append(this.demon, {			restorers: [],						admit: function(call){				return this.tree.hasDefinition(call[0], 'reverse');			},						submit: function(submit, call){				var restorer = this.tree.applyDefinition(call[0], 'reverse', call[1], call[2]);				if( restorer ){					if( !restorer[2] ) restorer[2] = [];					this.restorers.push(restorer);				}								submit.call(this, call);			}.curry(this.demon.submit),						end: function(){				if( this.restorers.length ){										// des actions en provenance d'un undo/redo ont abouties on les mots dans l'autre tableau					if( this.stack.memoryMode ){						this.tree.memory.to(this.stack.memoryMode).push(this.restorers.reverse());						this.tree.emit(this.stack.memoryMode);											}					else{						this.tree.memory.store(this.restorers.reverse());					}										this.restorers = [];				}								Demon.prototype.end.call(this);			},						// lorsqu'on annule les piles en cours, on remet les undos et redos d'ou ils provenait			cancelNext: function(){				var stacks = this.stacks, i = stacks.length;				while(i--) cancelStack.call(this, stacks[i]);				Demon.prototype.cancelNext.call(this);			},			cancel: function(){				cancelStack.call(this, this.stack);				Demon.prototype.cancel.call(this);			}		});	}});