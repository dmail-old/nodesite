/*---name: dropfilesdescription: Supporte le drop de fichiers sur l'arbre, les fichiers sont lus avant d'être insérérequire: dragNOTE- les images disposant d'un objet File pourront être affiché par img src="window.URL.createObjectURL(node.origin.file)"- les images ayant déjà été luespourront être affiché via img src="data:image/png;base64:atob(Array.prototype.map.call(node.getProperty('content'), String.fromCharCode))"- une image ayant déjà été chargé par le navigateur, je peux récup son base64 via: canvas.getDataUrl ou via context.getImageDatamais ça n'a aucun intérêt...*/Tree.definePlugin('dropfile', {	require: 'file,drag,popup',	monitorTimeout: 200,			init: function(){			this.drag.addDropSupport('files', {			alias: 'application/x-moz-file',			effect: 'copy',						canDrop: function(){				var args = this.tree.getDestination(this.overed, this.where);				return !args[0].never('insert');			},						drop: function(e){				var args = this.tree.getDestination(this.overed, this.where);				Array.prototype.forEach.call(e.event.dataTransfer.files, function(file){					args[0].insert(file, args[1]);				}, this);			}		});				this.filereader = new FileReader();		this.filereader.onerror = function(e){			switch(e.target.error.code){				case e.target.error.NOT_FOUND_ERR:					alert('File Not Found!');				break;				case e.target.error.NOT_READABLE_ERR:					alert('File is not readable');				break;				case e.target.error.ABORT_ERR:									break; // noop				default:					alert('An error occurred reading this file.');			}		};		this.filereader.onabort = function(e){ };				this.setAction('insert', 'handler', function(child, index){			var file = child.file, callback = this.tree.demon.decide.bind(this.tree.demon);						if( !(file instanceof File) ) return callback('transfer');						// ce qu'on veut insérer est un dossier			if( !child.isFile() ){						// on ne peut pas lire le contenu du dossier, on considère donc qu'il est lu et vide				child.setProperty('listed', true);				return callback('transfer');			}						var percentLoaded = 0;			// si la lecture du fichier devient longue on affiche la progression et un moyen d'abort la lecture du fichier			var timeout = setTimeout(function(){				var popup = monitor(					'Action en cours',					'<div>\						<h4 style="margin:0">Lecture du fichier '+child.name+'</h4>\						<progress style="width:100%;margin:0.5em 0"></progress>\					</div>',					function(){						if( this.tree.filereader.readyState == this.tree.filereader.LOADING ) this.tree.filereader.abort();					}				);								popup.dom.progress = popup.element.getElement(function(el){ return el.tagName.toLowerCase() == 'progress';  });				popup.setProgress = function(percent){ this.dom.progress.textContent = percent + '%'; };								popup.setProgress(percentLoaded);				this.tree.setPopup(popup);			}.bind(this), Tree.plugins.dropfile.monitorTimeout);						this.tree.filereader.onprogress = function(e){				if( e.lengthComputable ){					percentLoaded = Math.round((e.loaded / e.total) * 100);					if( percentLoaded < 100 && this.tree.popup ){						this.tree.popup.setProgress(percentLoaded);					}				}			}.bind(this);						this.tree.filereader.onload = function(e){				if( this.tree.popup ) this.tree.popup.done(e);				else clearTimeout(timeout);								child.setProperty('content', e.target.result);				callback('transfer');			}.bind(this);						switch(child.get('encoding')){				case 'base64': this.tree.filereader.readAsDataURL(file); break;				case 'binary': this.tree.filereader.readAsBinaryString(file); break;				// non supporté pour le moment puisque difficile à passer au serveur				case 'buffer': this.tree.filereader.readAsArrayBuffer(file); break;				case 'text': default: this.tree.filereader.readAsText(file, document.characterSet); break;			}					});			}});/*pas utiliséfunction base64_decode(str){	return window.atob(str);}function base64_encode(str){	return window.btoa(str);}function utf8_encode(str){	return decodeURIComponent(escape(str));}function utf8_decode(str){	return unescape(encodeURIComponent(str));}*/