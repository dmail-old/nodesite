/*---name: uniquedescription: Empèche qu'une action utilisateur donne le même nom à deux noeuds ayant le même parentrequire: problemsTODO- s'assurer que list du parent peut bien se produire pour uname sinon boucle infinie...*/Tree.definePlugin('unique', {	require: 'problems,transform',		node: {		getFree: function(key, value){			var values = this.children.map(function(child){ return child[key]; });			var next = this.tree.getSchema(key, 'nextFree') || undefined;						if( key == 'name' && this.tree.hasPlugin('extension') ){				var ext = Path.extname(value);				return values.getFree(Path.basename(value, ext), next, function(value){ return this.contains(value + ext); }) + ext;			}						return values.getFree(value, next);		},				getChildBy: function(key, value){			return this.children.find(function(child){ return child.get(key) == value; });		},				isFree: function(key, value){			return Boolean(this.getChildBy(key, value));		}	},		init: function(){		this.demon.deciders.transfer = function(){ this.transferCall(this.call); };				this.demon.deciders.cancel = function(){ this.cancelCall(); this.nextCall(); };				this.demon.deciders.list = function(node){			this.insertCall('list', node);			this.transferCall(this.call);		};				this.demon.deciders.remove = function(node){			this.insertCall('remove', node);			// lance l'appel direct			this.transferCall(this.call);		};				this.demon.deciders.usefree = function(property, freevalue){			switch(this.call[0]){				case 'update':					this.call[2][1] = freevalue;					// on refait pas passer on envoit direct					this.transferCall(this.call);				break;				case 'move':					this.insertCall('update', this.call[1], [property, freevalue]);					// on fait repasser l'appel par lé résolution de problème (pour gérer toutes les propriétés unique)					this.submit(this.call);				break;				case 'copy':					this.call[2][2].setProperty(property, freevalue);					this.submit(this.call);				break;				case 'insert':					this.call[2][0].setProperty(property, freevalue);					this.submit(this.call);				break;			}		};						this.resolveDuplicate = function(action, node, child, property, value, callback){			var freevalue = child.parentNode.getFree(property, value);			var title = lang.duplicate_title.apply(this, arguments);			var message = lang.duplicate_message.apply(this, arguments);			var choices = [];						// si ce noeud peut être renommé			if( node.can('update', property, value) ) choices.push({name: 'usefree', value: lang.rename + '"' + freevalue + '"'});			// si le noeud conflictuel peut être supprimé			if( child.can('remove') ) choices.push({name: 'remove', value: lang.replace});						if( choices.length == 0 ){				node.tree.setPopup(inform(					message,					function(){ callback('cancel'); }				));			}			else{				message+= lang.duplicate_resolve;				choices.push({name: 'cancel', value: lang.cancel});								node.tree.setPopup(suggest(					title,					message,					choices,					function(choice){						if( choice.name == 'usefree' ) callback(choice.name, property, freevalue);						else if( choice.name == 'remove' ) callback(choice.name, child);						else callback(choice.name);					}				));			}		};				this.define('update', 'handler', function(){			var node, parent, property, value, child, callback;						callback = this.tree.demon.decide.bind(this.tree.demon);			node = this;			parent = node.parentNode;			property = arguments[0];			value = arguments[1];			child = parent && this.tree.getSchema(property, 'unique') ? parent.getChildBy(property, value) : null;						if( child ) this.tree.resolveDuplicate('update', node, child, property, value, callback);			else callback('transfer');		});				['insert', 'move', 'copy', 'trash', 'recycle'].forEach(function(action){			this.define(action, 'handler', function(){				var node, parent, property, value, child, callback, schemas;								callback = this.tree.demon.decide.bind(this.tree.demon);				schemas = this.tree.schemas;								if( action == 'insert' ){					node = arguments[0];					parent = this;				}				else if( action == 'move' ){					node = this;					parent = arguments[0];										// move dans le même parent -> pas de conflit					if( this.parentNode == arguments[0] ) return callback('transfer');				}				else if( action == 'copy' ){					node = arguments[2];					parent = arguments[0];				}				else{					node = this;					parent = node.parentNode;				}								// on liste ou on transfer				if( parent.children.length === 0 ){										if( !this.tree.hasPlugin('list') || parent.hasProperty('listed') ) return callback('transfer');					return callback('list', parent);				}								for(property in schemas){					if( schemas[property].unique ){						if( property == 'name' && (action == 'trash' || action == 'recycle') ){							value = action == 'trash' ? node.name + '.' + Tree.trashExt : Path.filename(node.name);						}						else{							value = node.get(property);						}												child = parent.getChildBy(property, value);						if( child ) break;					}				}								if( child ) this.tree.resolveDuplicate(action, node, child, property, value, callback);				else callback('transfer');							});		}, this);			}});