/*---name: demondescription: permet de reporter des appels aux actions pour les éxécuter plus tardrequire: actionssers de base pour memory, problem, ajax...*/var Demon = new Class({	initialize: function(){		this.lockers = 0; // nombre de verrous empéchant le traitement des ins		this.link = 'defer'; // 'cancel','chain','ignore'		this.ins = []; // piles d'appel en cours de réception		this.stack = null; // ins en cours de traitement		this.stacks = []; // pile de ins en attentes	},		toString: function(){		return 'Demon';	},		connect: function(object, input, output){		this.object = object;		this.input = input;		this.output = output;		this.originalInput = object[input];				object[input] = this.oninput.bind(this);	},		close: function(){		this.object[this.input] = this.originalInput;	},		oninput: function(){		if( this.admit(arguments) ){			this.ins.push(arguments);			this.lock();			setImmediate(this.unlock.bind(this));		}		else{			this.originalInput.apply(this.object, arguments);		}	},		// relance un appel qui a été mit en attente	emit: function(call){		this.tree.handleAction(call, function(call){			// si l'appel a pu passer, on l'envoi à submit qui appeleras nextCall			if( call ) this.demon.submit(this.demon.call = call);			// si l'appel ne traverse pas on passe à l'appel suivant			else this.demon.nextCall();		});	},		// termine un appel	submit: function(call){		this.object[this.output].apply(this.object, call);		this.nextCall();	},		// le démon doit il traiter l'appel?	admit: Function.FALSE,		// pose un verrou, tant qu'un verrou existe les appels admissibles sont empilés	lock: function(){		this.lockers++;	},		// enlève un verrou, si c'est le dernier on traite la pile	unlock: function(){		if( this.lockers !== 0 ){			this.lockers--;			if( this.lockers === 0 ) this.examine();		}	},		// annule la pile en cours	cancel: function(){		this.stack = null;	},		// annule les piles en attente	cancelNext: function(){		this.stacks = [];	},		// met en attente une pile	defer: function(stack){		this.stacks.push(stack);	},		// retourne la prochaine pile en attente	next: function(){		return this.stacks.length ? this.stacks.shift() : false;	},		examine: function(){		var ins = this.ins;		if( ins.length ){			this.ins = []; // vide la pile pour qu'elle puisse être utilisée pendant le traitement de la pile actuelle			this.start(ins);		}	},			// que fait-on lorsqu'on veut traiter une pile?	check: function(stack){		if( !this.stack ) return true;		switch(this.link){			case 'cancel': this.cancel(); return true;			case 'defer': this.defer(stack); return false;		}		return false;	},		// demande à démarrer le traitement d'une pile	start: function(stack){		if( this.check(stack) ){			this.stack = stack;			this.emitAll();		}	},		// traite le prochain appel de la pile en cours	nextCall: function(){		this.index++;				if( this.index < this.stack.length ){			this.call = this.stack[this.index];			this.emit(this.call);		}		else{			delete this.call;			delete this.index;			this.end();		}	},		// envoie la pile de ins	emitAll: function(){		this.index = -1;		this.call = null;		this.nextCall();	},		// fin du traitement, traite la prochaine pile ou ne fais rien	end: function(){		this.stack = null;				var stack = this.next();		if( stack ){			this.start(stack);		}	}});Tree.definePlugin('demon', {	require: 'actions',		init: function(){		this.demon = new Demon();		this.demon.tree = this;		// connecte le démon à l'arbre, l'input est demandAction et l'output applyAction		this.demon.connect(this, 'demandAction', 'applyAction');	}});