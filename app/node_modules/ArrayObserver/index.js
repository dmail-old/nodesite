/*

NOTE:

VERY IMPORTANT: Cant catch the following:

- delete array[index] due to ObjectChangeEmitter limitations (Object.watch cant detect delete)
- array[index] = value where index is greater than array.length, value and previous values to array.length will be ignored
- array.length = Number where Number != array.length, thus adding or removing entries without being notified

REQUIRE:

object.js, object.at.js

USAGE:

var array = [];
var listener = function(change){
	// change has type, oldValue and value properties
};
var observer = ArrayObserver.new(array, listener);

*/

var ArrayObserver = {
	mutators: require('./mutators'),
	Observer: require('PropertyObserver').ObjectObserver,

	array: null,
	listener: null,
	bind: null,
	observer: null,
	delayed: false,
	closed: false,
	valueChangedType: 'update',
	methods: null,

	init: function(array, listener, bind, supressNotify){
		this.array = array;
		this.methods = {};
		this.observer = this.Observer.new(array);
		this.wrapAll();

		if( arguments.length > 1 ){
			this.open(listener, bind, supressNotify);
		}
	},

	open: function(listener, bind, supressNotify){
		this.listener = listener;
		this.bind = bind || this;

		var i = 0, j = array.length;
		for(;i<j;i++){
			this.observeValueAt(i);
				
			if( !supressNotify ){
				this.notify({
					type: 'add',
					index: i,
					oldValue: undefined,
					value: this.array[i],
					object: this.array
				});
			}
		}
	},

	close: function(){
		if( this.closed === false ){
			this.unwrapAll();

			var i = this.array.length;
			while(i--) this.unobserveValueAt(i);
			//this.observer.close(); optionnal
			this.observer = null;

			this.array = null;
			this.listener = null;
			this.bind = null;

			this.closed = true;
		}
	},

	notify: function(change){
		if( this.delayed === false && typeof this.listener == 'function' ){
			this.listener.call(this.bind, change);
		}
	},

	observeValueAt: function(index){
		this.observer.observe(index, this.onchange, this);
	},

	unobserveValueAt: function(index){
		this.observer.unobserve(index, this.onchange);
	},

	wrap: function(method){
		this.methods[method] = this.array[method];
		this.array[method] = this.mutators[method].bind(this);
	},

	unwrap: function(method){
		this.array[method] = this.methods[method];
		delete this.methods[method];
	},

	// we could wrap the Array.prototype directly too
	wrapAll: function(){
		for(var method in this.mutators ){
			this.wrap(method);
		}
	},

	unwrapAll: function(){
		for(var method in this.methods ){
			this.unwrap(method);
		}
	},

	applyMethod: function(method, args, supressDelay){
		if( !supressDelay ) this.delayed = true;
		var result = this.methods[method].apply(this.array, args);
		if( !supressDelay ) this.delayed = false;
		return result;
	},

	onchange: function(change){
		this.notify({
			type: this.valueChangedType,
			index: change.name,
			oldValue: change.oldValue,
			value: change.object[change.name],
			object: change.object
		});
	}
};

module.exports = ArrayObserver;