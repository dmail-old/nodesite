ArrayObserver
=============

Observe array modifications.

## Example

```javascript
var ArrayObserver = require('ArrayObserver');

// will keep two array synchronised :)
Array.prototype.sync = function(array){
  ArrayObserver.new(this, function(change){
    if( change.type == 'affectations' ){
      change.perform(array, this);
    }
    else if( change.type == 'add' ){
      array[change.index] = change.value;
    }
    else if( change.type == 'update' ){
      array[change.index] = change.value;
    }
    else if( change.type == 'remove' ){
      array.splice(change.index, 1);
    }
  }, this);
  
  return array;
};

var array = ['a', 'b', 'c'];
var syncArray = array.sync([]);
array.reverse();

console.log(array, syncArray);
// logs: ['c', 'b', 'a'], ['c', 'b', 'a']
```

## Requirements

- [ObjectObserver](../ObjectObserver)

## Limitations

ArrayObserver is unable to catch 3 type of change:

- delete array[index]; due to [ObjectObserver](../ObjectObserver) limitations.
- array[index] = value; when index is greater than array.length, value and previous values to array.length are ignored.
- array.length = number; when number is not array.length, the added/removed empty values are ignored.

## ArrayObserver.new(array, listener, bind)

- array: the array to observe
- listener: a function that will be called listener(change)
- bind: this value of listener

It will immediatly start to listen array changes and call listener

## ArrayObserver.close()

Stop listening changes.

## affectationChange

array.reverse() and array.sort() will emit affectationChange instead of regular change ('update', 'add' and 'remove').  
It's because reverse() and sort() perform a serie of affectation to reorder values.  
To manipulate this affectation serie affectationChange object are used.

## affectationChange.value

An array containing the serie of affectation done by reverse() or sort().  
An example value: [0,1,1,2]. It means: affect 0 to 1 then 1 to 2.

## affectationChange.perform(intoArray, fromArray)

Perform affectations in intoArray. If you know the array where affectations hapenned, passing it as second argument will avoid creation of a temporary array.

## Why affectationChange.perform create a temporary array?

Because affectations lost values while performed:

```javascript
var a = ['a', 'b', 'c'];
var affectations = [0,2,2,0]; // note: this would be affectations returned for a.reverse()

// naively performing affectations
a[0] = a[2];
a[2] = a[0];
// result in
['c', 'b', 'c'];
// instead of
['c', 'b', 'a'];
```

That's why a temporary array is created to trace original values.

## affectationChange.toMoves()

Transform affectations to moves.  
- Unlike affectation, don't overwrite values so can be performed without the need of a temporary array.  
- More expensive than affectations.  
- Only way I've found to make DOM follow an array state. (see TemplateIterator.performAffectations())

How to perform moves:

```javascript
// assume we got array and affectationChange defined
var moves = affectationChange.toMoves();

moves.forEach(function(move){
  var from = move[0], to, = move[1];
  if( from != to ){
    var value = array[from];
    array.splice(from, 1);
    array.splice(to, 0, value);
  }
});
```
