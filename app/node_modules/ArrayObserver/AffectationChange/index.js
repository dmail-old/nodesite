/*
"affectation" refers to:
	assigning 0 at 1 in ['a', 'b', 'c'] gives -> ['a', 'a', 'c']
"move" refers to:
	moving 0 at 1 in ['a', 'b', 'c'] gives -> ['b', 'a', 'c']

This function take an array of affectations
[oldIndex, newIndex, ...]
and returns a list of moves
[oldIndex, newIndex, ...]
that correspond to those affectations
*/
function transformAffectationsToMoves(affectations){
	var i = 0, j = affectations.length, oldIndex, index;
	var trace = [], moves = [], from, to, gap, tempTrace, traceIndex, k, l;

	for(;i<j;i+=2){
		oldIndex = affectations[i];
		if( typeof trace[oldIndex] === 'number' ){
			oldIndex = trace[oldIndex];
		}
		index = affectations[i + 1];

		if( oldIndex == index ){
			// affectations made this move useless
		}
		else{
			moves.push(oldIndex, index);

			// the value is moved to the left or the right of it's current index
			if( index < oldIndex ){
				gap = 1;
			}
			else{
				gap = -1;
			}

			/*
			for this affectations, store trace in a tempTrace array, that will be merge with trace after
			else the trace array could contain two identical index
			thus making trace.indexOf(from); possibly return the wrong index location
			*/
			tempTrace = [];

			from = oldIndex;
			to = index;
			if( typeof trace[from] == 'number' ){
				traceIndex = trace.indexOf(from);
				if( traceIndex > -1 ){
					from = traceIndex;
				}
			}
			tempTrace.push(from, to);
			//console.log(oldIndex, 'becomes', index, loopTrace);

			while(index != oldIndex){
				from = index;
				to = index + gap;
				if( typeof trace[from] == 'number' ){
					traceIndex = trace.indexOf(from);
					if( traceIndex > -1 ){
						from = traceIndex;
					}
				}
				tempTrace.push(from, to);
				//console.log(index, 'becomes', index+gap, loopTrace);

				index+= gap;
			}

			k = 0;
			l = tempTrace.length;
			for(;k<l;k+=2){
				trace[tempTrace[k]] = tempTrace[k+1];
			}

			//console.log('move', value, 'from', oldIndex, 'to', affectations[i + 1]);
			//console.log('result', array);
			//console.log('trace', trace);
		}
	}

	return moves;
}

function performAffectations(affectations, into, from){
	var i = 0, j = affectations.length, oldIndex, index;

	if( arguments.length === 2 ){
		from = [].concat(into);

		for(;i<j;i+=2){
			oldIndex = affectations[i];
			index = affectations[i + 1];
			into[index] = from[oldIndex];
		}
	}
	else{
		for(;i<j;i+=2){
			oldIndex = affectations[i];
			index = affectations[i + 1];
			into[index] = from[index];
		}
	}
}

module.exports = {
	type: 'affectations',
	value: [],

	init: function(value){
		this.value = value;
	},

	toMoves: function(){
		return transformAffectationsToMoves(this.value);	
	},

	perform: function(into, from){
		return performAffectations(this.value, into, from);
	}
};