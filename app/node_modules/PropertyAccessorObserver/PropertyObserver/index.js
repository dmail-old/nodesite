var PropertyPart = require('../PropertyAccessor').partPrototype;

var PropertyObserver = PropertyPart.create({
	Emitter: require('ObjectObserver'),
	closed: false,
	lastChange: null,
	listener: null,
	emitter: null,
	id: null, // id of this PartObserver

	init: function(name, model, listener, bind, id){
		PropertyPart.init.call(this, name);

		if( arguments.length > 1 ){
			this.setModel(model);
			if( arguments.length > 2 ){
				this.setListener(listener, bind, id);
			}			
		}
	},

	propagate: function(){
		// noop, notify do the job
	},

	// notify change to listener and nextPart
	notify: function(change){
		change.id = this.id;
		change.target = this;

		this.lastChange = change;
		
		if( this.nextPart ){			
			this.nextPart.setModel(change.value);
		}

		if( typeof this.listener == 'function' ){
			this.listener.call(this.bind, change);
		}
	},

	// check change and lastChange before notifying the change
	notifyChange: function(change){
		var lastChange = this.lastChange;

		if( lastChange ){
			// no real change, the object is different but the value still the same
			if( change.value == lastChange.value ){
				return;
			}
			// not a new change: the value is updated
			if( lastChange.type == 'new' && change.type == 'new' ){
				change.type = 'updated';
				change.oldValue = this.lastChange.value;
			}
		}

		this.notify(change);
	},

	// add a listener called each time a change happen
	// listener is immediatly called with a new change except if supressNotify == true
	setListener: function(listener, bind, id, supressNotify){
		this.listener = listener;
		this.bind = bind || this;
		this.id = id;
		
		if( !supressNotify ){
			this.notify(this.lastChange || {
				type: 'new',
				name: this.name,
				oldValue: undefined,
				value: undefined,
				model: this.model
			});
		}
	},

	watcher: function(name, oldValue, value){
		this.notifyChange({
			type: name in this.model ? 'updated' : 'new',
			name: name,
			oldValue: oldValue,
			value: value,
			model: this.model
		});
	},

	handleEvent: function(name, args){
		this.watcher.apply(this, args);
	},

	isPrimitive: function(value){
		var type = typeof value;
		return type == 'number' || type == 'boolean' || type == 'string';
	},

	setModel: function(model){
		this.unsetModel(true);
		this.model = model;
		this.hasModel = true;

		var change = {
			type: 'new',
			name: this.name,
			oldValue: undefined,
			value: undefined,
			model: model
		};
		var has;

		// '{} or {user.}' means bind to the model, in fact means bind to model.toString()
		if( this.name === '' ){
			change.value = model;
		}
		// primitive cant' be watched but does have properties
		else if( this.isPrimitive(model) ){
			change.value = model[this.name];
		}
		// object, function, primitive
		else{
			// null & undefined cant' be watched and dont have any properties
			if( model === null || model === undefined ){
				has = false;
			}
			// object, function
			else{
				this.emitter = this.Observer.new(model);
				this.emitter.on(this.name, this);
				has = this.name in model;

				if( has ){
					change.value = model[this.name];
				}			
			}

			// model doesn't have the property but the previous model had it
			if( has === false && this.lastChange ){
				change.type = 'deleted'; // we lost the pointer on that property
				change.oldValue = this.lastChange.value;
				change.model = this.lastChange.model;
			}
			// else dont touch change			
		}		

		return this.notifyChange(change);
	},

	unsetModel: function(supressNotify){
		if( this.hasModel ){

			if( this.emitter ){
				this.emitter.off(this.name, this);
				this.emitter = null;
			}
			// close the model if model is a ComputedBinding
			if( typeof this.model.close == 'function' ){
				this.model.close();
			}

			this.model = null;

			if( !supressNotify && this.lastChange ){
				this.notifyChange({
					type: 'deleted',
					name: this.name,
					oldValue: this.lastChange.value,
					value: undefined,
					model: this.lastChange.model
				});
			}
		}
	},

	close: function(){
		if( this.closed === false ){
			this.unsetModel(true);
			this.closed = true;
		}
	}
});

module.exports = PartObserver;
