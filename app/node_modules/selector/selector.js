/*
---

name: Selector

description: Object having with a match function destined to be called on a value

requires: Function.TRUE, Function.FALSE

...
*/

var Selector = {
	alwaysTrue: Function.TRUE,
	alwaysFalse: Function.FALSE,
	ACCEPT: true, // a test return true? we found what we wanted break the loop
	REJECT: false, // a test return reject? we continue the loop
	SKIP: 2, // only used in netxNode, prevNode, reject a node without invalidating it's descendant
	selector: null,

	create: function(selector){
		this.selector = selector;
	},

	test: Function.FALSE,

	isRejected: function(value){
		return value === this.REJECT;
	},

	isAccepted: function(value){
		return value === this.ACCEPT;
	},

	callTest: function(test, value){
		return test.call(this, value);
	},

	match: function(value){
		return this.isAccepted(this.callTest(this.test, value));
	},

	matchReverse: function(value){
		return this.isRejected(this.callTest(this.test, value));
	},

	neverMatch: function(){
		return this.test === this.alwaysFalse;
	},

	setReverse: function(reverse){
		if( reverse ){
			this.match = this.matchReverse;
		}
		else{
			this.match = Selector.match;
		}
	},

	// iterator supply values to test, we returns the first or all values matched
	collectMatch: function(iterator, iteratorBind, first){
		var found = first ? null : [], result, self = this;
		
		if( !this.neverMatch() ){
			iterator.call(iteratorBind, function(value){
				result = self.callTest(self.test, value);

				if( self.isAccepted(result) ){
					if( first ){
						found = value;
					}
					else{
						found.push(value);
						// simulate that the value isn't accepted to keep looping
						result = self.SKIP;
					}
				}

				return result;
			});
		}

		return found;
	}
};

module.exports = Selector;