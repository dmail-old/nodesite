/*
Reste : comment récup l'index avec des itérateur natif du genre Iterator(['a'])
Et il manque ptet un firstKey pour les objectIterator

Les iterators natifs marchent ici mais pour firstIndex ou firstKey
il faut itérer différement dessus

lorsqu'on apelle ça on attend que l'itérateur natif renvoie une paire genre
for(pair of iterator){
	index = pair[0];
	value = pair[1];
}

mes itérateur non natif vont renvoyer une valeur seulement, il devrait ptet renvoyer une paire
ça dépend ce qu'on veut faire


*/

var proto = require('proto');
var Collector = proto.create({
	Selector: require('../Selector'),
	iterator: null,
	selector: null,
	result: null,
	types: {
		'first': {
			firstBreak: true
		},

		'all': {
			firstBreak: false
		},

		'count': {
			result: 0,
			firstBreak: false,
			encode: function(){
				this.result++;
			}
		},

		// must be called on ArrayIterator only
		'firstIndex': {
			result: -1,
			firstBreak: true,
			encode: function(){
				return this.iterator.index;
			}
		},

		// must be called on ArrayIterator only
		'allIndex': {
			firstBreak: false,
			encode: function(){
				this.result.push(this.iterator.index);
			}
		}	
	},
	type: null,

	init: function(iterator, selector){
		this.iterator = iterator;
		if( arguments.length > 1){
			this.selector = this.createSelector(selector);
		}
	},

	createSelector: function(){
		return this.Selector.new.apply(this.Selector, arguments);
	},

	forOf: function(fn, bind){
		var iterator = this.iterator['@@iterator'](), next;

		next = iterator.next();
		while( next.done === false ){
			if( !fn || fn.call(bind, next.value) === true ) break;
			next = iterator.next();
		}

		return this;
	},

	handleNext: function(value){
		if( this.selector === null || this.selector.match(value) ){
			var result = this.type.encode ? this.type.encode.call(this, value) : value;

			if( this.type.firstBreak ){
				this.result = result;
				return true;
			}
			else{
				this.result.push(result);
			}
		}
	},

	collect: function(typeName){
		this.type = this.types[typeName];
		this.result = 'result' in this.type ? this.type.result : null;
		this.forOf(this.handleNext, this);
		return this.result;
	}
});

Object.key(Collector.types).forEach(function(method){
	Collector[method] = function(){
		return this.collect(method);
	};
});

// speed improvment
Collector.count = function(){
	// my custom iterators have a length property
	if( this.selector == null && this.iterator.length ) return this.iterator.length;
	return this.collect('count');
};

module.exports = Collector;