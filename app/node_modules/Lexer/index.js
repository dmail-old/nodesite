/*
var CacheIteration = {
	index: 0,	
	values: null,
	value: null,
	ended: false,

	add: function(value){
		this.values.push(value);
	},

	start: function(){
		this.values = [];
	},

	getValue: function(){
		if( this.ended && this.index < this.values.length ){
			return this.values[this.index++];
		}
	},

	nextWrapper: function(){
		var cache, result;

		if( this.hasCache() ){
			cache = this.cache[this.buffer];
			result = cache.getValue();
			if( !result ){
				cache.start();
			}
		}
		else{
			cache = this.addCache();
		}

		if( !result ){
			result = this.next();
			
			if( result == null ) cache.end();
			else cache.add(this.token);
		}		

		return result;
	},

	allWrapper: function(){
		var cache;
		
		if( this.hasCache() ) return this.getCache().values;
		else cache = this.addCache(); 
		this.useCache = false;

		var result = this.all();

		cache.values = result;
		cache.end();

		return result;
	},

	end: function(){
		this.ended = true;
	},

	cacheObject: function(item, iterationMethod){
		this.originalNext = item.next;
		item.next = this.nextWrapper;
		this.cache = {};
	}
};
*/

var Token = {
	index: 0,
	value: ''
};

var Lexer = {
	buffer: null,
	length: null,
	index: null,
	Token: Token, // token object
	char: null, // current char
	token: null, // current token
	BREAK: 0,
	CONTINUE: 1,
	//cache: null, // if is an object will be used to cache result, not working yet with next() 

	init: function(buffer){
		this.buffer = buffer;
		this.length = buffer.length;
		this.index = -1;
	},

	is: function(chars, char){
		return chars.indexOf(char) !== -1;
	},

	isSpecial: function(char){
		return this.is(this.specials, char);
	},

	isNumber: function(char){
		return '0' <= char && char <= '9';
	},

	isAlpha: function(char){
		return (char >= 'a' && char <= 'z') || (char >= 'A' && char <= 'Z') || char === '_' || char === '$';
	},

	isAlphaNum: function(char){
		return this.isAlpha(char) || this.isNumber(char);
	},

	charAt: function(index){
		return this.buffer.charAt(index);
	},

	createError: function(error){
		return new Error(this.__name__ + ' Error: ' + error);
	},

	unexpectedChar: function(){
		throw this.createError('Unexpected char ' + this.char + ' at ' + this.index + ' in ' + this.buffer);
	},

	readChar: function(index){
		if( index < this.length ){
			return this.charAt(index);
		}
		else{
			return null;
		}
	},

	readWhile: function(isChar, is){
		var buffer = '';
		is = is == null ? true : is;
		while( this.nextChar() && isChar.call(this, this.char) == is ){
			buffer+= this.char;
		}
		return buffer;
	},

	readAlphaNum: function(){
		return this.readWhile(this.isAlphaNum);
	},

	nextChar: function(){
		this.index++;
		this.char = this.readChar(this.index);
		return this.char;		
	},

	createToken: function(){
		return this.Token.new.apply(this.Token, arguments);
	},

	writeToken: function(){
		return this.BREAK;
	},

	next: function(){
		var result;

		this.token = this.createToken();

		while( this.nextChar() ){
			if( this.isSpecial(this.char) ) continue;

			result = this.writeToken(this.token, this.char);
			
			if( result === this.BREAK ) break;
			if( result === this.CONTINUE ) continue;
			this.unexpectedChar();
			break;
		}

		// token not modified and is not next first call
		if( this.token.index === 0 && this.token.value.length === 0 && this.index !== 0 ){
			this.token = null;
		}

		return this.token;
	},	

	parse: function(){
		var parts = [], part;

		while( part = this.next() ){
			parts.push(part);
		}

		return parts;
	}
};

module.exports = Lexer;