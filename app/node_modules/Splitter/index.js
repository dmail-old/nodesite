/*

var csv = 'a,b,c
d,e,f';

var csv = CSV.new(csv);
var parts = CSV.parts;

var firstLine = parts[0];
var firstValue = firstLine.values[0];

firstLine.value; // 'a,b,c'
firstLine.values[0]; // 'a'
firstLine.values[1]; // 'b'
firstLine.values[0].value = 'j,k,l,m'; // je dois être capable de générer le csv depuis ces parties

y me faut un truc qui garge en sychronisation le résultat global de ça

genre quand je fais ça ben ça update l'index des parties suivantes (ce que fait fileTemplate)
ça met à jour le représentation générale du csv aussi

Part pourrait très bien avoir un startIndex, endIndex
length ferait endIndex - startIndex
source irait lire dans l'énorme buffer et ferait buffer.slice(startIndex, endIndex)

donc quand je split, je split tout y compris separator
par contre selon ce que je demande:
source -> je retourne le source tel quel (parentsource.slice)
value -> je retourne la valeur tel qu'on l'utilise (sans séparateur ou guillement double etc)

-> nan on garde le système actuel

on peut un peu s'inspirer de:

http://quirksmode.org/dom/core/ les méthodes de la partie textNode

*/

var Splitter = {
	parts: null,	
	string: null,
	cache: {},

	new: function(string){
		string = String(string);

		if( string in this.cache ){
			return this.cache[string];
		}
		else{
			return this.cache[string] = Object.prototype.new.call(this, string);
		}
	},

	init: function(string){
		this.string = string;
	},

	_split: function(){
		throw new Error('unimplemented Splitter.split');
	},

	split: function(){
		var parts;

		if( this.hasOwnProperty('parts') ){
			parts = this.parts;
		}
		else{
			parts = this._split();
			this.parts = parts;
		}
		
		return parts;
	}
};

module.exports = Splitter;