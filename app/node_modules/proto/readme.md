proto
=============

Use object as prototype.

## Example

```javascript
var proto = require('proto');

var User = proto.create({
	name: null,
	
	init: function(name){
		this.name = name;
	},
	
	get firstLetter(){
		return this.name[0];
	}
});

var Admin = User.create({
	type: 'admin'
});

// instantiation
var user = User.new('foo');
var admin = Admin.new('bar');

Object.getPrototypeOf(user); // User
Object.getPrototypeOf(admin); // Admin
User.isPrototypeOf(user); // true
User.isPrototypeOf(admin); // true
admin.firstLetter; // 'b'
```

## Requirements

- [Object.property](../Object.property)

## Browser compatibility

If you don't use Object.defineProperty, all browsers are supported*.  
Else depends on [Object.defineProperty compat](http://kangax.github.io/es5-compat-table/#Object.defineProperty) :
 - Firefox 5+
 - Chrome 4+
 - Internet Explorer 9+
 - Opera 11.6+
 - Safari 5.1+
 
(*) In an environment without Object.defineProperty support all works fine but stuff related to custom properties cannot be used (like get firstLetter(), Object.defineProperty, Object.getOwnPropertyDescriptor, ...)

## Why

Feel soo good to use objects only.

## How it works

Four helpers are provided: [supplement](#supplement), [create](#create), [new](#new) and [extend](#extend).

## supplement(...)

Define properties in arguments on this. Uses [propertyArgumentsAPI](#propertyargumentsapi) and support custom property.

```javascript
var a = {};
var b = {name: 'damien'};
var c = {
	get value(){
		return 'foo';
	}
};

// add b and c properties to a
proto.supplement.call(a, b, c);
a.name; // 'damien'
a.value; // 'foo'
```

## create(...)

Return an object linked by prototype to this. See [Object.create](http://msdn.microsoft.com/fr-fr/library/ff925952%28v=vs.94%29.aspx).  
Arguments passed to create are added to object with supplement.

```javascript
var object = proto.create();
proto.name = 'ok';

Object.getPrototypeOf(object); // proto
object.hasOwnProperty('name'); // false
object.name; // 'foo';
```

## new(...)

Create an object linked by prototype to this, calls object.init() with supplied arguments and returns object.

```javascript
var User = proto.create({test: 'passed', init: function(name){ this.name = name; }});
var user = User.new('damien');

user.hasOwnProperty('name'); // true
user.name; // 'damien'
user.hasOwnProperty('test'); // false
user.test; // 'passed'
```

## extend(parent, ...)

The main uses of this function is to convert an old style prototype function into a proto style object :

```javascript
var Stream = function(){
	this.buffer = [];	
};
Stream.prototype.read = function(){};

var MyStream = proto.extend(Stream, {
	init: function(){
		Stream.call(this);
	},

	read: function(){

	}
});

MyStream.new() instanceof Stream; // true
```

## propertyArgumentsAPI

Properties can be passed in arguments like follows:

```javascript
var a = proto.create();

// object
a.supplement({foo: 'foo', bar: 'bar'});
a.foo; // 'foo'
a.bar; // 'bar'

// string
a.supplement('foo', 'bar');
a.foo; // 'bar'

// function
var User = function(){}; User.prototype.name = 'anonymous';
a.supplement(User);
a.name; // 'anonymous'
```

## Calling a parent method

Wrong version:

```javascript
var User = proto.create({
	foo: function(){}
});
var Admin = User.create({
	foo: function(){
		Object.getPrototypeOf(this).foo.call(this);
	}
});
var SuperAdmin = Admin.create({
	foo: function(){
		Object.getPrototypeOf(this).foo.call(this);
	}
});
```

In this scenario calling Admin.foo() call User.foo() as expected.   
However calling SuperAdmin.foo() call endlessly Admin.foo() because Object.getPrototypeOf(SuperAdmin) === Admin.  
In conclusion, you cannot rely on Object.getPrototypeOf() to access the parent when your object (Admin) is the parent of an other (SuperAdmin).

Right version:

```javascript
var User = proto.create({
	foo: function(){}
});
var Admin = User.create({
	foo: function(){
		User.foo.call(this);
	}
});
var SuperAdmin = Admin.create({
	foo: function(){
		Admin.foo.call(this);
	}
});
```

## Custom instantiation logic

You can define how instance are created by redefining the 'new' method:

```javascript
var Parser = proto.create({
	cache: {},
	
	hasCache: function(expression){
		return expression in this.cache;
	},
	
	new: function(expression){
		// returns an existing cached instance
		if( this.hasCache(expression) ){
			return this.cache[expression];
		}
		// return the newly cached instance
		else{
			return this.cache[expression] = Object.prototype.new.call(this, expression);
		}
	},
	
	expression: null,
	init: function(expression){
		this.expression = null;
	}
});

var parser_a = Parser.new('hello');
var parser_b = Parser.new('hello');
var parser_c = Parser.new('world');

parser_a == parser_b; // true
parser_a == parser_c; // false
Parser.cache['hello'] == parser_a; // true
Parser.cache['world'] == parser_c; // true
```

## Structure advices

I use the following structure when declaring my objects and I recommend to use it:

```javascript
var Parser = proto.create({
	// Properties used by the prototype (Parser)
	cache: {}
	
	// Methods used by the prototype (Parser)
	hasCache: function(){},
	new: function(){},
	
	// Properties used by the instance
	expression: null,

	// Methods used by the instance
	init: function(){}
});
```

I always declare all properties used by my object at least by setting them to null (like expression: null above).  
First, because it gives you a quick overview of your object. Second, it makes JavaScript faster* (missing ref).
