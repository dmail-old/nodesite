proto
=============

Use object as prototype for object oriented programming.

## Example

```javascript
var proto = require('proto');

// declaration
var User = proto.extend({
	name: null,
	
	init: function(name){
		this.name = name;
	},
	
	get firstLetter(){
		return this.name[0];
	}
});

// subclassing
var Admin = User.extend({
	type: 'admin'
});

// instantiation
var user = User.new('foo');
var admin = Admin.new('bar');

Object.getPrototypeOf(user); // User
Object.getPrototypeOf(admin); // Admin
User.isPrototypeOf(user); // true
User.isPrototypeOf(admin); // true
admin.firstLetter; // 'b'
```

## Requirements

- [Object.property](../Object.property)

## Browser compatibility

If you don't use Object.defineProperty, all browsers are supported*.  
Else depends on [Object.defineProperty compat](http://kangax.github.io/es5-compat-table/#Object.defineProperty) :
 - Firefox 5+
 - Chrome 4+
 - Internet Explorer 9+
 - Opera 11.6+
 - Safari 5.1+
 
(*) In an environment without Object.defineProperty support all works fine but stuff related to custom properties cannot be used (like get firstLetter(), Object.defineProperty, Object.getOwnPropertyDescriptor, ...)

## Why

Feel soo good to use objects only.

## How it works

Using [Object.pair/implement](../Object.pair/#implement), four helpers are provided: [create](#create), [new](#new), [supplement](#supplement) and [extend](#extend).

## create()

Return an instance of this. The instance is linked by prototype to this. See [Object.create](http://msdn.microsoft.com/fr-fr/library/ff925952%28v=vs.94%29.aspx).  

```javascript
var A = proto.extend({name: 'foo'});
var a = A.create();

a.hasOwnProperty('name'); // false
a.name; // 'foo'
```

## new(...)

[Create](#create) an instance of this and calls instance.init() with supplied arguments.

```javascript
var User = proto.extend({test: 'passed', init: function(name){ this.name = name; }});
var user = User.new('damien');

user.hasOwnProperty('name'); // true
user.name; // 'damien'
user.hasOwnProperty('test'); // false
user.test; // 'passed'
```

## supplement(...)

Define properties in arguments on this. Uses [propertyArgumentsAPI](#propertyargumentsapi)

```javascript
var a = {};
var b = {name: 'damien'};
var c = {
	get value(){
		return 'foo';
	}
};

// add b and c properties to a
proto.supplement.call(a, b, c);
a.name; // 'damien'
a.value; // 'foo'
```

## extend(...)

[Create](#create) an instance of this and calls [instance.supplement()](#supplement) with supplied arguments.  

```javascript
var Item = proto.extend({
	value: 0,
	promotion: 1,
	get price(){
		return this.value * this.promotion;	
	}
});

var Shoe = Item.extend({
	value: 100,
	promotion: 0.9
});

Shoe.price; // 90
```

## propertyArgumentsAPI

Properties can be passed in arguments like follows:

```javascript
var a = proto.extend();

// object
a.supplement({foo: 'foo', bar: 'bar'});
a.foo; // 'foo'
a.bar; // 'bar'

// string
a.supplement('foo', 'bar');
a.foo; // 'bar'

// function
var User = function(){}; User.prototype.name = 'anonymous';
a.supplement(User);
a.name; // 'anonymous'
```

## Calling a parent method

Wrong version:

```javascript
var User = proto.extend({
	foo: function(){}
});
var Admin = User.extend({
	foo: function(){
		Object.getPrototypeOf(this).foo.call(this);
	}
});
var SuperAdmin = Admin.extend({
	foo: function(){
		Object.getPrototypeOf(this).foo.call(this);
	}
});
```

In this scenario calling Admin.foo() call User.foo() as expected.   
However calling SuperAdmin.foo() call endlessly Admin.foo() because Object.getPrototypeOf(SuperAdmin) === Admin.  
In conclusion, you cannot rely on Object.getPrototypeOf() to access the parent when your object (Admin) is the parent of an other (SuperAdmin).

Right version:

```javascript
var User = proto.extend({
	foo: function(){}
});
var Admin = User.extend({
	foo: function(){
		User.foo.call(this);
	}
});
var SuperAdmin = Admin.extend({
	foo: function(){
		Admin.foo.call(this);
	}
});
```

## Custom instantiation logic

You can define how instance are created by redefining the 'new' method:

```javascript
var Parser = proto.extend({
	cache: {},
	
	hasCache: function(expression){
		return expression in this.cache;
	},
	
	new: function(expression){
		// returns an existing cached instance
		if( this.hasCache(expression) ){
			return this.cache[expression];
		}
		// return the newly cached instance
		else{
			return this.cache[expression] = Object.prototype.new.call(this, expression);
		}
	},
	
	expression: null,
	init: function(expression){
		this.expression = null;
	}
});

var parser_a = Parser.new('hello');
var parser_b = Parser.new('hello');
var parser_c = Parser.new('world');

parser_a == parser_b; // true
parser_a == parser_c; // false
Parser.cache['hello'] == parser_a; // true
Parser.cache['world'] == parser_c; // true
```

## Structure advices

I use the following specs when declaring my objects and I recommend to use it:

```javascript
var Parser = proto.extend({
	// Properties used by the prototype (Parser)
	cache: {}
	
	// Methods used by the prototype (Parser)
	hasCache: function(){},
	new: function(){},
	
	// Properties used by the instance
	expression: null,

	// Methods used by the instance
	init: function(){}
});
```

I always declare all properties used by my object at least by setting them to null (like expression: null above).  
First, because it gives you a quick overview of your object. Second, it helps JavaScript compilation.
