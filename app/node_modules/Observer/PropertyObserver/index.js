var proto = require('proto');

var ObjectObserver = proto.create({
	cache: [],
	size: 0,
	object: null,
	propertyObservers: null,	

	indexOf: function(object){
		var cache = this.cache, i = 0, j = cache.length, observer, index = -1;

		for(;i<j;i++){
			observer = cache[i];
			if( observer.object === object ){
				index = i;
				break;
			}
		}

		return index;	
	},

	new: function(object){
		var index = this.indexOf(object);

		if( index === -1 ){
			this.cache.push(proto.new.call(this, object));
		}
		return this.cache[index];
	},

	init: function(object){
		this.object = object;
		this.propertyObservers = {};
	},

	get: function(name){
		var observer;

		if( name in this.propertyObservers ){
			observer = this.propertyObservers[name];
		}
		else{
			observer = proto.new.call(PropertyObserver, this, name);
			this.propertyObservers[name] = observer;
			this.size++;
		}

		return observer;
	},

	remove: function(observer){
		this.size--;
		delete this.propertyObservers[observer.name];
		if( this.size === 0 ){
			this.cache.splice(this.cache.indexOf(this), 1);
		}
	},

	close: function(){
		for(var name in this.propertyObservers){
			this.propertyObservers[name].unobserve();
		}
	},

	notify: function(change){
		this.get(change.name).notify(change);
	},

	observe: function(name, fn, bind){
		return this.get(name).observe(fn, bind);
	},

	unobserve: function(name, fn){
		if( name in this.propertyObservers ){
			this.propertyObservers[name].unobserve(fn);
		}
	}
});

var PropertyObserver = proto.create({
	ObjectObserver: ObjectObserver,
	objectObserver: null,
	object: null,
	name: null,
	fns: null,
	binds: null,
	descriptor: null,
	customDescriptor: null,
	has: false, // object has the property
	opened: false,
	lastChange: null,

	new: function(objectObserver, name){
		if( !ObjectObserver.isPrototypeOf(objectObserver) ){
			objectObserver = ObjectObserver.new(objectObserver);
		}

		return objectObserver.get(name);
	},

	init: function(objectObserver, name){
		this.objectObserver = objectObserver;
		this.object = objectObserver.object;
		this.name = name;
		this.fns = [];
		this.binds = [];
	},

	createGetter: function(){
		return this.descriptor.value;
	},

	childSetter: function(child, value){
		var descriptor = Object.getOwnPropertyDescriptor(child, this.name);
    
		// property not in child object, create it and kill the parent custom setter in this child
		if( descriptor == null ){
			Object.defineProperty(child, this.name, {
				value: value,
				enumerable: true
			});
		}
		// the child got a custom setter (the child property is probably observed as well)
		else if( descriptor.set ){
			descriptor.set.call(child, value);
		}
		// the child has a descriptor without setter
		else{
			child[this.name] = value;
		}
	},

	createSetter: function(){
		var self = this;

		return function(value){
			if( this == self.object ){
				var oldValue = self.descriptor.value;

				if( oldValue !== value ){
					self.descriptor.value = value;

					self.notify({
						type: 'update',
						name: self.name,
						oldValue: oldValue,
						object: this
					});
				}
			}
			else{
				self.childSetter(this, value);
			}
		}
	},

	createFirstSetter: function(has){
		var self = this;

		return function(){
			if( this == self.object ){
				self.descriptor.enumerable = true;
				self.customDescriptor.enumerable = true;
				self.customDescriptor.set = this.createSetter();

				Object.defineProperty(self.object, self.name, self.customDescriptor);
				self.has = true;

				self.notify({
					type: 'add',
					name: self.name,
					oldValue: undefined,
					object: this
				});
			}
			else{
				self.childSetter(this, value);
			}
		}	
	},

	open: function(){
		if( this.opened === true ) return;
		this.opened = true;

		var descriptor = Object.getOwnPropertyDescriptor(this.object, this.name);

		if( descriptor ){
			this.has = true;
		}
		else{
			descriptor = {
				enumerable: false, // the property must not be considered as in the object until it's set
				writable: true,
				configurable: true
			};
			this.has = false;
		}

		this.descriptor = descriptor;

		if( descriptor ){
			// array.length or stuff like this are not configurable :(
			if( descriptor.configurable === false ){
				return false;
			}
			// the object is not suppoed to be modified (todo isFrozen, isSealed etc)
			if( descriptor.writable === false ){
				return false;
			}
			// custom getter and setter can't be watched, they should used getNotifier(this, 'test') (todo)
			if( 'get' in descriptor || 'set' in descriptor ){
				return false;
			}
		}	

		var customDescriptor = {
			get: this.createGetter(),
			set: this.has ? this.createSetter() : this.createFirstSetter(),
			enumerable: descriptor.enumerable,
			configurable: true
		};

		this.customDescriptor = customDescriptor;
		Object.defineProperty(this.object, this.name, customDescriptor);

		return true;		
	},

	close: function(){
		if( this.opened === false ) return;
		this.opened = false;

		if( this.has === true ){
			Object.defineProperty(this.object, this.name, this.descriptor);
		}
		else{
			delete this.object[this.name];
		}

		this.descriptor = null;
	},

	observe: function(fn, bind){
		this.fns.push(fn);
		this.binds.push(bind);
		if( this.fns.length === 1 ){
			return this.open();
		}
		return true;
	},

	unobserve: function(fn){
		if( fn ){
			var index = this.fns.indexOf(fn);

			if( index !== -1 ){
				this.fns.splice(index, 1);
				this.binds.splice(index, 1);
			}
		}
		else{
			this.fns.length = 0;
			this.binds.length = 0;
		}

		if( this.fns.length === 0 ){
			this.close();
			this.objectObserver.remove(this);
		}
	},

	notify: function(change){
		var i = 0, j = this.fns.length;

		this.lastChange = change;
		for(;i<j;i++){
			this.fns[i].call(this.binds[i], change);
		}
	}
});

module.exports = PropertyObserver;