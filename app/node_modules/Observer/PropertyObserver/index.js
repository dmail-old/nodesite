/*
DEPRECATED for customPropertyDefinition

mais mÃªme custompropertydefinition ne sera ptet pas utile donc bon
*/

var proto = require('@dmail/proto');

var ObjectObserver = proto.extend({
	cache: [],
	index: null,
	size: 0,
	object: null,
	propertyObservers: null,

	indexOf: function(object){
		var cache = this.cache, index = cache.length;

		while(index-- && cache[index].object !== object);

		return index;
	},

	has: function(object){
		var index = this.indexOf(object);
		this.index = index;
		return index != -1;
	},

	constructor: function(object){
		if( typeof(object)!== 'object' ) throw new TypeError('ObjectObserver called on non-object');

		if( this.has(object) ){
			return this.cache[this.index];
		}

		this.cache.push(this);
		this.object = object;
		this.propertyObservers = {};
	},

	get: function(name){
		var observer;

		if( name in this.propertyObservers ){
			observer = this.propertyObservers[name];
		}
		else{
			observer = PropertyObserver.create(this, name);
			this.propertyObservers[name] = observer;
			this.size++;
		}

		return observer;
	},

	remove: function(observer){
		this.size--;
		delete this.propertyObservers[observer.name];
		if( this.size === 0 ){
			this.cache.splice(this.cache.indexOf(this), 1);
		}
	},

	close: function(){
		for(var name in this.propertyObservers){
			this.propertyObservers[name].unobserve();
		}
	},

	notify: function(change){
		this.get(change.name).notify(change);
	},

	observe: function(name, fn, bind){
		return this.get(name).observe(fn, bind);
	},

	unobserve: function(name, fn, bind){
		if( name in this.propertyObservers ){
			this.propertyObservers[name].unobserve(fn, bind);
		}
	}
});

var PropertyObserver = proto.extend({
	ObjectObserver: ObjectObserver,
	objectObserver: null,
	object: null,
	name: null,
	fns: null,
	binds: null,
	descriptor: null,
	customDescriptor: null,
	has: false, // object has the property
	opened: false,
	lastChange: null,
	parentProto: null,
	protoObserver: null,

	constructor: function(objectObserver, name){
		if( !ObjectObserver.isPrototypeOf(objectObserver) ){
			objectObserver = ObjectObserver.create(objectObserver);
		}
		else{
			objectObserver = objectObserver.get(name);
		}

		this.objectObserver = objectObserver;
		this.object = objectObserver.object;
		this.name = name;
		this.fns = [];
		this.binds = [];
	},

	notify: function(change){
		var i = 0, j = this.fns.length;

		this.lastChange = change;
		for(;i<j;i++){
			this.fns[i].call(this.binds[i], change);
		}
	},

	unobserveProto: function(){
		if( this.protoObserver ){
			this.protoObserver.unobserveProto();
			this.protoObserver.unobserve(this.onProtoChange, this);
			this.protoObserver = null;
		}
	},

	onProtoChange: function(change){
		this.unobserveProto();
		this.notify(change);
	},

	get: function(object){
		return this.descriptor.value;
	},

	setChild: function(child, value){
		var descriptor = Object.getOwnPropertyDescriptor(child, this.name);

		// property not in child object, create it and overwrite the parent custom setter in this child
		if( descriptor == null ){
			Object.defineProperty(child, this.name, {
				value: value,
				enumerable: true
			});
		}
		// the child got a custom setter (the child property is probably observed as well)
		else if( descriptor.set ){
			descriptor.set.call(child, value);
		}
		// the child has a descriptor without setter
		else{
			child[this.name] = value;
		}
	},

	setFirst: function(object, value){
		if( this.object === object ){
			this.descriptor.enumerable = true;
			this.customDescriptor.enumerable = true;
			this.customDescriptor.set = this.createSetter();

			Object.defineProperty(object, this.name, this.customDescriptor);
			this.has = true;
			this.unobserveProto();

			this.notify({
				type: 'add',
				name: this.name,
				oldValue: undefined,
				object: object
			});
		}
		else{
			this.setChild(object, value);
		}
	},

	set: function(object, value){
		if( this.object === object ){
			var oldValue = this.descriptor.value;

			if( oldValue !== value ){
				this.descriptor.value = value;

				this.notify({
					type: 'update',
					name: this.name,
					oldValue: oldValue,
					object: object
				});
			}
		}
		else{
			this.setChild(object, value);
		}
	},

	createGetter: function(){
		var self = this;

		return function(){
			return self.get(this);
		};
	},

	createSetter: function(){
		var self = this;

		return function(value){
			self.set(this, value);
		};
	},

	createFirstSetter: function(){
		var self = this;

		return function(value){
			self.setFirst(this, value);
		};
	},

	open: function(){
		if( this.opened === true ) return;
		this.opened = true;

		var descriptor;

		if( Object.prototype.hasOwnProperty.call(this.object, this.name) ){
			this.has = true;
			descriptor = Object.getOwnPropertyDescriptor(this.object, this.name);

			// array.length or stuff like this are not configurable :(
			if( descriptor.configurable === false ){
				return false;
			}
			// the object is not suppoed to be modified (todo isFrozen, isSealed etc)
			if( descriptor.writable === false ){
				return false;
			}
			// custom getter and setter can't be watched, they should used getNotifier(this, 'test') (todo)
			if( 'get' in descriptor || 'set' in descriptor ){
				return false;
			}

			// this object is non extensible, we cannot deinfeProperty
			if( !Object.isExtensible(this.object) ){
				return false;
			}
		}
		else{
			this.has = false;

			this.parentProto = Object.getPrototypeOf(this.object);
			if( this.parentProto && this.parentProto != Object.prototype ){
				this.protoObserver = PropertyObserver.create(this.parentProto, this.name);
				this.protoObserver.observe(this.onProtoChange, this);
			}

			// this object is non extensible, but we can observe the parent
			if( !Object.isExtensible(this.object) ){
				return true;
			}

			descriptor = {
				enumerable: false, // the property must not be considered as in the object until it's set
				writable: true,
				configurable: true
			};
		}

		this.descriptor = descriptor;

		var customDescriptor = {
			get: this.createGetter(),
			set: this.has ? this.createSetter() : this.createFirstSetter(),
			enumerable: descriptor.enumerable,
			configurable: true
		};

		this.customDescriptor = customDescriptor;
		Object.defineProperty(this.object, this.name, customDescriptor);

		return true;
	},

	close: function(){
		if( this.opened === false ) return;
		this.opened = false;

		if( this.has === true ){
			Object.defineProperty(this.object, this.name, this.descriptor);
		}
		else if( this.descriptor ){
			this.unobserveProto();
			delete this.object[this.name];
		}

		this.descriptor = null;
	},

	observe: function(fn, bind){
		this.fns.push(fn);
		this.binds.push(bind);
		if( this.fns.length === 1 ){
			return this.open();
		}
		return true;
	},

	unobserve: function(fn, bind){
		if( fn ){
			var index = this.fns.indexOf(fn);

			if( index !== -1 ){
				if( bind ){
					var j = this.binds.length;

					while(index < j){
						if( this.binds[index] === bind ){
							break;
						}
						index++;
					}
					if( index >= j ) return;
				}

				this.fns.splice(index, 1);
				this.binds.splice(index, 1);
			}
		}
		else{
			this.fns.length = 0;
			this.binds.length = 0;
		}

		if( this.fns.length === 0 ){
			this.close();
			this.objectObserver.remove(this);
		}
	}
});

module.exports = PropertyObserver;
