## affectationChange

array.reverse() and array.sort() will emit affectationChange instead of regular change ('update', 'add' and 'remove').  
It's because reverse() and sort() perform a serie of affectation to reorder values.  
To manipulate this affectation serie affectationChange object are used.

## affectationChange.value

An array containing the serie of affectation done by reverse() or sort().  
An example value: [0,1,1,2]. It means: affect 0 to 1 then 1 to 2.

## affectationChange.perform(intoArray, fromArray)

Perform affectations in intoArray. If you know the array where affectations hapenned, passing it as second argument will avoid creation of a temporary array.

## Why affectationChange.perform create a temporary array?

Because affectations lost values while performed:

```javascript
var a = ['a', 'b', 'c'];
var affectations = [0,2,2,0]; // note: this would be affectations returned for a.reverse()

// naively performing affectations
a[0] = a[2];
a[2] = a[0];
// result in
['c', 'b', 'c'];
// instead of
['c', 'b', 'a'];
```

That's why a temporary array is created to trace original values.

## affectationChange.toMoves()

Transform affectations to moves.  
- Unlike affectation, don't overwrite values so can be performed without the need of a temporary array.  
- More expensive than affectations.  
- Only way I've found to make DOM follow an array state. (see TemplateIterator.performAffectations())

How to perform moves:

```javascript
// assume we got array and affectationChange defined
var moves = affectationChange.toMoves();

moves.forEach(function(move){
  var from = move[0], to, = move[1];
  if( from != to ){
    var value = array[from];
    array.splice(from, 1);
    array.splice(to, 0, value);
  }
});
```