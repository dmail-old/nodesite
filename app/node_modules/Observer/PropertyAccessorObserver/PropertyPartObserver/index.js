var PropertyPart = require('../PropertyAccessor').partPrototype;

var PropertyPartObserver = PropertyPart.create({
	Observer: require('PropertyObserver'),
	observer: null,
	closed: false,
	lastChange: null,
	listener: null,
	id: null, // id of this PartObserver

	init: function(name, model, listener, bind, id){
		PropertyPart.init.call(this, name);

		if( arguments.length > 1 ){
			this.setModel(model);
			if( arguments.length > 2 ){
				this.open(listener, bind, id);
			}			
		}
	},

	propagate: function(){
		// noop, notify do the job
	},

	// notify change to listener and nextPart
	notify: function(change){
		change.id = this.id;
		change.target = this;

		this.lastChange = change;
		
		if( this.nextPart ){			
			this.nextPart.setModel(change.value);
		}

		if( typeof this.listener == 'function' ){
			this.listener.call(this.bind, change);
		}
	},

	// check change and lastChange before notifying the change
	notifyChange: function(change){
		var lastChange = this.lastChange;

		if( lastChange ){
			// no real change, the object is different but the value still the same
			if( change.value == lastChange.value ){
				return;
			}
			// not a new change: the value is updated
			if( lastChange.type == 'add' && change.type == 'add' ){
				change.type = 'update';
				change.oldValue = this.lastChange.value;
			}
		}

		this.notify(change);
	},

	// add a listener called each time a change happen
	// listener is immediatly called with a new change except if supressNotify == true
	open: function(listener, bind, id, supressNotify){
		this.listener = listener;
		this.bind = bind || this;
		this.id = id;
		
		if( !supressNotify ){
			this.notify(this.lastChange || {
				type: 'add',
				name: this.name,
				oldValue: undefined,
				value: undefined,
				object: this.object
			});
		}
	},

	onchange: function(change){
		this.notifyChange({
			type: change.name in this.model ? 'update' : 'add',
			name: change.name,
			oldValue: change.oldValue,
			value: change.object[change.name],
			object: change.object
		});
	},

	isPrimitive: function(value){
		var type = typeof value;
		return type == 'number' || type == 'boolean' || type == 'string';
	},

	setModel: function(model){
		this.unsetModel(true);
		this.model = model;
		this.hasModel = true;

		var change = {
			type: 'add',
			name: this.name,
			oldValue: undefined,
			value: undefined,
			object: object
		};
		var has;

		// '{} or {user.}' means bind to the model, in fact means bind to model.toString()
		if( this.name === '' ){
			change.value = model;
		}
		// primitive cant' be watched but does have properties
		else if( this.isPrimitive(model) ){
			change.value = model[this.name];
		}
		// object, function, primitive
		else{
			// null & undefined cant' be watched and dont have any properties
			if( model === null || model === undefined ){
				has = false;
			}
			// object, function
			else{
				this.observer = this.Observer.new(model, this.name).observe(this.onchange, this);
				
				has = this.name in model;

				if( has ){
					change.value = model[this.name];
				}			
			}

			// model doesn't have the property but the previous model had it
			if( has === false && this.lastChange ){
				change.type = 'delete'; // we lost the pointer on that property
				change.oldValue = this.lastChange.value;
				change.model = this.lastChange.model;
			}
			// else dont touch change			
		}		

		return this.notifyChange(change);
	},

	unsetModel: function(supressNotify){
		if( this.hasModel ){

			if( this.observer != null ){
				this.observer.unobserve(this.onchange);
				this.observer = null;
			}
			// close the model if model is a ComputedBinding
			if( typeof this.model.close == 'function' ){
				this.model.close();
			}

			this.model = null;

			if( !supressNotify && this.lastChange ){
				this.notifyChange({
					type: 'delete',
					name: this.name,
					oldValue: this.lastChange.value,
					value: undefined,
					object: this.lastChange.object
				});
			}
		}
	},

	close: function(){
		if( this.closed === false ){
			this.unsetModel(true);
			this.closed = true;
		}
	}
});

module.exports = PropertyPartObserver;
