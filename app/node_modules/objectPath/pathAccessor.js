/*

Same as ObjectPath except same path returns same instance
(usefull when path matters and the object on wich it's tested)

*/

var ObjectPath = require('./objectPath');
var PathAccessor = ObjectPath.extend({
	cache: {},
	new: function(path){
		if( path in this.cache ){
			return this.cache[path];
		}
		return this.cache[path] = ObjectPath.new.call(this, path);
	}
});

module.exports = PathAccessor;

/**
*/

var PathAccessor = PathAccessor;
var Template = require('stringTemplate').extend({
	open: '{{',
	close: '}}',

	replacer: function(match, value){
		var path = PathAccessor.new(value).setModel(this);

		// dont replace {{name}} when name does not exists in this
		if( path.has() ){
			value = path.get();
			return value == null ? '' : value;
		}
		return match;
	}
});

String.implement('render', function(object){
	return Template.new(this).render(object);
});

/**

Sort an array towards the properties of object he contains

orderBy('name');
orderBy('name');
orderBy('name', 'index', -1, function(a){ return a.name.toLowerCase(); }, 'getCount()');

*/
Array.getComparer = function(){
	var i, n, j = arguments.length, fns = [], orders = [], arg;

	i = n = 0;

	for(;i<j;i++){
		arg = arguments[i];
		switch(typeof arg){
		case 'string':
			arg = function(accessor, item){
				return accessor.setModel(item).get();
			}.curry(PathAccessor.new(arg));
			break;
		case 'function':
			fns[n++] = arg;
			break;
		case 'number':
			if( n ) orders[n-1] = arg;
			break;
		}
	}

	function compare(a,b){
		var calc, va, vb;
		for(i=0;i<n;i++){
			calc = fns[i];
			va = calc.call(a, a);
			vb = calc.call(b, b);

			if( va > vb ) return orders[i] || 1;
			if( va < vb ) return -(orders[i] || 1);
		}
		return 0;
	}

	return compare;
};

Array.implement('orderBy', function(){
	return this.sort(Array.getComparer.apply(Array, arguments));
});