/*

name: keys

description: Help to manipulate object keys, required almost everywhere

provides:
	ownKeys, eachOwnKey, iterateKey, eachOwnKeyIn
	appendKey, append, completeKey, complete
	implementKey, implement, complementKey, complement

*/

var keys = {
	ownKeys: 'getOwnPropertyNames' in Object ? Object.getOwnPropertyNames : Object.keys,

	eachOwnKey: function(object, fn, bind){
		var keys = this.ownKeys(object), i = 0, j = keys.length, key;

		for(;i<j;i++){
			key = keys[i];
			fn.call(bind, key, object);
		}

		return object;
	},

	iterateKey: function(keyIterator, array, fn, bind){
		var i = 0, j = array.length, item;

		for(;i<j;i++){
			item = array[i];
			if( item instanceof Function ) item = item.prototype;

			switch(typeof item){
			case 'string':
				var temp = {};
				temp[item] = array[++i];

				fn.call(bind, item, temp);
				break;
			case 'object':
				keyIterator.call(this, item, fn, bind);
				break;
			}
		}
	},

	eachOwnKeyIn: function(array, fn, bind){
		return this.iterateKey(this.eachOwnKey, array, fn, bind);
	},

	append: function(object){
		this.eachOwnKeyIn(Array.prototype.slice.call(arguments, 1), this.appendKey, object);
		return object;
	},

	complete: function(object){
		this.eachOwnKeyIn(Array.prototype.slice.call(arguments, 1), this.completeKey, object);
		return object;
	},

	implement: function(object){
		this.eachOwnKeyIn(Array.prototype.slice.call(arguments, 1), this.implementKey, object.prototype);
		return this;
	},

	complement: function(object){
		this.eachOwnKeyIn(Array.prototype.slice.call(arguments, 1), this.complementKey, object.prototype);
		return this;
	}
};

// avoir custom getter being called
keys.cloneDescriptor = function(descriptor){
	var clone = {}, keys, i, j, key;

	keys = keys.ownKeys(descriptor);
	i = 0;
	j = keys.length;

	for(;i<j;i++){
		key = keys[i];
		clone[key] = descriptor[key];
	}

	if( !descriptor.set ) delete descriptor.set;

	return clone;
};

if( 'getOwnPropertyDescriptor' in Object ){

	keys.appendKey = function(key, object){
		if( object ){
			var descriptor = Object.getOwnPropertyDescriptor(object, key);
			// not needed as we want the same descriptor as source
			//descriptor = keys.cloneDescriptor(descriptor);
			Object.defineProperty(this, key, descriptor);
		}
		else{
			this[key] = object[key];
		}
	};

	keys.implementKey = function(key, object){
		var descriptor;

		if( object ){
			descriptor = Object.getOwnPropertyDescriptor(object, key);
			// don't put enumerable = false on source descriptor
			descriptor = keys.cloneDescriptor(descriptor);
			descriptor.enumerable = false;
		}
		else{
			descriptor = {enumerable: false,  configurable: true, writable: true, value: object[key]};
		}

		Object.defineProperty(this, key, descriptor);
	};

}
else{

	keys.appendKey = keys.implementKey = function(key, object){
		this[key] = object[key];
	};

}

keys.completeKey = function(key){
	// set key/value pair in this if not existing
	if( !(key in this) ){
		keys.appendKey.apply(this, arguments);
	}
	return this;
};

keys.complementKey = function(key){
	if( !(key in this) ){
		keys.implementKey.apply(this, arguments);
	}
	return this;
};

Object.append = keys.append.bind(keys);

module.exports = keys;