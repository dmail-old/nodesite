var proto = require('proto');
var ArrayIterator = proto.create({
	array: null,
	direction: 'next',
	sign: null,
	from: null,
	to: null,
	start: null,
	end: null,
	loopIndex: null,
	index: null,
	lastIndex: null,
	looped: false,
	done: {done: true},

	init: function(array, direction, from, to){
		if( array == null ){
			throw new TypeError("array is null or not defined");
		}

		direction = direction || this.direction;

		var length, sign, start, end;

		length = Object(array).length >>> 0;

		if( direction === 'next' ){
			sign = 1;
			start = -1;
			end = length - 1;
		}
		else{
			if( direction === 'both' ) to = true;
			sign = -1;
			start = length;
			end = 0;
		}

		//if( length === 0 ) return;

		// from should respect array limits
		if( typeof from != 'number' ) from = start;
		else if( sign == 1 ? from < start : from > start ) from = start;
		else if( sign == 1 ? from > end : from < end ) from = end;

		// if to === true we loop twice except if from == start as loop is useless
		if( to === true && from != start ) this.loopIndex = from;

		// to should respect array limits
		if( typeof to != 'number' ) to = end;
		else if( sign == 1 ? to > end : to < end ) to = end;
		else if( sign == 1 ? to < start : to > start ) to = start;

		// prevent infinite loop
		if( sign == 1 ? to < from : to > from ){
			to = from;
			this.loopIndex = null;
		}

		this.array = array;
		this.direction = direction;
		this.sign = sign;
		this.start = start;
		this.end = end;
		this.from = from;
		this.to = to;
	},

	reset: function(){
		this.index = this.from;
		this.lastIndex = this.to;
		this.looped = false;
	},
	
	next: function(){

		if( this.index === this.lastIndex ){
			if( this.looped === true || typeof this.loopIndex != 'number' ) return this.done;
			this.index = this.start;
			this.lastIndex = this.loopIndex;
			this.looped = true;
		}

		this.index+= this.sign;
		return {value: this.array[this.index], done: false};
	},

	// before es6
	forOf: function(fn, bind){
		this.reset();

		var next = this.next();

		while( next.done === false ){
			if( !fn || fn.call(bind, next.value, this.index, this.array) === true ) break;
			next = this.next();
		}

		return this;
	},

	// after es6, allow to write for(key of ArrayIterator.new(['a', 'b']))
	'@@iterator': function(){
		this.reset();
		return this;
	},
	
	toArray: function(){
		// TODO, return the iterator as Array (es6 would do Array.from(iterator))
	}
});

module.exports = ArrayIterator;	