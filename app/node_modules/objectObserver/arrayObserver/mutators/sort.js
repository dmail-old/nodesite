// sort an array with comparer and return the list of performed affectations
function sortWithAffectations(array, compare){
	var i = 0, j = array.length, pairs = [], pair, affectations = [];

	for(;i<j;i++){
		pairs[i] = [i, array[i]];
	}

	if( typeof compare != 'function' ) compare = Function.COMPARE;

	pairs.sort(function(a, b){
		return compare.call(array, a[1], b[1]);
	});

	i = 0;
	for(;i<j;i++){
		pair = pairs[i];
		affectations.push(pair[0], i);
		array[i] = pair[1];
	}

	return affectations;
}

/*
"affectation" refers to:
	assigning 0 at 1 in ['a', 'b', 'c'] gives -> ['a', 'a', 'c']
"move" refers to:
	moving 0 at 1 in ['a', 'b', 'c'] gives -> ['b', 'a', 'c']

This function take an array of affectations
[oldIndex, newIndex, ...]
and returns a list of moves
[oldIndex, newIndex, ...]
that correspond to those affectations
*/
function transformAffectationsToMoves(affectations){
	var i = 0, j = affectations.length, oldIndex, index;
	var trace = [], moves = [], from, to, gap, tempTrace, traceIndex, k, l;

	for(;i<j;i+=2){
		oldIndex = affectations[i];
		if( typeof trace[oldIndex] === 'number' ){
			oldIndex = trace[oldIndex];
		}
		index = affectations[i + 1];

		if( oldIndex == index ){
			// affectations made this move useless
		}
		else{
			moves.push(oldIndex, index);

			// the value is moved to the left or the right of it's current index
			if( index < oldIndex ){
				gap = 1;
			}
			else{
				gap = -1;
			}

			/*
			for this affectations, store trace in a tempTrace array, that will be merge with trace after
			else the trace array could contain two identical index
			thus making trace.indexOf(from); possibly return the wrong index location
			*/
			tempTrace = [];

			from = oldIndex;
			to = index;
			if( typeof trace[from] == 'number' ){
				traceIndex = trace.indexOf(from);
				if( traceIndex > -1 ){
					from = traceIndex;
				}
			}
			tempTrace.push(from, to);
			//console.log(oldIndex, 'becomes', index, loopTrace);

			while(index != oldIndex){
				from = index;
				to = index + gap;
				if( typeof trace[from] == 'number' ){
					traceIndex = trace.indexOf(from);
					if( traceIndex > -1 ){
						from = traceIndex;
					}
				}
				tempTrace.push(from, to);
				//console.log(index, 'becomes', index+gap, loopTrace);

				index+= gap;
			}

			k = 0;
			l = tempTrace.length;
			for(;k<l;k+=2){
				trace[tempTrace[k]] = tempTrace[k+1];
			}

			//console.log('move', value, 'from', oldIndex, 'to', affectations[i + 1]);
			//console.log('result', array);
			//console.log('trace', trace);
		}
	}

	return moves;
}

function performAffectations(affectations, from, into){
	var i = 0, j = affectations.length, oldIndex, index;

	from = from || this.array;

	for(;i<j;i+=2){
		oldIndex = affectations[i];
		index = affectations[i + 1];
		into[index] = from[index];
	}
}

module.exports = function(comparer){
	this.delayed = true;
	var affectations = sortWithAffectations(this.array, comparer);
	this.delayed = false;
	
	this.notify({
		type: 'affectations',
		value: affectations,

		toMoves: function(){
			return transformAffectationsToMoves(this.value);	
		},

		perform: function(from, into){
			return performAffectations(this.value, from, into);
		}
	});

	return this.array;
};