/*

NOTE:

VERY IMPORTANT: Cant catch the following:

- delete array[index] due to ObjectChangeEmitter limitations (Object.watch cant detect delete)
- array[index] = value where index is greater than array.length, value and previous values to array.length will be ignored
- array.length = Number where Number != array.length, thus adding or removing entries without being notified

REQUIRE:

object.js, object.at.js

USAGE:

var array = [];
var listener = function(change){
	// change has type, oldValue and value properties
};
var observer = ArrayObserver.new(array, listener);

*/

var ObjectChangeEmitter = require('./objectChangeEmitter');
var ArrayObserver = {
	array: null,
	listener: null,
	bind: null,
	methods: null,
	observer: null,
	delayed: false,
	closed: false,
	valueChangedType: 'update',
	mutators: require('./mutators')

	create: function(array, listener, bind){
		this.array = array;
		this.listener = listener;
		this.bind = bind || this;
		this.methods = {};
		this.observer = ObjectChangeEmitter.new(array);

		var i = 0, j = array.length;
		for(;i<j;i++){
			this.observeValueAt(i);
			this.notify({
				type: 'add',
				index: i,
				value: this.array[i]
			});
		}
		this.wrapAll();
	},

	close: function(){
		if( this.closed === false ){
			this.unwrapAll();

			var i = this.array.length;
			while(i--) this.unobserveValueAt(i);
			this.observer = null;

			this.array = null;
			this.listener = null;
			this.bind = null;
			this.methods = null;

			this.closed = true;
		}
	},

	notify: function(change){
		if( this.delayed === false && typeof this.listener == 'function' ){
			this.listener.call(this.bind, change);
		}
	},

	observeValueAt: function(index){
		this.observer.on(index, this);
	},

	unobserveValueAt: function(index){
		this.observer.off(index, this);
	},

	// we could wrap the Array.prototype directly too
	wrapAll: function(){
		for(var method in this.mutators ){
			this.wrap(method);
		}
	},

	unwrapAll: function(){
		for(var method in this.methods ){
			this.unwrap(method);
		}
	},

	wrap: function(method){
		this.methods[method] = this.array[method];
		this.array[method] = this.mutators[method].bind(this);
	},

	unwrap: function(method){
		this.array[method] = this.methods[method];
		delete this.methods[method];
	},

	applyMethod: function(method, args, supressDelay){
		if( !supressDelay ) this.delayed = true;
		var result = this.methods[method].apply(this.array, args);
		if( !supressDelay ) this.delayed = false;
		return result;
	},

	handleEvent: function(name, args){
		this.valueChanged.apply(this, args);
	},

	valueChanged: function(index, oldValue, value){
		this.notify({
			type: this.valueChangedType,
			index: index,
			oldValue: oldValue,
			value: value
		});
	}
};

module.exports = ArrayObserver;