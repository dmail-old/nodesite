ArrayObserver
=============

Observe array modifications.

## Requirements

- [ObjectChangeEmitter](../objectChangeEmitter)

## Example

```javascript
// will keep two array synchronised :)
Array.prototype.sync = function(array){
  ArrayObserver.new(this, function(change){
    if( change.type == 'affectations' ){
      change.perform(this, array);
    }
    else if( change.type == 'add' ){
      array[change.index] = change.value;
    }
    else if( change.type == 'update' ){
      array[change.index] = change.value;
    }
    else if( change.type == 'remove' ){
      array.splice(change.index, 1);
    }
  }, this);
  
  return array;
};

var array = ['a', 'b', 'c'];
var syncArray = array.sync([]);
array.reverse();

console.log(array, syncArray);
// logs: ['c', 'b', 'a'], ['c', 'b', 'a']
```

## Limitations:

ArrayObserver will fail in 3 case:

- delete array[index] due to [ObjectChangeEmitter](../objectChangeEmitter) limitations.
- array[index] = value when index is greater than array.length, value and previous values to array.length will be ignored
- array.length = Number when Number != array.length, thus adding or removing entries without being notified

## ArrayObserver.new(array, listener, bind)

- array: the array to observe
- listener: a function that will be called listener(change)
- bind: this value of listener

It will immediatly start to listen array changes and call listener

## ArrayObserver.close()

Stop listening to change on array and clean all.

## affectationChange

Reverse and sort emit affectationChange instead of regular change like update, add and remove.  
It's because reverse and sort use a serie of affectation to change values index.  
To do what you want with this serie of affectation affectationChange are used.

## affectationChange.value

An array containing the serie of affectation done by reverse() or sort().
It looks like [0,1,1,2] wich means affect 0 to 1 then 1 to 2.

## affectationChange.perform(fromArray, targetArray)

Perform the affectations that happened in fromArray, into targetArray. 
Values are read in fromArray and affected in the targetArray.

## affectationChange.toMoves()

Transform the serie of affectation into a serie of moves.  
Performing moves is very easy then:

```javascript
var array; // this array want to perform affectations but as moves
var moves = affectationChange.toMoves().forEach(function(move){
  var from = move[0], to, = move[1];
  if( from != to ){
    var value = array[from];
    array.splice(from, 1);
    array.splice(to, 0, value);
  }
});
```

