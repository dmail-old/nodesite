exports['cache call getter on demand, even on child objects'] = function(test){
	var object = {};
	var count = 0;
	var value;
	var child = Object.create(object);
	var childValue;
	var getterValue = 'foo';
	
	test.imports.new(object, 'cached').define({
		get: function(){
			count++;
			return getterValue;
		},
		cache: true
	});

	value = object.cached;
	value = object.cached;
	childValue = child.cached;
	object.cached = 'bar';

	test.equal(value, getterValue);	
	test.equal(childValue, getterValue);
	test.equal(child.cached, 'bar');
	test.equal(count, 1);

	test.done();
};

exports['cache of composed properties invalidation'] = function(test){
	var object = {};
	var child = Object.create(object);
	var count = 0;
	var fullName;
	var definition = test.imports.new(object, 'fullName').define({
		subproperties: ['firstName', 'lastName'],
		get: function(firstName, lastName){
			count++;
			return firstName + ' ' + lastName;
		},
		cache: true
	});

	object.firstName = 'damien';
	object.lastName = 'maillard';
	fullName = object.fullName;

	test.equal(definition.cache.has(object), true);
	test.equal(definition.cache.has(child), true);

	object.firstName = 'sandra';
	// firstName of object has been modified, cache for child & object for 'fullName' expires

	test.equal(definition.cache.has(object), false);
	test.equal(definition.cache.has(child), false);

	child.lastName = 'machefer';
	fullName = child.fullName;
	object.lastName = 'grassiot';

	// lastName of object has been modified but child.lastName exists, cache is still valid
	test.equal(definition.cache.has(child), true);

	test.done();
};