exports['customProperty is set in the propertyDescriptor and can be copied'] = function(test){
	var a = {};
	var customProperty = new test.imports(a, 'name');
	customProperty.define({cache: true, get: function(){ return 'foo'; }});
	var b = {};

	Object.defineProperty(b, 'name', Object.getOwnPropertyDescriptor(a, 'name'));

	test.equal(customProperty.fromObject(b), customProperty);
};

exports['customProperty get/set right value'] = function(test){
	var object = {};
	var a = Object.create(object);
	var b = Object.create(object);
	var customProperty = new test.imports(object, 'name').define({});

	a.name = 'foo';
	b.name = 'bar';
	test.equal(a.name, 'foo');
	test.equal(b.name, 'bar');
};

exports['observe + unobserve restore the property'] = function(test){
	var object = {};
	var child = Object.create(object);
	var listener = function(){};
	var def = new test.imports(object, 'name');

	def.addListener(listener);
	object.name = 'foo';
	def.removeListener(listener);

	test.equal('name' in child, false);
	test.equal(object.name, 'foo');
};

exports['cache call getter on demand, even on child objects'] = function(test){
	var object = {};
	var count = 0;
	var value;
	var child = Object.create(object);
	var childValue;
	var getterValue = 'foo';
	
	new test.imports(object, 'cached').define({
		get: function(){
			count++;
			return getterValue;
		},
		cache: true
	});

	value = object.cached;
	value = object.cached;
	childValue = child.cached;
	object.cached = 'bar';

	test.equal(value, getterValue);	
	test.equal(childValue, getterValue);
	test.equal(child.cached, 'bar');
	test.equal(count, 1);
};

exports['cache of composed properties invalidation'] = function(test){
	var object = {};
	var child = Object.create(object);
	var count = 0;
	var fullName;
	var definition = new test.imports(object, 'fullName').define({
		subproperties: ['firstName', 'lastName'],
		get: function(firstName, lastName){
			count++;
			return firstName + ' ' + lastName;
		},
		cache: true
	});

	object.firstName = 'damien';
	object.lastName = 'maillard';
	fullName = object.fullName;

	test.equal(definition.cache.has(object), true);
	test.equal(definition.cache.has(child), true);

	object.firstName = 'sandra';
	// firstName of object has been modified, cache for child & object for 'fullName' expires

	test.equal(definition.cache.has(object), false);
	test.equal(definition.cache.has(child), false);

	child.lastName = 'machefer';
	fullName = child.fullName;
	object.lastName = 'grassiot';

	// lastName of object has been modified but child.lastName exists, cache is still valid
	test.equal(definition.cache.has(object), false);
	test.equal(definition.cache.has(child), true);
};