/*

NOTES:
observer une propriété dans un objet apelle le listener pour les objets en héritant par prototype
observer une propriété puis redéfinir la propriété détruit les observeurs de cette propriété
	-> en résumé on peut faire defineCustomProperty() puis observeProperty
	-> mais on ne peut pas le faire dans l'ordre inverse (observeProperty puis defineCustomProperty)

A FAIRE:
- Mettre au propre le fonctionnement actuel sans fixer pour le moment les deux points suivants
- Fix le problème de cache : 
	var parent = {firstName: 'a', lastName: 'b'};
	parent.fullName; // cache du parent
	var child = Object.create(parent);
	child.firstName = 'foo';
	// le cache de child est delete sauf que child n'a pas de cache
	// le cache du parent n'est pas delete, à juste titre, le parent n'a pas été modifié
	child.fullName; // conséquence -> retourne le cache du parent alors que child.firstName est !=
	
	solutions :
	1 - supprimer le cache du parent même si en fait il est valide
		+ très simple
		+ pas très couteux puisque seul le parent doit recalculer le résultat
		- on perd quelque chose qui était en cache bètement
	2 - avoir une propriété qui dit que cet objet ne peut plus bénéficier du cache du parent
		+ le cache est bien invalidé que pour l'enfant et pas le parent
		- couteux en perf : a priori ette propriété est pénible à lier à l'objet
	3 - Le cache ne concerne que les valeurs des sous-propriétés et pas l'objet
		+ Le cache est partagé parmi toutes les instances -> bonnes perfs
		+ 
		- Le cache n'est plus lié à l'objet, ou alors il faut instancier un cache par objet

- Mettre en place le fait qu'on observe le parent lorsque l'object n'a pas la prop
- Proposer un 3ème type de cache : 'arguments' qui met en cache la valeur des arguments
mais ne tiens pas compte de l'instance
	voir même 'this', 'arguments', 'this+arguments'
	this -> le cache actuel
	arguments -> le cache qui ne dépend pas de l'objet et qui check que les arguments
	this+arguments -> le cache qui dépend de l'object et check aussi les arguments

*/

var proto = require('proto');

var Cache = proto.create({
	cachedObject: null,
	objects: null,
	values: null,
	index: null,

	init: function(object){
		this.cachedObject = object;
		this.objects = [];
		this.values = [];
	},

	hasOwn: function(object){
		var index = this.objects.indexOf(object);
		this.index = index;
		return index !== -1;
	},

	has: function(object){

		while( this.hasOwn(object) === false ){
			object = Object.getPrototypeOf(object);
			if( object === this.cachedObject ) break;
			if( object === null ){
				throw new Error('object not child of cachedObject');
			}
		}

		return this.index != -1;
	},

	get: function(object, has){
		if( has === true || this.has(object) ) return this.values[this.index];
		return null;
	},

	set: function(object, value){
		if( this.has(object) ){
			this.values[this.index] = value;
		}
		else{
			this.objects.push(object);
			this.values.push(value);
		}
	},

	delete: function(object){		
		if( this.hasOwn(object) ){ // delete own cache, never parent cache, like delete operator on property
			this.objects.splice(this.index, 1);
			this.values.splice(this.index, 1);
			return true;
		}
		return false;
	},

	clear: function(){
		this.objects.length = this.values.length = 0;
	}
});

var OnceCache = proto.create({
	exists: false,
	value: null,

	init: function(){

	},

	has: function(object){
		return this.exists === true;
	},

	get: function(object, has){
		return has === true || this.has(object) ? this.value : null;
	},

	set: function(object, value){
		this.exists = true;
		this.value = value;
	},

	delete: function(object){
		this.exists = false;
		this.value = null;
	},

	clear: function(){
		this.delete();
	}
});

var Getters = {
	computed: function(object){
		var values = this.descriptor.subproperties.map(function(name){
			return object[name];
		});

		return this.descriptor.get.apply(object, values);
	},

	accessor: function(object){
		return this.descriptor.get.call(object);
	},

	value: function(object){
		return this.descriptor.value;
	},

	cache: function(object){
		var value;

		if( this.cache.has(object) ){
			value = this.cache.get(object, true);
		}
		else{
			value = this.getter(object);
			this.cache.set(object, value);
		}

		return value;
	}
};

var Setters = {
	computed: function(object, value){
		var values = this.descriptor.set.call(object, value);

		if( !Array.isArray(values) || values.length != this.subproperties.length ){
			throw new TypeError(this.messages.invalidSetLength);
		}

		var i = 0, j = values.length;
		for(;i<j;i++){
			object[this.subproperties[i]] = values[i];
		}
	},

	accessor: function(object, value){
		this.descriptor.set.call(object, value);
	},

	value: function(object, value){
		this.descriptor.value = value;
	},

	cache: function(object, value){
		this.cache.set(object, value);
		this.setter(object, value);
	}
};

var CustomPropertyDefinition = proto.create({
	object: null,
	name: null,
	oldDescriptor: null, // the old propertyDescriptor
	descriptor: null, // the customDescriptor
	propertyDescriptor: null, // the current porpertyDescriptor	
	cache: null,
	notifier: null,
	messages: {
		invalidObject: 'customProperty object must be an object',
		invalidDescriptor: 'customProperty descriptor is not a non null object',
		unspecifiedGet: 'customProperty descriptor must specify when cache or subproperties is specified',
		unspecifiedAccessor: 'customeProperty must sepcify a getter or a setter when subproperties is specified',
		invalidGetLength: 'customProperty descriptor get length must be equal to subproperties.length',
		invalidSetLength: 'customProperty descriptor set must return an array with length = subproperties.length',
		neverChanges: 'customProperty descriptor onchange will never be called because writable = false',
		inextensible: 'object is not extensible'
	},

	init: function(object, name){
		if( Object(object) != object ){
			throw new TypeError(this.messages.invalidObject);
		}
		if( Object.isExtensible(object) === false ){
			throw new TypeError(this.messages.inextensible);
		}

		name = String(name);

		this.object = object;
		this.name = name;
	},	

	getter: null,
	get: null,
	createGetter: function(){
		if( this.descriptor.get ){
			this.getter = Getters[this.descriptor.subproperties ? 'computed' : 'accessor'];
		}
		else{
			this.getter = Getters.value;
		}
		this.get = this.cache === null ? this.getter : Getters.cache;

		var self = this;
		return function(){
			return self.get(this);
		};
	},

	setter: null,
	set: null,
	createSetter: function(){
		if( this.descriptor.set ){
			this.setter = Setters[this.descriptor.subproperties ? 'computed' : 'accessor'];
		}
		else{
			this.setter = Setters.value;
		}
		this.set = this.cache === null ? this.setter : Setters.cache;

		var self = this;
		return function(value){
			return self.set(this, value);			
		};
	},

	getFromPropertyDescriptor: function(propertyDescriptor){
		var get, customPropertyDefinition = null;

		if( 'get' in propertyDescriptor ){
			get = propertyDescriptor.get;
			if( 'customPropertyDefinition' in get ){
				customPropertyDefinition = get.customPropertyDefinition;
			}
		}

		return customPropertyDefinition;
	},

	setInPropertyDescriptor: function(propertyDescriptor){
		propertyDescriptor.get.customPropertyDefinition = this;
	},

	createPropertyDescriptor: function(descriptor){
		var propertyDescriptor = {
			get: this.createGetter(),
			set: this.createSetter()
		};

		['writable', 'configurable', 'enumerable', 'value'].forEach(function(key){
			if( key in descriptor ) propertyDescriptor[key] = descriptor[key];
		});

		return propertyDescriptor;
	},

	rollback: function(){
		if( this.oldDescriptor !== null ){
			Object.defineProperty(this.object, this.name, this.oldDescriptor);
			this.oldDescriptor = null;
		}
		else{
			delete this.object[this.name];
		}
	},

	createCache: function(object, name, descriptor){
		var cache = null, type = descriptor.cache;

		if( type !== false ){
			if( false === 'get' in descriptor ){
				throw new TypeError(this.messages.unspecifiedGet);
			}

			if( type === 'once' ){
				cache = OnceCache.new(object);
			}
			else if( type === true ){
				cache = Cache.new(object);
			}

			if( 'value' in descriptor ){
				cache.set(object, descriptor.value);
			}
		}

		return cache;
	},

	invalidCacheWhenSubPropertyChange: function(object, subproperties){
		throw new Error('unimplemented');
	},

	createSubProperties: function(object, name, descriptor){
		var subproperties = descriptor.subproperties;

		if( 'get' in descriptor && subproperties.length != descriptor.get.length ){
			throw new TypeError(this.messages.invalidGetLength);
		}
		else if( false === 'set' in descriptor ){
			throw new TypeError(this.messages.unspecifiedAccessor);
		}

		if( this.cache ){
			this.invalidCacheWhenSubPropertyChange(object, subproperties);
		}
	},

	propertyChanged: function(change){
		// lorsqu'on observe la propriété il faut la recalculer dès qu'une sous propriété change
		if( this.notifier && this.notifier.size !== 0 ){
			// we call this.set normally, but this.getter to bypass the cache
			this.set(change.object, this.getter(change.object));
		}
		else if( this.cache ){
			this.cache.delete(change.object);
		}
	},

	setProperty: function(object, value, previous){
		var oldValue = object[this.name];

		if( oldValue !== value ){
			previous(object, value);

			this.notifier.notify({
				type: 'update',
				name: this.name,
				oldValue: oldValue,
				value: value,
				object: object
			});
		}

		if( this.object != object ){
			Observer.observeProperty(object, this.name, this, 'propertyChanged');
		}
	},

	addObservability: function(){
		this.addSetter(this.setProperty);
	},

	removeObservability: function(){
		this.removeSetter(this.setProperty);
	},

	define: function(descriptor){
		var object = this.object, name = this.name;

		this.oldDescriptor = Object.getOwnPropertyDescriptor(object, name);

		if( arguments.length === 0 ){
			descriptor = this.oldDescriptor || {};
		}
		else{
			if( Object(descriptor) != descriptor ){
				throw new TypeError(this.messages.invalidDescriptor);
			}			
			// cache
			if( 'cache' in descriptor ){
				this.cache = this.createCache(object, name, descriptor);
			}
			// subproperties
			if( 'subproperties' in descriptor ){
				this.subproperties = this.createSubProperties(object, name, descriptor);	
			}
		}
		
		this.descriptor = descriptor;
		this.propertyDescriptor = this.createPropertyDescriptor(descriptor);		
		this.setInPropertyDescriptor(this.propertyDescriptor);
		Object.defineProperty(object, name, this.propertyDescriptor);

		return this;
	}
});

var Notifier = proto.create({
	listeners: null,
	bindings: null,
	index: null,
	lastChange: null,

	init: function(){
		this.listeners = [];
		this.bindings = [];
	},

	get size(){
		return this.listeners.length;
	},

	hasListener: function(fn, bind){
		var listeners = this.listeners, bindings = this.bindings, index = listeners.length;

		while(index--){
			if( listeners[index] === fn && bindings[index] === fn ) break;
		}

		this.index = index;

		return index;
	},

	addListener: function(fn, bind){
		if( this.hasListener(fn, bind) ){
			return false;
		}
		else{
			this.listeners.push(fn);
			this.bindings.push(bind);
			return true;
		}
	},

	removeListener: function(fn, bind){
		if( arguments.length === 0 ){
			if( this.size !== 0 ){
				this.listeners.length = this.bindings.length = 0;
				return true;
			}
		}
		else if( this.hasListener(fn, bind) ){
			this.listeners.splice(this.index, 1);
			this.bindings.splice(this.index, 1);
			return true;			
		}

		return false;
	},

	notify: function(change, listenerType){
		var listeners = this.listeners, bindings = this.bindings, i = 0, j = listeners.length, listener;

		this.lastChange = change;
		for(;i<j;i++){
			listener = listeners[i];
			if( typeof listener == 'object' ){
				listener[bindings[i]](change);
			}
			else{
				listener.call(bindings[i], change);
			}
		}

		return this;
	}
});

var Observer = {
	observeProperty: function(object, name, fn, bind){
		
		// si cet objet n'a pas la propriété, cherche un parent où mettre cette propriété
		// on gèreras ça à la fin
		/*
		var proto = object;
		while( !Object.prototype.hasOwnProperty.call(proto, name) ){
			proto = Object.getPrototypeOf(proto);
			if( proto === null ){
				proto = object;
				break;
			}
		}
		*/
		// en fait ici on peut reprendre la logique tel quel de
		// propertyObserver, qui va apeller observeProperty sur le parent
		// qui va remove l'observer lorsqu'il est set pour la première fois

		var propertyDescriptor = Object.getOwnPropertyDescriptor(proto, name), customDefinition, notifier;

		if( propertyDescriptor ){
			customDefinition = CustomPropertyDefinition.getFromPropertyDescriptor(propertyDescriptor);
		}
		if( customDefinition === null ){
			customDefinition = CustomPropertyDefinition.new(proto, name);
			customDefinition.define(propertyDescriptor || {});
		}
		if( customDefinition.descriptor.writable === false ){
			throw new TypeError(CustomPropertyDefinition.messages.neverChanges);
		}

		notifier = customDefinition.notifier;

		if( notifier === null ){
			notifier = Notifier.new();
			customDefinition.notifier = notifier;			
		}

		// first time the propery is observed
		if( notifier.size === 0 ){
			customDefinition.addObservability();
		}

		return notifier.addListener(fn, bind);
	},

	canRollBack: function(customDefinition){
		// we can rollback when the property don't use cache nor subproperties
		if( customDefinition.descriptor === customDefinition.oldDescriptor ) return true; // special fast case
		return customDefinition.cache === null && customDefinition.subproperties === null;
	},

	unobserveProperty: function(object, name, fn, bind){
		var propertyDescriptor = Object.getOwnPropertyDescriptor(object, name);
		if( propertyDescriptor === null ) return false;
		var customDefinition = CustomPropertyDefinition.getFromPropertyDescriptor(propertyDescriptor);
		if( customDefinition === null ) return false;
		var notifier = customDefinition.notifier;
		if( notifier === null ) return false;
		if( notifier.removeListener(fn, bind) === false ) return false;

		if( notifier.size === 0 ){
			customDefinition.removeObservability();
			// on a définie une propriétée dont on n'a plus besoin
			// faut remettre la propriété a son état d'origine
			if( this.canRollBack(customDefinition) ){
				customDefinition.rollback();
			}
		}

		return true;
	}
};

module.exports = CustomPropertyDefinition;