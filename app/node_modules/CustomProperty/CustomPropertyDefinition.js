/*

*/

var proto = require('proto');

var ObjectCache = proto.create({
	value: undefined,
	exists: null,

	has: function(){
		return this.exists === true;
	},

	get: function(){
		return this.value;
	},

	set: function(value){
		this.exists = true;
		this.value = value;
	},

	delete: function(){
		if( this.has() ){
			this.exists = false;
			this.value = undefined;
			return true;
		}
		return false;	
	}
});

var CustomPropertyDefinition = proto.create({
	Getters: {
		computed: function(object){
			var values = this.descriptor.subproperties.map(function(name){
				return object[name];
			});

			return this.descriptor.get.apply(object, values);
		},

		accessor: function(object){
			return this.descriptor.get.call(object);
		},

		value: function(object){
			return this.descriptor.value;
		}
	},
	Setters: {
		computed: function(value, object){
			var values = this.descriptor.set.call(object, value);

			if( Array.isArray(values) && values.length != this.subproperties.length ){
				throw new TypeError(this.messages.invalidSetLength);
			}

			var i = 0, j = values.length;
			for(;i<j;i++){
				object[this.subproperties[i]] = values[i];
			}
		},

		accessor: function(value, object){
			this.descriptor.set.call(object, value);
		},

		value: function(value, object){
			this.descriptor.value = value;
		}
	},
	Notifier: require('Notifier'),

	object: null,
	name: null,
	oldDescriptor: null, // the old propertyDescriptor
	descriptor: null, // the customDescriptor
	propertyDescriptor: null, // the current porpertyDescriptor	
	cache: null,
	notifier: null,
	subproperties: null,
	isHeritable: true,
	parent: null,
	filterParents: [Function, Boolean, Array, Object, RegExp, Error, String, Number].map(function(o){
		return o.prototype;
	}),
	traceChildren: !false, // by default, don't trace children to avoid garbage collection issue
	children: null, // array of object who inherited from this property
	messages: {
		invalidObject: 'customProperty object must be an object',
		invalidDescriptor: 'customProperty descriptor is not a non null object',
		unspecifiedGet: 'customProperty descriptor must specify when cache or subproperties is specified',
		unspecifiedAccessor: 'customeProperty must sepcify a getter or a setter when subproperties is specified',
		invalidGetLength: 'customProperty descriptor get length must be equal to subproperties.length',
		invalidSetLength: 'customProperty descriptor set must return an array with length = subproperties.length',
		neverChanges: 'customProperty descriptor onchange will never be called because writable = false',
		inextensible: 'object is not extensible'
	},

	constructor: function(object, name){
		if( Object(object) != object ){
			throw new TypeError(this.messages.invalidObject);
		}
		if( Object.isExtensible(object) === false ){
			throw new TypeError(this.messages.inextensible);
		}

		name = String(name);

		this.object = object;
		this.name = name;
	},

	createParent: function(object){
		var parent = new this.constructor(object, this.name);
		return parent;
	},

	createChild: function(object){
		var child = new this.constructor(object, this.name);
		var childDescriptor = {};
		for(var key in this.descriptor ) childDescriptor[key] = this.descriptor[key];

		child.define(childDescriptor);
	
		if( this.notifier ){
			child.notifier = this.notifier;
		}

		return child;
	},

	addChild: function(object){
		var child = this.createChild(object);
		if( this.traceChildren ) this.children.push(child);
		return child;
	},

	getValue: null,

	getValueGetter: function(descriptor){
		if( descriptor.get ){
			return this.Getters[this.descriptor.subproperties ? 'computed' : 'accessor'];
		}
		
		return this.Getters.value;
	},

	get: function(object){
		var value;

		if( this.cache !== null ){
			if( this.cache.has() ){
				value = this.cache.get(true);
			}
			else{
				value = this.getValue(object);
				this.cache.set(value);
			}
		}
		else{
			value = this.getValue(object);
		}

		return value;
	},

	createGetter: function(){
		var self = this;
		return function(){
			return self.get(this);
		};
	},

	setValue: null,

	getValueSetter: function(descriptor){
		if( 'set' in descriptor ){
			return this.Setters[descriptor.subproperties ? 'computed' : 'accessor'];
		}
		return this.Setters.value;
	},

	set: function(value, object){
		if( this.object !== object ){ // happen once per object because after this object got his own setter
			if( this.isHeritable ){
				this.addChild(object).set(value, object);
			}
			else{
				Object.defineProperty(object, this.name, {value: value});
			}
		}
		else{
			var notify = false, oldValue;

			if( this.notifier && this.notifier.size !== 0 ){
				oldValue = object[this.name]; // this.get(object) ne marcherais pas pour object != this.object
				if( oldValue === value ) return;
				notify = true;			
			}

			if( this.cache !== null ){
				this.cache.set(value, object);
			}
			this.setValue(value, object);
			
			if( notify ){
				this.notifier.notify({
					type: 'update',
					name: this.name,
					oldValue: oldValue,
					value: value,
					object: object
				});
			}
		}
	},

	createSetter: function(){
		var self = this;
		return function(value){
			return self.set(value, this);			
		};
	},

	propertyChanged: function propertyChanged(change){
		// lorsqu'on observe la propriété il faut la recalculer dès qu'une sous propriété change
		if( this.notifier && this.notifier.size !== 0 ){
			change.object[this.name] = this.getValue(change.object);
		}
		else if( this.cache ){
			if( change.object === this.object ){
				this.cache.delete();
			}
			else{
				// le cache a changé dans un enfant
				// le cache n'est plus héritable, mais que pour cet objet
				this.addChild(change.object);
			}
		}
	},

	removeParentListener: function removeParentListener(){
		if( this.parent.parent ) this.parent.removeParentListener();
		this.parent.removeListener(this.onParentChange, this);
		this.notifier.remove(this.removeParentListener, this);
	},

	onParentChange: function onParentChange(change){
		this.removeParentListener();
		this.notifier.notify(change);
	},		

	addListener: function(fn, bind){
		if( this.notifier === null ){
			this.notifier = new this.Notifier();			
		}

		if( this.descriptor === null ){ // there is no descriptor
			if( !Object.prototype.hasOwnProperty.call(this.object, this.name) ){
				var proto = Object.getPrototypeOf(this.object);
				if( proto !== null && this.filterParents.indexOf(proto) === -1 ){
					this.parent = this.fromObject(proto, this.name);
					if( this.parent === null ){
						this.parent = new CustomPropertyDefinition(proto, this.name).define();
					}

					this.notifier.add(this.removeParentListener, this);
					// lorsque le parent change on peut supprimer la prop
					this.parent.addListener(this.onParentChange, this);
				}
			}
			
			this.define();
		}
		else if( this.descriptor.writable === false ){
			throw new TypeError(this.messages.neverChanges);
		}		

		return this.notifier.add(fn, bind);
	},

	removeListener: function(fn, bind){
		var notifier = this.notifier;
		if( notifier === null ) return false;
		if( notifier.remove(fn, bind) === false ) return false;
		// a customProperty was set to be observed, but there is no listener anymore
		if( notifier.size === 0 ) this.checkRollBack();

		return true;
	},

	fromPropertyDescriptor: function(propertyDescriptor){
		var get, customPropertyDefinition = null;

		if( 'get' in propertyDescriptor ){
			get = propertyDescriptor.get;
			if( 'customPropertyDefinition' in get ){
				customPropertyDefinition = get.customPropertyDefinition;
			}
		}

		return customPropertyDefinition;
	},

	fromObject: function(object, name){
		var propertyDescriptor = Object.getOwnPropertyDescriptor(object, name);
		if( propertyDescriptor ){
			return this.fromPropertyDescriptor(propertyDescriptor);
		}
		return null;
	},

	setInPropertyDescriptor: function(propertyDescriptor){
		propertyDescriptor.get.customPropertyDefinition = this;
	},

	assignDescriptor: function(to, from){
		['writable', 'configurable', 'enumerable', 'value', 'set', 'get'].forEach(function(key){
			if( key in from ) to[key] = from[key];
		});
		return to;
	},

	createPropertyDescriptor: function(descriptor){
		var propertyDescriptor = this.assignDescriptor({}, descriptor);

		propertyDescriptor.get = this.createGetter();
		propertyDescriptor.set = this.createSetter();
		delete propertyDescriptor.value;
		delete propertyDescriptor.writable;

		if( !('configurable' in propertyDescriptor) ) propertyDescriptor.configurable = true;

		return propertyDescriptor;
	},

	checkRollBack: function(){
		if( this.cache === null && this.subproperties === null ){
			this.rollback();
		}
	},

	rollback: function(){
		if( this.children ) this.children.forEach(function(child){ child.rollback(); });

		var customDescriptor = this.descriptor;

		if( !('set' in customDescriptor) && !('get' in customDescriptor) && !('value' in customDescriptor) ){
			delete this.object[this.name];
		}
		else{
			Object.defineProperty(this.object, this.name, this.assignDescriptor(this.oldDescriptor || {}, customDescriptor));
		}
	},

	invalidCacheWhenSubPropertyChange: function(object, subproperties){
		subproperties.forEach(function(propertyName){
			API.addPropertyListener(object, propertyName, this.propertyChanged, this);
		}, this);
	},

	define: function(descriptor){
		var object = this.object, name = this.name;

		this.oldDescriptor = Object.getOwnPropertyDescriptor(object, name);

		if( arguments.length === 0 ){
			descriptor = this.oldDescriptor || {};
		}
		else{
			if( Object(descriptor) != descriptor ){
				throw new TypeError(this.messages.invalidDescriptor);
			}			
			// cache
			if( 'cache' in descriptor && descriptor.cache ){
				if( false === 'get' in descriptor ){
					throw new TypeError(this.messages.unspecifiedGet);
				}
				this.cache = new ObjectCache();
				if( 'value' in descriptor ){
					this.cache.set(descriptor.value);
				}
			}
			// subproperties
			if( 'subproperties' in descriptor ){
				if( 'get' in descriptor ){
					if( descriptor.subproperties.length != descriptor.get.length ){
						throw new TypeError(this.messages.invalidGetLength);
					}
				}
				else if( false === 'set' in descriptor ){
					throw new TypeError(this.messages.unspecifiedAccessor);
				}

				if( this.cache ){
					this.invalidCacheWhenSubPropertyChange(object, descriptor.subproperties);
				}
			}
		}

		if( this.isHeritable && this.traceChildren ) this.children = [];
		
		this.descriptor = descriptor;
		this.setValue = this.getValueSetter(descriptor);
		this.getValue = this.getValueGetter(descriptor);
		this.propertyDescriptor = this.createPropertyDescriptor(descriptor);		
		this.setInPropertyDescriptor(this.propertyDescriptor);
		
		Object.defineProperty(object, name, this.propertyDescriptor);

		return this;
	}
});

var API = {
	currentCustomProperty: null,

	hasOwnCustomProperty: function(object, name){
		return CustomPropertyDefinition.prototype.fromObject(object, name) !== null;
	},

	getOwnCustomProperty: function(object, name){
		return CustomPropertyDefinition.prototype.fromObject(object, name);
	},

	getOwnCustomPropertyDescriptor: function(object, name){
		var property = this.getOwnCustomProperty(object, name);
		return property ? property.descriptor : null;
	},

	defineCustomProperty: function(object, name, descriptor){
		return new CustomPropertyDefinition(object, name).define(descriptor);		
	},

	addPropertyListener: function(object, name, fn, bind){
		var customDefinition = CustomPropertyDefinition.prototype.fromObject(object, name);
		if( customDefinition === null ){
			customDefinition = new CustomPropertyDefinition(object, name);
		}
		return customDefinition.addListener(fn, bind);	
	},

	removePropertyListener: function(object, name, fn, bind){
		var customDefinition = CustomPropertyDefinition.prototype.fromObject(object, name);
		return customDefinition ? customDefinition.removeListener(fn, bind) : false;
	}
};

CustomPropertyDefinition.API = API;

module.exports = CustomPropertyDefinition;