/*

reste à prendre la logique de PropertyObserver pour la mettre dans observeProperty / unobserveProperty

en gardant à l'esprit que lorsqu'on observe les sous propriétés qui sont modifié, on veut aussi
être notifié lorsqu'une sous propriété enfant est modifiée

*/

var proto = require('proto');

var Cache = proto.create({
	cachedObject: null,
	objects: null,
	values: null,
	index: null,

	init: function(object){
		this.cachedObject = object;
		this.objects = [];
		this.values = [];
	},

	hasOwn: function(object){
		var index = this.objects.indexOf(object);
		this.index = index;
		return index !== -1;
	},

	has: function(object){

		while( this.hasOwn(object) === false ){
			object = Object.getPrototypeOf(object);
			if( object === this.cachedObject ) break;
			if( object === null ){
				throw new Error('object not child of cachedObject');
			}
		}

		return this.index != -1;
	},

	get: function(object, has){
		if( has === true || this.has(object) ) return this.values[this.index];
		return null;
	},

	set: function(object, value){
		if( this.has(object) ){
			this.values[this.index] = value;
		}
		else{
			this.objects.push(object);
			this.values.push(value);
		}
	},

	delete: function(object){		
		if( this.hasOwn(object) ){ // delete own cache, never parent cache, like delete operator on property
			this.objects.splice(this.index, 1);
			this.values.splice(this.index, 1);
			return true;
		}
		return false;
	},

	clear: function(){
		this.objects.length = this.values.length = 0;
	}
});

var OnceCache = proto.create({
	exists: false,
	value: null,

	init: function(){

	},

	has: function(object){
		return this.exists === true;
	},

	get: function(object, has){
		return has === true || this.has(object) ? this.value : null;
	},

	set: function(object, value){
		this.exists = true;
		this.value = value;
	},

	delete: function(object){
		this.exists = false;
		this.value = null;
	},

	clear: function(){
		this.delete();
	}
});

var Notifier = proto.create({
	listeners: null,
	bindings: null,
	index: null,
	lastChange: null,

	init: function(){
		this.listeners = [];
		this.bindings = [];
	},

	hasListener: function(fn, bind){
		var listeners = this.listeners, bindings = this.bindings, index = listeners.length;

		while(index--){
			if( listeners[index] === fn && bindings[index] === fn ) break;
		}

		this.index = index;

		return index;
	},

	addListener: function(fn, bind){
		if( this.hasListener(fn, bind) ){
			return false;
		}
		else{
			this.listeners.push(fn);
			this.bindings.push(bind);
			return true;
		}
	},

	removeListener: function(fn, bind){
		if( arguments.length === 0 ){
			this.listeners.length = this.bindings.length = 0;
		}
		else if( this.hasListener(fn, bind) ){
			this.listeners.splice(this.index, 1);
			this.bindings.splice(this.index, 1);			
		}
		else{
			return false;
		}

		if( this.listeners.length === 0 ){

		}

		return true;
	},

	notify: function(change){
		var listeners = this.listeners, bindings = this.bindings, i = 0, j = listeners.length;

		this.lastChange = change;
		for(;i<j;i++){
			listeners[i].call(bindings[i], change);
		}

		return this;
	}
});

var CustomPropertyDefinition = proto.create({
	object: null,
	name: null,
	invalidObjectMessage: 'customProperty object must be an object',
	invalidDescriptorMessage: 'customProperty descriptor is not a non null object',
	unspecifiedGetMessage: 'customProperty descriptor must specify when cache or subproperties is specified',
	unspecifiedAccessorMessage: 'customeProperty must sepcify a getter or a setter when subproperties is specified',
	invalidGetLengthMessage: 'customProperty descriptor get length must be equal to subproperties.length',
	invalidSetLengthMessage: 'customProperty descriptor set must return an array with length = subproperties.length',
	neverChangesMessage: 'customProperty descriptor onchange will never be called because writable = false',
	inextensibleMessage: 'object is not extensible',
	unconfigurableMessage: 'cannot redefine non-configurable property',
	descriptor: null,
	cache: null,
	notifier: null,

	init: function(object, name){
		if( Object(object) != object ){
			throw new TypeError(this.invalidObjectMessage);
		}
		name = String(name);

		this.object = object;
		this.name = name;
	},

	getComputed: function(object){
		var values = this.descriptor.subproperties.map(function(name){
			return object[name];
		});

		return this.descriptor.get.apply(object, values);
	},

	setComputed: function(object, value){
		var values = this.descriptor.set.call(object, value);

		if( !Array.isArray(values) || values.length != this.subproperties.length ){
			throw new TypeError(this.invalidSetLengthMessage);
		}

		var i = 0, j = values.length;
		for(;i<j;i++){
			object[this.subproperties[i]] = values[i];
		}
	},

	getGetter: function(object){
		return this.descriptor.get.call(object);
	},

	setSetter: function(object, value){
		this.descriptor.set.call(object, value);
	},

	getValue: function(object){
		return this.descriptor.value;
	},

	setValue: function(object, value){
		this.descriptor.value = value;
	},

	getWithoutCache: null,
	getWithCache: function(object){
		var value;

		if( this.cache.has(object) ){
			value = this.cache.get(object, true);
		}
		else{
			value = this.getWithoutCache(object);
			this.cache.set(object, value);
		}

		return value;
	},

	setWithoutCache: null,
	setWithCache: function(object, value){
		this.cache.set(object, value);
		this.setWithoutCache(object, value);
	},

	_getter: null,
	_setter: null,

	getter: function(object){
		return this._getter(object);
	},

	setter: function(object, value){
		var oldValue = object[this.name];

		if( oldValue !== value ){
			this._setter(object, value);
			if( this.notifier !== null ){
				this.notifier.notify({
					type: 'update', // pas forcément, c'est ptet add
					name: this.name,
					oldValue: oldValue,
					value: value,
					object: object
				});				
			}
		}
	},

	createGetter: function(){
		var self = this;

		if( this.descriptor.get ){
			this.getWithoutCache = this.descriptor.subproperties ? this.getComputed : this.getGetter;
		}
		else{
			this.getWithoutCache = this.getValue;
		}

		this._getter = this.cache === null ? this.getWithoutCache : this.getWithCache;

		return function(){
			return self.getter(this);
		};
	},

	createSetter: function(){
		var self = this;

		if( this.descriptor.set ){
			this.setWithoutCache = this.descriptor.subproperties ? this.setComputed : this.setGetter;
		}
		else{
			this.setWithoutCache = this.setValue;
		}

		this._setter = this.cache === null ? this.setWithoutCache : this.setWithCache;

		return function(value){
			return self.setter(this, value);			
		};
	},

	onSubPropertyChange: function(change){
		// lorsqu'on observe la propriété il faut la recalculer dès qu'une sous propriété change
		if( this.notifier !== null ){
			this.setter(change.object, this.getWithoutCache(change.object));
		}
		// sinon on invalide juste le cache
		else if( this.cache !== null ){
			this.cache.delete(change.object);
		}
	},

	getFromPropertyDescriptor: function(propertyDescriptor){
		var get, customPropertyDefinition = null;

		if( 'get' in propertyDescriptor ){
			get = propertyDescriptor.get;
			if( 'customPropertyDefinition' in get ){
				customPropertyDefinition = get.customPropertyDefinition;
			}
		}

		return customPropertyDefinition;
	},

	setInPropertyDescriptor: function(propertyDescriptor){
		propertyDescriptor.get.customPropertyDefinition = this;
	},

	createPropertyDescriptor: function(descriptor){
		var propertyDescriptor = {
			get: this.createGetter(),
			set: this.createSetter()
		};

		['writable', 'configurable', 'enumerable', 'value'].forEach(function(key){
			if( key in descriptor ) propertyDescriptor[key] = descriptor[key];
		});

		return propertyDescriptor;
	},

	define: function(descriptor){
		var object = this.object, name = this.name;

		// this object is non extensible, we cannot defineProperty
		if( Object.isExtensible(object) === false ) throw new TypeError(this.inextensibleMessage);

		var currentDescriptor = Object.getOwnPropertyDescriptor(object, name);
		if( currentDescriptor ){
			// property is not configurable, we cannot redefineproperty (array.length for ex)
			if( currentDescriptor.configurable === false ) throw new TypeError(this.unconfigurableMessage);

			// close any previous customPropertyDefinition
			var previous = this.getFromPropertyDescriptor(currentDescriptor);
			if( previous ){
				// we keep the notifier of the previous customProperty
				// because redefining the property does not mean we don't want to observe the 
				// property anymore
				this.notifier = previous.notifier;
				// however, the new property certainly differs from the previous one, so clean stuff
				previous.remove();
			}
		}

		if( Object(descriptor) != descriptor ) throw new TypeError(this.invalidDescriptorMessage);

		// subproperties
		if( 'subproperties' in descriptor ){
			var subproperties = descriptor.subproperties;

			if( 'get' in descriptor && subproperties.length != descriptor.get.length ){
				throw new TypeError(this.invalidGetLengthMessage);
			}
			else if( false === 'set' in descriptor ){
				throw new TypeError(this.unspecifiedAccessorMessage);
			}

			subproperties.forEach(function(property){
				
				this.observeProperty(object, property, this.onSubPropertyChange);

			}, this);
		}

		// onchange
		if( descriptor.onchange ){
			if( descriptor.writable === false ){
				throw new TypeError(this.neverChanges);
			}
			
			if( this.notifier == null ) this.notifier = Notifier.new();
			this.notifier.addListener(descriptor.onchange);
		}

		// cache
		if( descriptor.cache ){
			if( false === 'get' in descriptor ){
				throw new TypeError(this.unspecifiedGetMessage);
			}

			if( descriptor.cache === 'once' ){
				this.cache = OnceCache.new(object);
			}
			else if( descriptor.cache === true ){
				this.cache = Cache.new(object);
			}

			if( 'value' in descriptor ){
				this.cache.set(object, descriptor.value);
			}
		}
		
		this.descriptor = descriptor;

		var propertyDescriptor = this.createPropertyDescriptor(descriptor);
		this.setInPropertyDescriptor(propertyDescriptor);
		Object.defineProperty(object, name, propertyDescriptor);

		return this;
	},

	remove: function(){
		// supprimer les observeurs sur les subproperties, c'est tout?

		if( this.notifier ){
			this.notifier.removeListener(this.descriptor.onchange);
		}
		if( this.descriptor.subproperties ){
			this.descriptor.subproperties.forEach(function(property){				
				this.unobserveProperty(this.object, property, this.onSubPropertyChange, this);
			}, this);
		}
	},

	observeProperty: function(object, name, fn, bind){
		var propertyDescriptor = Object.getOwnPropertyDescriptor(object, name), customDefinition;

		if( propertyDescriptor ) customDefinition = this.getFromPropertyDescriptor(propertyDescriptor);

		if( !customDefinition ){
			customDefinition = CustomPropertyDefinition.new(object, name, {});
		}
		if( customDefinition.notifier === null ){
			customDefinition.notifier = Notifier.new();
		}

		customDefinition.notifier.addListener(fn, bind);
	},

	unobserveProperty: function(object, name, fn, bind){
		/*
		si une customProperty existe
		supprime le listener
		si y'a plus de listener
		supprime notifier
		si y'avais que 'onchange', supprime la customProperty
		*/
	}
});

module.exports = CustomPropertyDefinition;