/*

NOTES:
observer une propriété dans un objet apelle le listener pour les objets en héritant par prototype
observer une propriété puis redéfinir la propriété détruit les observeurs de cette propriété
	-> en résumé on peut faire defineCustomProperty() puis observeProperty
	-> mais on ne peut pas le faire dans l'ordre inverse (observeProperty puis defineCustomProperty)

A FAIRE:
- Mettre au propre
- Mettre en place le fait qu'on observe le parent lorsque l'object n'a pas la prop
- Cache doit aussi set une customProp sur child

*/

var proto = require('proto');

var Getters = {
	computed: function(object){
		var values = this.descriptor.subproperties.map(function(name){
			return object[name];
		});

		return this.descriptor.get.apply(object, values);
	},

	accessor: function(object){
		return this.descriptor.get.call(object);
	},

	value: function(object){
		return this.descriptor.value;
	},

	cache: function(object){
		var value;

		if( this.cache.has(object) ){
			value = this.cache.get(object, true);
		}
		else{
			value = this.getter(object);
			this.cache.set(value, this);
		}

		return value;
	}
};

var Setters = {
	computed: function(object, value){
		var values = this.descriptor.set.call(object, value);

		if( !Array.isArray(values) || values.length != this.subproperties.length ){
			throw new TypeError(this.messages.invalidSetLength);
		}

		var i = 0, j = values.length;
		for(;i<j;i++){
			object[this.subproperties[i]] = values[i];
		}
	},

	accessor: function(object, value){
		this.descriptor.set.call(object, value);
	},

	value: function(object, value){
		this.descriptor.value = value;
	},

	cache: function(object, value){
		this.cache.set(value, object);
		this.setter(object, value);
	}
};

var ObjectCache = proto.create({
	object: null,
	value: undefined,
	exists: null,

	has: function(){
		return this.exists === true;
	},

	get: function(){
		return this.value;
	},

	set: function(value){
		this.exists = true;
		this.value = value;
	},

	delete: function(){
		if( this.has() ){
			this.exists = false;
			this.value = undefined;
			return true;
		}
		return false;	
	},

	clear: function(){
		this.delete();
	}
});

var Cache = proto.create({
	cachedObject: null,
	objectsCache: null,
	objectCache: null,

	init: function(object){
		this.cachedObject = object;
		this.objectsCache = [];
	},

	find: function(object){
		var list = this.objectsCache, index = list.length, objectCache;
		
		while(index--){
			objectCache = list[index];
			if( objectCache.object === object ){
				this.objectCache = objectCache;
			}
		}

		return index != -1;
	},

	has: function(object){
		while( true ){			
			if( this.find(object) ) return this.objectCache.has();
			if( object === this.cachedObject ) return false;
			object = Object.getPrototypeOf(object);			
			if( object === null ) return false;
		}
	},

	get: function(object, has){
		if( has === true || this.has(object) ) return this.objectCache.value;
		return null;
	},

	createCache: function(object){
		var cache = ObjectCache.new(object);
		this.objetsCache.push(cache);
		return cache;
	},

	set: function(value, object){
		var objectCache = this.find(object) ? this.objectCache : this.createCache(object);
		return objectCache.set(value);
	},

	delete: function(object){
		if( this.find(object) ){
			return this.objectCache.delete();
		}
		// create it because now object must have its own cache and not inherit from parent cache
		this.createCache(object);
		return false;
	},

	clear: function(){
		this.objetsCache.length = 0;
	}
});

var CustomPropertyDefinition = proto.create({
	object: null,
	name: null,
	oldDescriptor: null, // the old propertyDescriptor
	descriptor: null, // the customDescriptor
	propertyDescriptor: null, // the current porpertyDescriptor	
	cache: null,
	notifier: null,
	messages: {
		invalidObject: 'customProperty object must be an object',
		invalidDescriptor: 'customProperty descriptor is not a non null object',
		unspecifiedGet: 'customProperty descriptor must specify when cache or subproperties is specified',
		unspecifiedAccessor: 'customeProperty must sepcify a getter or a setter when subproperties is specified',
		invalidGetLength: 'customProperty descriptor get length must be equal to subproperties.length',
		invalidSetLength: 'customProperty descriptor set must return an array with length = subproperties.length',
		neverChanges: 'customProperty descriptor onchange will never be called because writable = false',
		inextensible: 'object is not extensible'
	},

	init: function(object, name){
		if( Object(object) != object ){
			throw new TypeError(this.messages.invalidObject);
		}
		if( Object.isExtensible(object) === false ){
			throw new TypeError(this.messages.inextensible);
		}

		name = String(name);

		this.object = object;
		this.name = name;
	},	

	getter: null,
	get: null,
	createGetter: function(){
		if( this.descriptor.get ){
			this.getter = Getters[this.descriptor.subproperties ? 'computed' : 'accessor'];
		}
		else{
			this.getter = Getters.value;
		}
		this.get = this.cache === null ? this.getter : Getters.cache;

		var self = this;
		return function(){
			return self.get(this);
		};
	},

	setter: null,
	set: null,
	createSetter: function(){
		if( this.descriptor.set ){
			this.setter = Setters[this.descriptor.subproperties ? 'computed' : 'accessor'];
		}
		else{
			this.setter = Setters.value;
		}
		this.set = this.cache === null ? this.setter : Setters.cache;

		var self = this;
		return function(value){
			return self.set(this, value);			
		};
	},

	getFromPropertyDescriptor: function(propertyDescriptor){
		var get, customPropertyDefinition = null;

		if( 'get' in propertyDescriptor ){
			get = propertyDescriptor.get;
			if( 'customPropertyDefinition' in get ){
				customPropertyDefinition = get.customPropertyDefinition;
			}
		}

		return customPropertyDefinition;
	},

	setInPropertyDescriptor: function(propertyDescriptor){
		propertyDescriptor.get.customPropertyDefinition = this;
	},

	createPropertyDescriptor: function(descriptor){
		var propertyDescriptor = {
			get: this.createGetter(),
			set: this.createSetter()
		};

		['writable', 'configurable', 'enumerable', 'value'].forEach(function(key){
			if( key in descriptor ) propertyDescriptor[key] = descriptor[key];
		});

		return propertyDescriptor;
	},

	rollback: function(){
		if( this.oldDescriptor !== null ){
			Object.defineProperty(this.object, this.name, this.oldDescriptor);
			this.oldDescriptor = null;
		}
		else{
			delete this.object[this.name];
		}
	},

	createCache: function(object, name, descriptor){
		var cache = null, type = descriptor.cache;

		if( type !== false ){
			if( false === 'get' in descriptor ){
				throw new TypeError(this.messages.unspecifiedGet);
			}

			if( type === 'once' ){
				cache = ObjectCache.new(object);
			}
			else if( type === true ){
				cache = Cache.new(object);
			}

			if( 'value' in descriptor ){
				cache.set(descriptor.value, object);
			}
		}

		return cache;
	},

	invalidCacheWhenSubPropertyChange: function(object, subproperties){
		throw new Error('unimplemented');
	},

	createSubProperties: function(object, name, descriptor){
		var subproperties = descriptor.subproperties;

		if( 'get' in descriptor && subproperties.length != descriptor.get.length ){
			throw new TypeError(this.messages.invalidGetLength);
		}
		else if( false === 'set' in descriptor ){
			throw new TypeError(this.messages.unspecifiedAccessor);
		}

		if( this.cache ){
			this.invalidCacheWhenSubPropertyChange(object, subproperties);
		}
	},

	// A REFAIRE
	propertyChanged: function(change){
		// lorsqu'on observe la propriété il faut la recalculer dès qu'une sous propriété change
		if( this.notifier && this.notifier.size !== 0 ){
			// we call this.set normally, but this.getter to bypass the cache
			this.set(change.object, this.getter(change.object));
		}
		else if( this.cache ){
			this.cache.delete(change.object);
		}
	},

	setProperty: function(object, value, previous){
		var isSelf = this.object == object;
		var oldValue = object[this.name];

		if( oldValue !== value ){
			if( isSelf ) previous(object, value);

			this.notifier.notify({
				type: 'update',
				name: this.name,
				oldValue: oldValue,
				value: value,
				object: object
			});
		}

		if( !isSelf ){		
			// happen ONLY ONCE per object : because after we set the property into object

			this.childObserveds.push(object);
			// WARNING : keep this line before observing object to set the prop in object
			// else observeProperty observe for parent changes instead of child
			Object.defineProperty(object, this.name, {
				value: value,
				enumerable: true
			});
			// il fau tnotifier le parent!!!!!
			Observer.observeProperty(object, this.name, this, 'propertyChanged');
		}
	},

	addObservability: function(){
		this.addSetter(this.setProperty);
		this.childObserveds = [];
	},

	removeObservability: function(){
		this.removeSetter(this.setProperty);
		this.childObserveds.forEach(function(child){
			this.unobserveProperty(child, this.name, this, 'propertyChanged');
		}, this);
	},

	define: function(descriptor){
		var object = this.object, name = this.name;

		this.oldDescriptor = Object.getOwnPropertyDescriptor(object, name);

		if( arguments.length === 0 ){
			descriptor = this.oldDescriptor || {};
		}
		else{
			if( Object(descriptor) != descriptor ){
				throw new TypeError(this.messages.invalidDescriptor);
			}			
			// cache
			if( 'cache' in descriptor ){
				this.cache = this.createCache(object, name, descriptor);
			}
			// subproperties
			if( 'subproperties' in descriptor ){
				this.subproperties = this.createSubProperties(object, name, descriptor);	
			}
		}
		
		this.descriptor = descriptor;
		this.propertyDescriptor = this.createPropertyDescriptor(descriptor);		
		this.setInPropertyDescriptor(this.propertyDescriptor);
		Object.defineProperty(object, name, this.propertyDescriptor);

		return this;
	}
});

var Notifier = proto.create({
	listeners: null,
	bindings: null,
	index: null,
	lastChange: null,

	init: function(){
		this.listeners = [];
		this.bindings = [];
	},

	get size(){
		return this.listeners.length;
	},

	hasListener: function(fn, bind){
		var listeners = this.listeners, bindings = this.bindings, index = listeners.length;

		while(index--){
			if( listeners[index] === fn && bindings[index] === fn ) break;
		}

		this.index = index;

		return index;
	},

	addListener: function(fn, bind){
		if( this.hasListener(fn, bind) ){
			return false;
		}
		else{
			this.listeners.push(fn);
			this.bindings.push(bind);
			return true;
		}
	},

	removeListener: function(fn, bind){
		if( arguments.length === 0 ){
			if( this.size !== 0 ){
				this.listeners.length = this.bindings.length = 0;
				return true;
			}
		}
		else if( this.hasListener(fn, bind) ){
			this.listeners.splice(this.index, 1);
			this.bindings.splice(this.index, 1);
			return true;			
		}

		return false;
	},

	notify: function(change, listenerType){
		var listeners = this.listeners, bindings = this.bindings, i = 0, j = listeners.length, listener;

		this.lastChange = change;
		for(;i<j;i++){
			listener = listeners[i];
			if( typeof listener == 'object' ){
				listener[bindings[i]](change);
			}
			else{
				listener.call(bindings[i], change);
			}
		}

		return this;
	}
});

var Observer = {
	observeProperty: function(object, name, fn, bind){
		
		// si cet objet n'a pas la propriété, cherche un parent où mettre cette propriété
		// on gèreras ça à la fin
		/*
		var proto = object;
		while( !Object.prototype.hasOwnProperty.call(proto, name) ){
			proto = Object.getPrototypeOf(proto);
			if( proto === null ){
				proto = object;
				break;
			}
		}
		*/
		// en fait ici on peut reprendre la logique tel quel de
		// propertyObserver, qui va apeller observeProperty sur le parent
		// qui va remove l'observer lorsqu'il est set pour la première fois

		var propertyDescriptor = Object.getOwnPropertyDescriptor(proto, name), customDefinition, notifier;

		if( propertyDescriptor ){
			customDefinition = CustomPropertyDefinition.getFromPropertyDescriptor(propertyDescriptor);
		}
		if( customDefinition === null ){
			customDefinition = CustomPropertyDefinition.new(proto, name);
			customDefinition.define(propertyDescriptor || {});
		}
		if( customDefinition.descriptor.writable === false ){
			throw new TypeError(CustomPropertyDefinition.messages.neverChanges);
		}

		notifier = customDefinition.notifier;

		if( notifier === null ){
			notifier = Notifier.new();
			customDefinition.notifier = notifier;			
		}

		// first time the propery is observed
		if( notifier.size === 0 ){
			customDefinition.addObservability();
		}

		return notifier.addListener(fn, bind);
	},

	canRollBack: function(customDefinition){
		// special fast case where the oldDescriptor is used as descriptor
		if( customDefinition.descriptor === customDefinition.oldDescriptor ) return true;

		// we can rollback when the property don't use cache nor subproperties
		return customDefinition.cache === null && customDefinition.subproperties === null;
	},

	unobserveProperty: function(object, name, fn, bind){
		var propertyDescriptor = Object.getOwnPropertyDescriptor(object, name);
		if( propertyDescriptor === null ) return false;
		var customDefinition = CustomPropertyDefinition.getFromPropertyDescriptor(propertyDescriptor);
		if( customDefinition === null ) return false;
		var notifier = customDefinition.notifier;
		if( notifier === null ) return false;
		if( notifier.removeListener(fn, bind) === false ) return false;

		if( notifier.size === 0 ){
			customDefinition.removeObservability();
			// on a définie une propriétée dont on n'a plus besoin
			// faut remettre la propriété a son état d'origine
			if( this.canRollBack(customDefinition) ){
				customDefinition.rollback();
			}
		}

		return true;
	}
};

module.exports = CustomPropertyDefinition;