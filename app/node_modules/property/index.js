/*

name: property

description: Help to manipulate object keys, required almost everywhere

provides:
	ownKeys, eachOwnKey, iterateKey, eachOwnKeyIn
	appendKey, append, completeKey, complete
	implementKey, implement, complementKey, complement

*/

var property = {
	ownKeys: 'getOwnPropertyNames' in Object ? Object.getOwnPropertyNames : Object.keys,

	eachOwnKey: function(object, fn, bind){
		var list = this.ownKeys(object), i = 0, j = list.length, key;

		for(;i<j;i++){
			key = list[i];
			fn.call(bind, key, object);
		}

		return object;
	},

	iterateKey: function(keyIterator, array, fn, bind){
		var i = 0, j = array.length, item;

		for(;i<j;i++){
			item = array[i];
			if( item instanceof Function ) item = item.prototype;

			switch(typeof item){
			case 'string':
				var temp = {};
				temp[item] = array[++i];

				fn.call(bind, item, temp);
				break;
			case 'object':
				keyIterator.call(this, item, fn, bind);
				break;
			}
		}
	},

	eachOwnKeyIn: function(array, fn, bind){
		return this.iterateKey(this.eachOwnKey, array, fn, bind);
	},

	append: function(object){
		this.eachOwnKeyIn(Array.prototype.slice.call(arguments, 1), this.appendKey, object);
		return object;
	},

	complete: function(object){
		this.eachOwnKeyIn(Array.prototype.slice.call(arguments, 1), this.completeKey, object);
		return object;
	},

	implement: function(object){
		this.eachOwnKeyIn(Array.prototype.slice.call(arguments, 1), this.implementKey, object.prototype);
		return this;
	},

	complement: function(object){
		this.eachOwnKeyIn(Array.prototype.slice.call(arguments, 1), this.complementKey, object.prototype);
		return this;
	}
};

// avoir custom getter being called
property.cloneDescriptor = function(descriptor){
	var clone = {}, keys, i, j, key;

	keys = property.ownKeys(descriptor);
	i = 0;
	j = keys.length;

	for(;i<j;i++){
		key = keys[i];
		clone[key] = descriptor[key];
	}

	if( !descriptor.set ) delete descriptor.set;

	return clone;
};

if( 'getOwnPropertyDescriptor' in Object ){

	property.appendKey = function(key, object){
		if( object ){
			/*if( key[0] === '@' ){
				var cachedPropertyName = '_' + key, property;

				Object.defineProperty(this, cachedPropertyName, {value: null});
				Object.defineProperty(this, key, {
					get: function(){
						var value = this[cachedPropertyName];
						if( value === null ){
							property = object[key];
							value = typeof property == 'function' ? property.call(this) : property;
							this[cachedPropertyName] = value;
						}
					},

					set: function(value){
						this[cachedPropertyName] = value;
					}
				});
			}
			else{
				*/
				var descriptor = Object.getOwnPropertyDescriptor(object, key);
				// not needed as we want the same descriptor as source
				//descriptor = keys.cloneDescriptor(descriptor);
				Object.defineProperty(this, key, descriptor);
			//}
		}
		else{
			this[key] = object[key];
		}
	};

	property.implementKey = function(key, object){
		var descriptor;

		if( object ){
			descriptor = Object.getOwnPropertyDescriptor(object, key);
			// don't put enumerable = false on source descriptor
			descriptor = property.cloneDescriptor(descriptor);
			descriptor.enumerable = false;
		}
		else{
			descriptor = {enumerable: false,  configurable: true, writable: true, value: object[key]};
		}

		Object.defineProperty(this, key, descriptor);
	};

}
else{

	property.appendKey = property.implementKey = function(key, object){
		this[key] = object[key];
	};

}

property.completeKey = function(key){
	// set key/value pair in this if not existing
	if( !(key in this) ){
		property.appendKey.apply(this, arguments);
	}
	return this;
};

property.complementKey = function(key){
	if( !(key in this) ){
		property.implementKey.apply(this, arguments);
	}
	return this;
};

Object.append = property.append.bind(property);

module.exports = property;