/*

name: property

description: Help to manipulate object properties, required almost everywhere

*/

var ownNames = 'getOwnPropertyNames' in Object ? Object.getOwnPropertyNames : Object.keys;

if( 'getOwnPropertyDescriptor' in Object ){

	// avoir custom getter being called
	function cloneDescriptor(descriptor){
		var clone = {}, names, i, j, name;

		names =  Object.getOwnPropertyNames(descriptor);
		i = 0;
		j = names.length;

		for(;i<j;i++){
			name = names[i];
			clone[key] = descriptor[key];
		}

		if( !descriptor.set ) delete descriptor.set;

		return clone;
	}

	function addProperty(key, object){
		if( object ){
			var descriptor = Object.getOwnPropertyDescriptor(object, key);
			// not needed as we want the same descriptor as source
			//descriptor = keys.cloneDescriptor(descriptor);
			Object.defineProperty(this, key, descriptor);
		}
		else{
			this[key] = object[key];
		}
	}

	function implementProperty(key, object){
		var descriptor;

		if( object ){
			descriptor = Object.getOwnPropertyDescriptor(object, key);
			// don't put enumerable = false on source descriptor
			descriptor = cloneDescriptor(descriptor);
			descriptor.enumerable = false;
		}
		else{
			descriptor = {enumerable: false,  configurable: true, writable: true, value: object[key]};
		}

		Object.defineProperty(this, key, descriptor);
	}

	function forEach(){
		var names = Object.getOwnPropertyNames(object), name, i, j, parentNames;

		i = 0;
		j = names.length;
		for(;i<j;i++){
			name = names[i];
			fn.call(bind, name, object);
		}

		while( object = Object.getPrototypeOf(object) ){
			if( object == Object.prototype ) break;
			parentNames = Object.getOwnPropertyNames(object);
			i = 0;
			j = parentNames.length;
			for(;i<j;i++){
				name = parentNames[i];
				if( names.indexOf(name) === -1 ){
					names.push(name);
					fn.call(bind, name, object);
				}
			}
		}
	}

	/*

	Object.getPropertyOwner = function(object, key){
		while( object ){
			if( Object.prototype.hasOwnProperty.call(object, key) ) return object;
			object = Object.getPrototypeOf(object);
		}
		return null;
	};

	Object.getPropertyDescriptor = function(object, key){
		object = Object.getPropertyOwner(object, key);
		return object ? Object.getOwnPropertyDescriptor(object, key) : null;
	};

	*/

}
else{

	function addProperty(){
		this[key] = object[key];
	}

	function implementProperty(){
		this[key] = object[key];
	}

	function forEach(object, fn, bind){
		for(var key in object) fn.call(bind, key, object);
		return object;
	}

	function cloneDescriptor(){
		
	}

}

var property = {
	ownNames: ownNames,
	cloneDescriptor: cloneDescriptor;

	forEach: forEach,

	forEachOwn: function(object, fn, bind){
		var names = this.ownNames(object), i = 0, j = names.length, name;

		for(;i<j;i++){
			name = names[i];
			fn.call(bind, name, object);
		}

		return object;
	},

	receiver: {},
	callForEach: function(forEach, array, fn, bind){
		var i = 0, j = array.length, item, temp;

		for(;i<j;i++){
			item = array[i];
			if( typeof item == 'string' ){
				this.receiver[item] = array[i];
				i++;
				item = this.receiver;
			}
			forEach.call(this, item, fn, bind);
		}
	},

	forEachOwnIn: function(array, fn, bind){
		return this.callForEach(this.forEachOwn, array, fn, bind);
	},

	forEachIn = function(array, fn, bind){
		return this.callForEach(this.forEach, array, fn, bind);
	},

	addProperty: addProperty,

	implementProperty: implementProperty,

	completeProperty: function(key){
		// set key/value pair in this if not existing
		if( !(key in this) ){
			property.addProperty.apply(this, arguments);
		}
		return this;
	},

	complementProperty: function(key){
		if( !(key in this) ){
			property.implementProperty.apply(this, arguments);
		}
		return this;
	},

	append: function(object){
		this.forEachOwnIn(Array.prototype.slice.call(arguments, 1), this.addProperty, object);
		return object;
	},

	complete: function(object){
		this.forEachOwnIn(Array.prototype.slice.call(arguments, 1), this.completeProperty, object);
		return object;
	},

	implement: function(object){
		this.forEachOwnIn(Array.prototype.slice.call(arguments, 1), this.implementProperty, object.prototype);
		return this;
	},

	complement: function(object){
		this.forEachOwnIn(Array.prototype.slice.call(arguments, 1), this.complementProperty, object.prototype);
		return this;
	}
};

Object.append = property.append.bind(property);

module.exports = property;