/*

name: property

description: Help to manipulate object properties, required almost everywhere

*/

var property = {
	ownNames: Object.keys,

	forEach: function(object, fn, bind){
		for(var name in object) fn.call(bind, name, object);
		return object;
	},

	forEachOwn: function(object, fn, bind){
		var names = this.ownNames(object), i = 0, j = names.length, name;

		for(;i<j;i++){
			name = names[i];
			fn.call(bind, name, object);
		}

		return object;
	},

	receiver: {},
	callForEach: function(forEach, array, fn, bind){
		var i = 0, j = array.length, item, temp;

		for(;i<j;i++){
			item = array[i];
			if( typeof item == 'string' ){
				this.receiver[item] = array[i];
				i++;
				item = this.receiver;
			}
			forEach.call(this, item, fn, bind);
		}
	},

	forEachOwnIn: function(array, fn, bind){
		return this.callForEach(this.forEachOwn, array, fn, bind);
	},

	forEachIn: function(array, fn, bind){
		return this.callForEach(this.forEach, array, fn, bind);
	},

	addProperty: function(name, object){
		this[name] = object[name];
	}
};

if( 'getOwnPropertyDescriptor' in Object ){

	var es5Methods = {
		ownNames: Object.getOwnPropertyNames,
		
		assignPropertyDescriptor: function(name, object){
			var descriptor = Object.getOwnPropertyDescriptor(object, name);
			if( descriptor !== undefined && descriptor.enumerable === true ){
				Object.defineProperty(this, name, descriptor);
			}
		},

		addPropertyDescriptor: function(name, object){
			var descriptor = Object.getOwnPropertyDescriptor(object, name);
			Object.defineProperty(this, name, descriptor);
		},

		implementPropertyDescriptor: function(name, object){
			var descriptor = Object.getOwnPropertyDescriptor(object, name);

			// we can modify directly the descriptor object because
			// Object.getOwnPropertyName create a descriptor object each time it's called
			descriptor.enumerable = false;

			Object.defineProperty(this, name, descriptor);
		},
		
		forEach: function(object, fn, bind){
			var names = Object.getOwnPropertyNames(object), name, i, j, proto, protoNames;

			i = 0;
			j = names.length;
			for(;i<j;i++){
				name = names[i];
				fn.call(bind, name, object);
			}

			proto = object;
			while( proto = Object.getPrototypeOf(proto) ){
				if( proto == Object.prototype ) break;
				
				protoNames = Object.getOwnPropertyNames(proto);
				i = 0;
				j = protoNames.length;
				for(;i<j;i++){
					name = protoNames[i];
					if( names.indexOf(name) === -1 ){
						names.push(name);
						fn.call(bind, name, proto);
					}
				}
			}
		}
	};

	for(var method in es5Methods){
		property[method] = es5Methods[method];
	}

	property.appendMethod = property.addPropertyDescriptor;
	property.implementMethod = property.implementPropertyDescriptor;
	property.assignMethod = property.assignPropertyDescriptor;

	/*
	property.getPropertyOwner = function(object, name){
		while( object ){
			if( Object.prototype.hasOwnProperty.call(object, name) ) return object;
			object = Object.getPrototypeOf(object);
		}
		return null;
	};

	property.getPropertyDescriptor = function(object, name){
		object = property.getPropertyOwner(object, name);
		return object ? Object.getOwnPropertyDescriptor(object, name) : null;
	};
	*/
}
else{
	property.appendMethod = property.implementMethod = property.assignMethod = property.addProperty;
}

var API = {
	completeProperty: function(name, object){
		if( !(name in this) ){
			property.appendMethod.call(this, name, object);
		}
		return this;
	},

	complementProperty: function(name, object){
		if( !(name in this) ){
			property.implementMethod.call(this, name, object);
		}
		return this;
	},

	assign: function(object){
		this.forEachOwnIn(Array.prototype.slice.call(arguments, 1), this.assignMethod, object);
		return object;
	},

	append: function(object){
		this.forEachOwnIn(Array.prototype.slice.call(arguments, 1), this.appendMethod, object);
		return object;
	},

	complete: function(object){
		this.forEachOwnIn(Array.prototype.slice.call(arguments, 1), this.completeProperty, object);
		return object;
	},

	implement: function(object){
		this.forEachOwnIn(Array.prototype.slice.call(arguments, 1), this.implementMethod, object.prototype);
		return this;
	},

	complement: function(object){
		this.forEachOwnIn(Array.prototype.slice.call(arguments, 1), this.complementProperty, object.prototype);
		return this;
	}
};

for(var method in API){
	property[method] = API[method];
}

if( !Object.assign ){
	Object.assign = property.assign.bind(property);
}

module.exports = property;