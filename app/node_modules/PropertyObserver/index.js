var proto = require('proto');

var ObjectObserver = proto.create({
	cache: [],
	size: 0,
	object: null,
	propertyObservers: null,	

	indexOf: function(object){
		var cache = this.cache, i = 0, j = cache.length, observer, index = -1;

		for(;i<j;i++){
			observer = cache[i];
			if( observer.object === object ){
				index = i;
				break;
			}
		}

		return index;	
	},

	new: function(object){
		var index = this.indexOf(object);

		if( index === -1 ){
			this.cache.push(proto.new.call(this, object));
		}
		return this.cache[index];
	},

	init: function(object){
		this.object = object;
		this.propertyObservers = {};
	},

	get: function(name){
		var observer;

		if( name in this.propertyObservers ){
			observer = this.propertyObservers[name];
		}
		else{
			observer = proto.new.call(PropertyObserver, this, name);
			this.propertyObservers[name] = observer;
			this.size++;
		}

		return observer;
	},

	remove: function(observer){
		this.size--;
		delete this.propertyObservers[observer.name];
		if( this.size === 0 ){
			this.cache.splice(this.cache.indexOf(this), 1);
		}
	},

	close: function(){
		for(var name in this.propertyObservers){
			this.propertyObservers[name].unobserve();
		}
	},

	observe: function(name, fn, bind){
		return this.get(name).observe(fn, bind);
	},

	unobserve: function(name, fn){
		if( name in this.propertyObservers ){
			this.propertyObservers[name].unobserve(fn);
		}
	}
});

var PropertyObserver = proto.create({
	ObjectObserver: ObjectObserver,
	objectObserver: null,
	name: null,	
	fns: null,
	binds: null,
	descriptor: null,

	new: function(objectObserver, name){
		if( !ObjectObserver.isPrototypeOf(objectObserver) ){
			objectObserver = ObjectObserver.new(objectObserver);
		}

		return objectObserver.get(name);
	},

	init: function(objectObserver, name){
		this.objectObserver = objectObserver;
		this.name = name;
		this.fns = [];
		this.binds = [];
	},

	open: function(){
		if( this.descriptor ) return;

		var object = this.objectObserver.object, name = this.name;
		var descriptor = Object.getOwnPropertyDescriptor(object, name) || {
			enumerable: true
			// value: undefined (don't set value to know if value is set to undefined)
		};

		this.descriptor = descriptor;

		// array.length or stuff like this are not configurable :(
		if( descriptor.configurable === false ){
			return false;
		}
		// the object is not suppoed to be modified (todo isFrozen, isSealed etc)
		if( descriptor.writable === false ){
			return false;
		}
		// custom getter and setter can't be watched, they should used getNotifier(this, 'test') (todo)
		if( 'get' in descriptor || 'set' in descriptor ){
			return false;
		}

		var self = this;
		var oldValue;
		Object.defineProperty(object, name, {
			get: function(){
				return descriptor.value;
			},

			set: function(value){
				oldValue = descriptor.value;

				if( oldValue !== value ){
					descriptor.value = value;
					self.notify(value, oldValue, this);
				}
			},

			enumerable: descriptor.enumerable,
			configurable: true
		});

		return true;		
	},

	close: function(){
		if( this.descriptor == null ) return;

		if( 'value' in this.descriptor ){
			Object.defineProperty(this.objectObserver.object, this.name, this.descriptor);
		}
		else{
			delete this.objectObserver.object[this.name];
		}

		this.descriptor = null;
	},

	observe: function(fn, bind){
		this.fns.push(fn);
		this.binds.push(bind);
		if( this.fns.length === 1 ){
			return this.open();
		}
		return true;
	},

	unobserve: function(fn){
		if( fn ){
			var index = this.fns.indexOf(fn);

			if( index !== -1 ){
				this.fns.splice(index, 1);
				this.binds.splice(index, 1);
			}
		}
		else{
			this.fns.length = 0;
			this.binds.length = 0;
		}

		if( this.fns.length === 0 ){
			this.close();
			this.objectObserver.remove(this);
		}
	},

	notify: function(value, oldValue, object){
		var i = 0, j = this.fns.length;

		for(;i<j;i++){
			this.fns[i].call(this.binds[i], value, oldValue, this.name, object);
		}
	}
});

module.exports = PropertyObserver;