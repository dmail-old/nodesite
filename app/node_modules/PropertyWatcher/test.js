exports['watch() call fn on property change'] = function(test){
	var model = {}, bind = {};

	test.imports.watch(model, 'name', function(value, oldValue, name, object){
		test.equal(this, bind);
		test.equal(value, model.name);
		test.equal(oldValue, undefined);
		test.equal(name, 'name');
		test.equal(object, model);
		test.done();
	}, bind);

	model.name = 'damien';
};

exports['watch() call fn only when property not ==='] = function(test){
	var model = {}, count = 0;

	test.imports.watch(model, 'name', function(value, oldValue, name, object){
		count++;
	});

	model.name = 'damien';
	model.name = 'damien';
	model.name = 0;
	model.name = false;

	test.equal(count, 3);
	test.done();
};

exports['watch() respect the ennumerable property'] = function(test){
	var model = {};
	var desc = {
		ennumerable: false
	};

	Object.defineProperty(model, 'name', desc);

	test.imports.watch(model, 'name', function(){});
	test.equal(Object.getOwnPropertyDescriptor(model, 'name').ennumerable, desc.ennumerable);

	test.done();
};

exports['watch() ignore non configurable property'] = function(test){
	test.equal(test.imports.watch([], 'length', function(){}), false);
	test.done();
};

exports['watch() ignore property with custom getter or setter'] = function(test){
	test.equal(test.imports.watch({get foo(){}}, 'foo', function(){}), false);
	test.equal(test.imports.watch({set foo(value){}, get foo(){}}, 'foo', function(){}), false);
	test.done();
};

exports['unwatch() will not create property when they do not exist'] = function(test){
	var model = {};

	test.imports.watch(model, 'name', function(){});
	test.imports.unwatch(model, 'name');

	test.equal('name' in model, false);
	test.done();
};

exports['unwatch() restore the lastValue'] = function(test){
	var model = {};

	test.imports.watch(model, 'name', function(){});
	model.name = 'damien';
	test.imports.unwatch(model, 'name');

	test.equal(model.name, 'damien');
	test.done();
};
