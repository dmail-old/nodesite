var Request = require('./browser/request');

var server = {
	link: null,
	handlers: {
		'application/json': function(){
			var text = this.response.text, json;

			if( text === '' ){
				this.emit('handle', null, null);
			}
			else{
				try{
					json = JSON.parse(text);
				}
				catch(e){
					return this.emit('handle', e);
				}

				this.json = json;
				if( json.status != 200 ){
					return this.emit('handle', new Error('SERVER : ' + json.data));
				}
				this.emit('handle', null, json.data);
			}			
		},

		'text/html': function(){
			var html = this.response.text;
			this.emit('handle', null, html);
		}
	},

	open: function(){
		var request = Request.new({
			link: 'chain',
			method: 'post',
			format: 'json'
		});

		request.parseContentType = function(contentType){
			if( contentType ){
				var index = contentType.indexOf(';');
				if( index !== -1 ){
					contentType = contentType.slice(0, index);
				}
			}

			return contentType;
		};
		request.getContentType = function(){
			return this.parseContentType(this.getHeader('content-type'));
		};
		request.setHeader('Accept', 'application/json');
		request.options.isSuccess = function(){
			var status = this.status, ok = status >= 200 && status < 300;

			if( ok ){
				var type = this.getContentType();

				if( type in server.handlers ){
					server.handlers[type].call(this);
				}
				else{
					this.emit('handle', new Error('response content type not supported'));
				}

				return true;
			}
			else{
				this.emit('handle', new Error('bad status'));

				return false;
			}
		};
		request.on('request', function(options){
			if( options && options.callback ){
				this.once('handle', options.callback);
			}
		});

		this.link = request;
	},

	GET: function(url, callback){
		this.link.method = 'GET';
		this.link.send({
			url: url,
			callback: callback
		});
	}
};

var ElementEmitter = require('./browser/elementEmitter');
var app = {
	container: $('page'),

	init: function(){
		String.implement('stripScripts', function(exec){
			var scripts = '';
			var text = this.replace(/<script[^>]*>([\s\S]*?)<\/script>/gi, function(all, code){
				scripts += code + '\n';
				return '';
			});

			if( exec === true ){
				NS.browser.exec(scripts);
			}
			else if( typeof exec == 'function' ){
				exec(scripts, text);
			}

			return text;
		});

		// window.connection.open serait un nom plus juste
		// ou alors window.server.connection.open
		// ou window.serverConnection.open
		server.open();

		this.emitter = ElementEmitter.new(window, this);
		this.emitter.on({
			'click': this.click,
			'popstate': this.popstate
		});

		this.locationChanged(document.location.href);
	},

	setPage: function(html){
		if( typeof html != 'string' ) html = html.toString();

		this.container.innerHTML = html; // document.body.innerHTML = html;
		// search for <template> in the DOM
		require('mdv').bootstrap(this.container);
		// search for <script> in the string and evals it
		html.stripScripts(true);
	},

	// demande au serveur la page se trouvant à url
	go: function(url, state){
		document.title = url;

		// prevent browser caching document
		// if( filename.endsWith('.html') ) filename+= '?rand=' + new Date().getTime();

		var self = this;

		server.GET(url, function(error, response){
			if( error ) return console.warn(error);

			var type = this.getContentType();

			if( type == 'text/html' ){
				self.setPage(response);
			}
		});

	},

	locationChanged: function(url, state){
		if( typeof url == 'undefined' ) url = document.location.href;
		this.go(url);
	},
	
	// bouton prev ou next activé
	popstate: function(e){
		this.locationChanged(document.location.href, e.state);
	},

	getAnchorElement: function(element){
		while( element && element.tagName && element.tagName.toLowerCase() != 'a' ){
			element = element.parentNode;
		}

		return element;
	},

	// lorsqu'on click sur un élément de la page
	click: function(e){
		var anchorElement = this.getAnchorElement(e.target);

		if( anchorElement ){
			// click de molette
			if( e.middleClick ) return true;
			// touche ctrl ou touche cmd
			if( e.control || e.meta ) return true;
			// URL courante, on laisse la page se recharger
			if( document.location.href == anchorElement.href ) return true;
			// URL externe
			if( document.location.hostname != anchorElement.hostname ) return true;

			// les URL internes entrainent un locationChanged et history.pushState
			history.pushState(null, null, anchorElement.href);
			this.locationChanged(anchorElement.href);
			e.preventDefault();
			return false;
		}
	}
};

this.server = server;
this.app = app;
