Function.overloadAxisGetter = function(fn){
	return function(axis){
		if( typeof axis == 'string' ) return fn.apply(this, arguments);

		return {
			x: fn.call(this, 'x', axis),
			y: fn.call(this, 'y', axis)
		};
	};
};

/*
Function.overloadSideGetter = function(fn){
	return function(side){
		if( typeof side == 'string' ) return fn.apply(this, arguments);

		return {
			left: fn.call(this, 'left'),
			right: fn.call(this, 'right'),
			top: fn.call(this, 'top'),
			bottom: fn.call(this, 'bottom')
		}
	};
};
*/

var Element = require('../../Element');
var os = require('os');
var browser = require('browser');

var Methods = {
	getWindow: function(){ return this.ownerDocument.getWindow(); },
	getDocument: function(){ return this.ownerDocument; },

	elementMeasurers: {},
	documentMeasurers: {},
	elementMethods: {},
	documentMethods: {},

	defineElementMeasurer: function(name, measurer){
		this.elementMeasurers[name] = measurer;
		this.elementMethods[name] = Function.overloadAxisGetter(measurer);
	},

	defineDocumentMeasurer: function(name, measurer){
		this.documentMeasurers[name] = measurer;
		this.documentMethods[name] = Function.overloadAxisGetter(measurer);
	},

	measure: function(element, name, param1, param2){
		var methods;

		if( element instanceof Element ){
			methods = this.elementMethods;
		}
		else if( element === document || element === window ||
			element === document.html /*|| element === document.body*/ ){
			if( element === window ) element = document;
			methods = this.documentMethods;
		}
		else{
			throw new TypeError('element, document or window expected');
		}

		var method = methods[name];

		if( typeof method != 'function' ) throw new Error('unknown measurer ' + name);

		return method.call(this, element, param1, param2);
	},

	getBorder: function(element, side){
		return element.getComputedStyle('border-' + side + '-width').toInt() || 0;
	},

	getMargin: function(element, side){
		return element.getComputedStyle('margin-' + side).toInt() || 0;
	},

	isBorderBox: function(element){
		return element.getComputedStyle('-moz-box-sizing') == 'border-box';
	}
};

var ElementMeasurers = {
	size: function(element, axis){
		return element['offset' + (axis == 'x' ? 'Width' : 'Height')];
	},

	clientSize: function(element, axis){
		return element['client' + (axis == 'x' ? 'Width' : 'Height')];
	},

	scrollSize: function(element, axis){
		return element['scroll' + (axis == 'x' ? 'Width' : 'Height')];
	},

	scroll: function(element, axis){
		return element['scroll' + (axis == 'x' ? 'Left' : 'Top')];
	},

	offset: function(element, axis){
		return element['offset' + (axis == 'x' ? 'Left' : 'Top')];
	},

	position: function(element, axis){
		return this.measure(element, 'offset', axis) - this.getMargin(element, axis == 'x' ? 'left' : 'top');
	},

	cumulativeScroll: function(element, axis){
		var parent = element.parentNode, scroll = 0;

		while(parent){
			scroll+= this.measure(parent, 'scroll', axis);
			parent = parent.parentNode;
		}

		return scroll;
	},

	cumulativeOffset: function(element, axis){
		var parent = element, offset = 0;

		while(parent){
			offset+= this.measure(parent, 'offset', axis);
			if( parent != element && (browser.safari || browser.firefox && !this.isBorderBox(parent)) ){
				offset+= this.getBorder(parent, axis == 'x' ? 'left' : 'top');
			}
			parent = parent.offsetParent;
		}

		return offset;
	},

	cumulativePosition: function(element, axis, relative){
		var offset = this.measure(element,'cumulativeOffset', axis);
		var scroll = this.measure(element, 'cumulativeScroll', axis);
		var cumulativePosition = offset - scroll;

		if( relative ){
			cumulativePosition-= this.measure(relative,'cumulativePosition', axis);
			cumulativePosition-= this.getBorder(relative, axis == 'x' ? 'left' : 'top');
		}

		return cumulativePosition;
	}
};

// offsets speed improvment
if( !os.ios && 'getBoundingClientRect' in Element.prototype ){
	ElementMeasurers.offsets = function(element, axis){
		var html, offset;

		html = element.ownerDocument.documentElement;
		offset = parseInt(element.getBoundingClientRect()[axis == 'x' ? 'left' : 'top'], 10);

		offset+= this.measure(element, 'cumulativeScroll', axis);
		if( element.getComputedStyle('position') != 'fixed' ) offset+= this.measure(html, 'scroll', axis);
		offset-= html['client' + (axis == 'x' ? 'Left' : 'Top')];

		return offset;
	};
}

if( browser.firefox ){
	ElementMeasurers.offset = function(element, axis){
		var offset = element['offset' + (axis == 'x' ? 'Left' : 'Top')], parent = element.parentNode;

		if( parent && parent.getComputedStyle('overflow') != 'visible' ){
			offset+= this.getBorder(parent, axis == 'x' ? 'left' : 'top');
		}

		return offset;
	};
}

Object.keys(ElementMeasurers).forEach(function(name){
	Methods.defineElementMeasurer(name, ElementMeasurers[name]);
});

if( typeof document != 'undefined' ){
	if( !document.compatMode || document.compatMode == 'CSS1Compat' ){
		document.compatElement = document.html;
	}
	else{
		document.compatElement = document.body;
	}

	var zero = function(){
		return 0;
	};

	var documentMeasurers = {
		size: function(document, axis){
			return ElementMeasurers.size.call(this, document.compatElement, axis);
		},

		clientSize: function(document, axis){
			return ElementMeasurers.clientSize.call(this, document.compatElement, axis);
		},

		scrollSize: function(document, axis){
			return Math.max(
				ElementMeasurers.scrollSize.call(this, document.compatElement, axis),
				ElementMeasurers.scrollSize.call(document.body, axis),
				this.measure(document, 'clientSize', axis)
			);
		},

		scroll: function(axis){
			return window['page' + (axis == 'x' ? 'XOffset' : 'YOffset')];
		},

		offset: zero,
		cumulativeScroll: zero,
		cumulativeOffset: zero,
		cumulativePosition: zero
	};

	if( browser.ie ){
		documentMeasurers.scroll = ElementMeasurers.scroll;
	}

	Object.keys(documentMeasurers).forEach(function(name){
		Methods.defineDocumentMeasurer(name, documentMeasurers[name]);
	});

}

// scrollTo, offsetParent, coordinates
(function(){

	if( typeof document === 'undefined' ) return;

	Element.implement({
		scrollTo: function(x, y){
			this.scrollLeft = x;
			this.scrollTop = y;

			return this;
		},

		getOffsetParent: function(){
			if( this.getComputedStyle('position') != 'fixed' ){
				try{ return this.offsetParent; }
				catch(e){}
			}
			return null;
		},

		getCoordinates: function(element){
			var
				position = Methods.measure(this, 'cumulativePosition', element),
				size = Methods.measure(this, 'size'),
				obj = {
					left: position.x,
					top: position.y,
					width: size.x,
					height: size.y
				}
			;

			obj.right = obj.left + obj.width;
			obj.bottom = obj.top + obj.height;

			return obj;
		}
	});

	var methods = {
		scrollTo: function(x, y){
			window.scrollTo(x, y);
			return this;
		},
		getOffsetParent: function(){
			return null;
		},
		getCoordinates: Element.prototype.getCoordinates
	};

	Object.keys(methods).forEach(function(name){
		var method = methods[name];
		document[name] = document.html[name] = /*document.body[name] = */window[name] = method;
	});

	// offsetparent fix
	(function(){

		function isOffset(el){
			return el.getComputedStyle('position') != 'static';
		}

		function isOffsetStatic(el){
			return isOffset(el) || (/^(?:table|td|th)$/i).test(el.tagName);
		}

		var element = document.createElement('div'), child = document.createElement('div');

		element.style.height = '0';
		element.appendChild(child);
		if( child.offsetParent === element ){
			Element.implement('getOffsetParent', function(){
				var element = this;
				if( element.getComputedStyle('position') == 'fixed' ) return null;

				var isOffsetCheck = element.getComputedStyle('position') == 'static' ? isOffsetStatic : isOffset;
				while( element = element.parentNode ){
					if( isOffsetCheck(element) ) return element;
				}
				return null;
			});
		}

	})();

})();
