var TemplateInstance = {
	template: null,
	fragment: null,
	firstNode: null,
	lastNode: null,
	model: null,
	nodeMap: new WeakMap(),
	toString: function(){ return 'TemplateInstance'; },

	create: function(template){
		this.template = template;
		this.fragment = template.cloneContent();
		this.firstNode = this.fragment.firstChild;
		this.lastNode = this.fragment.lastChild;
		this.linkFragment(this.fragment);
	},

	toggleFragmentMap: function(fragment, link){
		var node = fragment.firstChild;

		while( node ){
			if( link ){
				this.nodeMap.set(node, this);
			}
			else{
				this.nodeMap.delete(node);
			}
			node = node.nextSibling;
		}
	},

	linkFragment: function(fragment){
		return this.toggleFragmentMap(fragment, true);
	},

	unlinkFragment: function(fragment){
		return this.toggleFragmentMap(fragment, false);
	},

	destroy: function(){
		this.unsetModel();
		this.remove();
		this.unlinkFragment(this.fragment);
	},

	getNodeAtPath: function(path){
		return this.firstNode ? this.firstNode.getNodeAtPath(path) : null;
	},

	findNode: function(path){
		var node = this.getNodeAtPath(path);
		if( node == null ){
			console.warn('node not found at', path, 'in', this.firstNode, this);
		}
		return node;
	},

	link: function(model){
		var linkers = this.template.getLinkers(), i = linkers.length, linker, node;

		while(i--){
			linker = linkers[i];
			node = this.findNode(linker.path);
			if( node ){
				linker.link(node, model);
			}
		}
	},

	unlink: function(model){
		var linkers = this.template.getLinkers(), i = linkers.length, linker, node;

		while(i--){
			linker = linkers[i];
			node = this.findNode(linker.path);
			if( node ) linker.unlink(node, model);
		}
	},

	setModel: function(model){
		this.unsetModel();
		this.model = model;
		this.link(model);
	},

	unsetModel: function(model){
		if( this.model != null ){
			this.unlink(model);
			this.model = null;
		}
	},

	insert: function(parent, before){
		this.remove();

		if( !before ){
			parent.appendChild(this.fragment);
		}
		else{
			parent.insertBefore(this.fragment, before);
		}
	},

	remove: function(){
		// not inserted
		if( !this.firstNode || this.firstNode.parentNode == this.fragment ) return;

		var first = this.firstNode, last = this.lastNode, node = this.firstNode, next;

		// put back the node in the fragment
		// -> if insert is called after remove fragment is still filled with the nodeList
		while( node ){
			next = node.nextSibling;
			this.fragment.appendChild(node);
			if( node == last ) break;
			node = next;
		}
	}
};

Object.defineProperty(Node.prototype, 'templateInstance', {
	get: function(){
		var instance = TemplateInstance.nodeMap.get(this);

		if( instance ) return instance;
		if( this.parentNode ) return this.parentNode.templateInstance;
		return undefined;
	}
});

Node.prototype.getNodeAt = function(){
	var node = this, i = 0, j = arguments.length, arg;

	for(;i<j;i++){
		arg = Number(arguments[i]);
		// on utilise nextSibling (car au premier tour on connait pas node.parentNode.childNodes)
		while( arg-- ){
			node = node.nextSibling;
			if( node == null ) return null;
		}

		if( i + 1 < j ){
			node = node.firstChild;
			if( node == null ) return null;
		}
	}

	return node;
};

Node.prototype.getNodeAtPath = function(path){
	return this.getNodeAt.apply(this, path.split('.'));
};

module.exports = TemplateInstance;