/*

FIX:

repeat as marche pas non plus
l'attribut repeat marche plus, ça fait planter le navigateur

*/

var Observer = require('Observer');

var TemplateIterator = {
	ComputedObserver: Observer.ComputedObserver,
	ArrayObserver: Observer.ArrayObserver,
	computedObserver: null,
	arrayObserver: null,
	template: null,
	element: null,
	instances: null,
	closed: false,
	scopeNamed: false,
	toString: function(){ return 'TemplateIterator'; },

	init: function(template){
		this.template = template;
		this.element = template.element;
		this.element.templateIterator = this;
		this.instances = [];
	},

	getNodeForInsertionAt: function(index){
		var before;

		// use firstNode of the nextInstance
		if( this.instances.length > index + 1 ){
			before = this.instances[index + 1].firstNode;
		}
		// use lastNode.nextSibling of the previous instance
		else if( index > 0 ){
			before = this.instances[index - 1].lastNode.nextSibling;
		}
		// use nextSibling of the template element
		else{
			before = this.element.nextSibling;
		}

		return before;
	},

	createInstance: function(model){
		var instance = this.template.createInstance();
		instance.setModel(model);
		return instance;
	},

	createInstanceAt: function(model, index){
		var instance = this.createInstance(model);
		this.instances[index] = instance;
		return instance;
	},

	createAndInsertInstanceAt: function(model, index){
		var instance = this.createInstanceAt(index, model);
		instance.insert(this.element.parentNode, this.getNodeForInsertionAt(index));
		return instance;
	},

	destroyInstances: function(){
		var instances = this.instances, i = 0, j = instances.length;
		for(;i<j;i++){
			instances[i].destroy();
		}
		this.instances.length = 0;
	},

	forEachInputs: function(node, fn, bind){
		var attrNames = ['if', 'repeat', 'bind'], i = 0, j = attrNames.length, attrName;

		bind = bind || this;
		for(;i<j;i++){
			attrName = attrNames[i];
			if( node.hasAttribute(attrName) ){
				fn.call(
					bind,
					attrName,
					node.getAttribute(attrName)
				);
			}
		}
	},

	resolveInputs: function(values){
		if( 'if' in values && !values['if'] ){
			// on supprime toute les instances
			this.destroyInstances();
		}
		else{
			// by default we observer the model
			var model = this.model;

			/*
			on regarde si y'a un as dans le bind
			si y'en a un genre foo as bar
			chaque fois qu'on trouve bar faut le remplacer par foo
			*/

			if( 'repeat' in values ){
				// if repeat exists and is not repeat "alias" in "propertyName"
				if( this.scopeNamed === false && values.repeat ){
					model = values['repeat'];
				}

				// on répète le template pour chaque item
				if( Array.isArray(model) ){
					this.observe(model);
				}
				// supression de toutes les instances
				else{
					this.unobserve();
					this.destroyInstances();
				}
			}
			else{
				// if bind attribute exists and isn't bind "alias" as "propertyName"
				if( this.scopeNamed === false && 'bind' in values && values.bind ){
					model = values['bind'];
				}

				if( this.instances.length === 0 ){
					this.createAndInsertInstanceAt(model, 0);
				}
				else{
					this.instances[0].setModel(model);
				}

			}
		}
	},

	getAttributeKeyword: function(attrName){
		if( attrName == 'repeat' ){
			return 'in';
		}
		else if( attrName == 'bind' ){
			return 'as';
		}
		else{
			return '';
		}
	},

	parseAttributeValue: function(name, value){
		var result = [], index, keyword = this.getAttributeKeyword(name);

		if( keyword ){
			index = value.indexOf(' ' + keyword + ' ');

			if( index !== - 1 ){
				result.push(value.slice(0, index));
				result.push(keyword);
				result.push(value.slice(index + keyword.length + 2));

				return result;
			}
		}

		result.push(value);

		return result;
	},

	checkAttribute: function(name, value){
		var parts = this.parseAttributeValue(name, value);

		if( parts.length > 1 ){
			this.scopeNamed = true;
			var linkers = this.template.getLinkers(), i = 0, j = linkers.length;
			for(;i<j;i++){
				linkers[i].namedScope(parts[0], parts[2]);
			}
		}

		this.computedObserver.observe(name, this.model, parts[0], true);
	},

	checkAttributes: function(){
		this.computedObserver = this.ComputedObserver.new(this.resolveInputs, this);
		this.forEachInputs(this.element, this.checkAttribute, this);
		this.computedObserver.resolve();
	},

	setModel: function(model){
		this.model = model;
		this.checkAttributes();
	},

	close: function(){
		if( this.closed === false ){
			this.unobserve();
			this.destroyInstances();
			this.closed = true;
			this.element.templateIterator = null;
		}
	},

	/*
	When calling sort or reverse on model, i get a list of affectations
	[oldIndex, newIndex, ...]
	The list is used to sync model and this.instances

	As instance represent DOM nodes I have to move DOM nodes accordingly
	for more information look at transformAffectationsToMoves
	*/
	performAffectations: function(change){
		var i, j, oldIndex, index, instance, currentInstance, instances = this.instances, moves = change.toMoves();

		i = 0;
		j = moves.length;
		for(;i<j;i+=2){
			oldIndex = moves[i];
			index = moves[i + 1];
			instance = instances[oldIndex];
			currentInstance = instances[index];

			/*
			move is a costfull operation (two splice) but it's the only way i've found
			to make array state follow DOM insertion 

			the reason is that array.splice and DOM insertion works the same:
			the element is removed from it's place then inserted to his new location
			*/
			instances.move(oldIndex, index);
			instance.insert(this.element.parentNode, currentInstance.firstNode);
		}
	},

	arrayChanged: function(change){
		if( change.type == 'add' ){
			this.createAndInsertInstanceAt(change.value, change.index);
		}
		else if( change.type == 'update' ){
			this.instances[change.index].destroy();
			this.createAndInsertInstanceAt(change.value, change.index);
		}
		else if( change.type == 'remove' ){
			this.instances[change.index].destroy();
			this.instances.splice(change.index, 1);
		}
		else if( change.type == 'affectations' ){
			this.performAffectations(change);
		}
	},

	unobserve: function(){
		if( this.arrayObserver ){
			this.arrayObserver.close();
			this.arrayObserver = null;
		}
	},

	observe: function(array){
		this.unobserve();
		this.arrayObserver = this.ArrayObserver.new(array, this.arrayChanged, this, true);

		// this is fater than listening to array 'add' and insert individually each instance
		var i = 0, j = array.length, instance, fragment;
		if( j !== 0 ){
			fragment = document.createDocumentFragment();
			for(;i<j;i++){
				instance = this.createInstanceAt(array[i], i);
				instance.insert(fragment);
			}
			this.element.parentNode.insertBefore(fragment, this.element.nextSibling);
		}
	}
};

module.exports = TemplateIterator;