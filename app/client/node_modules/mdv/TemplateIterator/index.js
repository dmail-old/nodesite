/*

FIX:

repeat as marche pas non plus
l'attribut repeat marche plus, ça fait planter le navigateur


faudrait que l'élément dans lequel on insère les instances puisse être set
faudrait qu'on puisse ne pas insert les instances, les garder quelque part et les insérer que si on le veut
juste pour le principe (créer un documentfragment?)
n'insérer les éléments que l'on crée

*/

var TemplateIterator = {
	ArrayObserver: require('ArrayObserver'),
	ComputedObserver: require('ComputedObserver'),
	template: null,
	element: null,
	instances: null,
	arrayObserver: null,
	computedObserver: null,
	closed: false,
	scopeNamed: false,

	toString: function(){ return 'TemplateIterator'; },

	init: function(template){
		this.template = template;
		this.element = template.element;
		this.element.templateIterator = this;
		this.instances = [];
	},

	getNodeForInsertionAt: function(index){
		var before;

		// use firstNode of the nextInstance
		if( this.instances.length > index + 1 ){
			before = this.instances[index + 1].firstNode;
		}
		// use lastNode.nextSibling of the previous instance
		else if( index > 0 ){
			before = this.instances[index - 1].lastNode.nextSibling;
		}
		// use nextSibling of the template element
		else{
			before = this.element.nextSibling;
		}

		return before;
	},

	createInstanceAt: function(index, model){
		var instance = this.template.createInstance();
		instance.setModel(model);
		this.instances[index] = instance;
		instance.insert(this.element.parentNode, this.getNodeForInsertionAt(index));
		return instance;
	},

	/*
	When calling sort or reverse on model, i get a list of affectations
	[oldIndex, newIndex, ...]
	The list is used to sync model and this.instances

	As instance represent DOM nodes I have to move DOM nodes accordingly
	for more information look at transformAffectationsToMoves
	*/
	performAffectations: function(change){
		var i, j, oldIndex, index, instance, currentInstance, instances = this.instances, moves = change.toMoves();

		i = 0;
		j = moves.length;
		for(;i<j;i+=2){
			oldIndex = moves[i];
			index = moves[i + 1];
			instance = instances[oldIndex];
			currentInstance = instances[index];

			/*
			move is a costfull operation (two splice) but it's the only way i've found
			to make array state follow DOM insertion 

			the reason is that array.splice and DOM insertion works the same:
			the element is removed from it's place then inserted to his new location
			*/
			instances.move(oldIndex, index);
			instance.insert(this.element.parentNode, currentInstance.firstNode);
		}
	},

	arrayChanged: function(change){
		if( change.type == 'add' ){
			this.createInstanceAt(change.index, change.value);
		}
		else if( change.type == 'update' ){
			this.instances[change.index].destroy();
			this.createInstanceAt(change.index, change.value);
		}
		else if( change.type == 'remove' ){
			this.instances[change.index].destroy();
			this.instances.splice(change.index, 1);
		}
		else if( change.type == 'affectations' ){
			this.performAffectations(change);
		}
	},

	unobserve: function(){
		if( this.arrayObserver ){
			this.arrayObserver.close();
			this.arrayObserver = null;
		}
	},

	observe: function(array){
		this.unobserve();
		// en passant true on auras pas arrayChanged, il faut créer les instance à la main
		this.arrayObserver = this.ArrayObserver.new(array, this.arrayChanged, this, !true);
	},

	destroyInstances: function(){
		var instances = this.instances, i = 0, j = instances.length;
		for(;i<j;i++){
			instances[i].destroy();
		}
		this.instances.length = 0;
	},

	resolveInputs: function(values){
		
		if( 'if' in values && !values['if'] ){
			// on supprime toute les instances
			this.destroyInstances();
		}
		else if( 'repeat' in values ){
			var value = values['repeat'];

			// on répète le template pour chaque item
			if( Array.isArray(value) ){
				this.observe(value);
			}
			// supression de toutes les instances
			else{
				this.unobserve();
				this.destroyInstances();
			}
		}
		else{
			// on observe une sous partie du modèle, ou le modèle lui même
			var model;

			// bind = "name as othername" -> utilise le model
			if( this.scopeNamed || !('bind' in values) ){
				model = this.model;
			}
			// bind = "name" -> utilise le sous objet appelé "name"
			else{
				model = values['bind'];
			}

			/*
			on regarde si y'a un as dans le bind
			si y'en a un genre foo as bar
			chaque fois qu'on trouve bar faut le remplacer par foo
			*/

			if( this.instances.length === 0 ){
				this.createInstanceAt(0, model);
			}
			else{
				this.instances[0].setModel(model);
			}
		}
	},

	getAttributeKeyword: function(attrName){
		if( attrName == 'repeat' ){
			return 'in';
		}
		else if( attrName == 'bind' ){
			return 'as';
		}
		else{
			return '';
		}
	},

	parseAttributeValue: function(name, value){
		var result = [], index, keyword = this.getAttributeKeyword(name);

		if( keyword ){
			index = value.indexOf(' ' + keyword + ' ');

			if( index !== - 1 ){
				result.push(value.slice(0, index));
				result.push(keyword);
				result.push(value.slice(index + keyword.length + 2));

				return result;
			}
		}

		result.push(value);

		return result;
	},

	forEachInputs: function(node, fn, bind){
		var attrNames = ['if', 'repeat', 'bind'], i = 0, j = attrNames.length, attrName;

		bind = bind || this;
		for(;i<j;i++){
			attrName = attrNames[i];
			if( node.hasAttribute(attrName) ){
				fn.call(
					bind,
					attrName,
					node.getAttribute(attrName)
				);
			}
		}
	},

	checkAttribute: function(name, value){

		var parts = this.parseAttributeValue(name, value);

		if( parts.length > 1 ){
			this.scopeNamed = true;
			var linkers = this.template.getLinkers(), i = 0, j = linkers.length;
			for(;i<j;i++){
				linkers[i].namedScope(parts[0], parts[2]);
			}
		}

		this.computedObserver.observe(name, this.model, parts[0], true);
	},

	checkAttributes: function(){
		this.computedObserver = this.ComputedObserver.new(this.resolveInputs, this);
		this.forEachInputs(this.element, this.checkAttribute, this);
		this.computedObserver.resolve();
	},

	setModel: function(model){
		this.model = model;
		this.checkAttributes();
	},

	close: function(){
		if( this.closed === false ){
			this.unobserve();
			this.destroyInstances();
			this.closed = true;
			this.element.templateIterator = null;
		}
	}
};

module.exports = TemplateIterator;