var Linker = require('../Linker');
var TemplateIterator = require('mdv/templateIterator');
var proto = require('@dmail/proto');

var SubTemplateLinker = proto.extend.call(Linker, {
	name: 'SubTemplateLinker',
	terminal: true,
	template: null,

	constructor: function(templateElement){
		this.template = this.createTemplate(templateElement);
	},

	createTemplate: function(element){
		return require('mdv/Template').create(element);
	},

	link: function(node, model){
		if( node.childNodes.length === 0 && this.template.content.childNodes.length !== 0 ){
			node.appendChild(this.template.cloneContent());
		}
		/*
		explanation of the previous if:

		calling Template.new(node)
		put node.childNodes in a documentfragment
		the next time link is called node.childNodes is empty
		so we need to repopulate childNodes with the original childNodes

		native template doesn't need that because their contents is also
		cloned when doing content.cloneNode(true)
		*/

		if( this.modelPath ){
			this.checkAttributes(node);
		}

		var template = this.createTemplate(node);
		template.linkers = this.template.getLinkers();

		var iterator = TemplateIterator.create(template);
		iterator.setModel(model);
	},

	unlink: function(node, model){
		node.templateIterator.close();
		node.templateIterator = null;
	},

	checkAttributes: function(node){
		TemplateIterator.forEachInputs(node, function(name, value){
			var parts = TemplateIterator.parseAttributeValue.call(TemplateIterator, name, value);

			parts[0] = this.getNamedScopePath(
				parts[0],
				this.modelPath,
				this.modelPathAlias
			);

			node.setAttribute(name, parts.join(' '));

		}, this);

		if( !node.hasAttribute('bind') && !node.hasAttribute('repeat') ){
			// je suis cens√© propager namedScope au subtemplate
		}
	},

	namedScope: function(path, replace){
		this.modelPath = path;
		this.modelPathAlias = replace;
	}
});

module.exports = SubTemplateLinker;
