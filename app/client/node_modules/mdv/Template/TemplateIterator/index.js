/*

FIX:

repeat as marche pas non plus
l'attribut repeat marche plus, ça fait planter le navigateur


*/

var TemplateIterator = {
	ArrayObserver: require('objectObserver/arrayObserver'),
	ComputedBinding: require('ComputedBinding'),
	TemplateInstance: require('../TemplateInstance'),
	template: null,
	element: null,
	instances: null,
	arrayObserver: null,
	closed: false,
	inputs: null,
	scopeNamed: false,

	toString: function(){ return 'TemplateIterator'; },

	init: function(template){
		this.template = template;
		this.element = template.element;
		this.instances = [];
	},

	createInstance: function(model){
		var instance = this.TemplateInstance.new(this.template);
		instance.setModel(model);
		return instance;
	},

	getNodeForInsertionAt: function(index){
		var before;

		// use firstNode of the nextInstance
		if( this.instances.length > index + 1 ){
			before = this.instances[index + 1].firstNode;
		}
		// use lastNode.nextSibling of the previous instance
		else if( index > 0 ){
			before = this.instances[index - 1].lastNode.nextSibling;
		}
		// use nextSibling of the template element
		else{
			before = this.element.nextSibling;
		}

		return before;
	},

	insertInstanceAt: function(index, model){
		var instance = this.createInstance(model);
		this.instances[index] = instance;
		instance.insert(this.element.parentNode, this.getNodeForInsertionAt(index));
		return instance;
	},

	/*
	When calling sort or reverse on model, i get a list of affectations
	[oldIndex, newIndex, ...]
	The list is used to sync model and this.instances

	As instance represent DOM nodes I have to move DOM nodes accordingly
	for more information look at transformAffectationsToMoves
	*/
	performAffectations: function(affectations){
		var i, j, oldIndex, index, instance, currentInstance, instances = this.instances;
		var moves = this.ArrayObserver.transformAffectationsToMoves(affectations);

		i = 0;
		j = moves.length;
		for(;i<j;i+=2){
			oldIndex = moves[i];
			index = moves[i + 1];
			instance = instances[oldIndex];
			currentInstance = instances[index];

			/*
			move is a costfull operation (two splice) but it's the only way i've found
			to make array state follow DOM insertion 

			the reason is that array.splice and DOM insertion works the same:
			the element is removed from it's place then inserted to his new location
			*/
			instances.move(oldIndex, index);
			instance.insert(this.element.parentNode, currentInstance.firstNode);
		}
	},

	arrayChanged: function(change){
		if( change.type == 'add' ){
			this.insertInstanceAt(change.index, change.value);
		}
		else if( change.type == 'update' ){
			this.instances[change.index].destroy();
			this.insertInstanceAt(change.index, change.value);
		}
		else if( change.type == 'remove' ){
			this.instances[change.index].destroy();
			this.instances.splice(change.index, 1);
		}
		else if( change.type == 'affectations' ){
			this.performAffectations(change.value);
		}
	},

	unobserve: function(){
		if( this.arrayObserver ){
			this.arrayObserver.close();
			this.arrayObserver = null;
		}
	},

	observe: function(array){
		this.unobserve();
		this.arrayObserver = this.ArrayObserver.new(array, this.arrayChanged, this);
	},

	destroyInstances: function(){
		var instances = this.instances, i = 0, j = instances.length;
		for(;i<j;i++){
			instances[i].destroy();
		}
		this.instances.length = 0;
	},

	resolveInputs: function(values){
		
		if( 'if' in values && !values['if'] ){
			// on supprime toute les instances
			this.destroyInstances();
		}
		else if( 'repeat' in values ){
			var value = values['repeat'];

			// on répète le template pour chaque item
			if( Array.isArray(value) ){
				this.observe(value);
			}
			// supression de toutes les instances
			else{
				this.unobserve();
				this.destroyInstances();
			}
		}
		else{
			// on observe une sous partie du modèle, ou le modèle lui même
			var model;

			// bind = "name as othername" -> utilise le model
			if( this.scopeNamed || !('bind' in values) ){
				model = this.template.model;
			}
			// bind = "name" -> utilise le sous objet appelé "name"
			else{
				model = values['bind'];
			}

			/*
			on regarde si y'a un as dans le bind
			si y'en a un genre foo as bar
			chaque fois qu'on trouve bar faut le remplacer par foo
			*/

			if( this.instances.length === 0 ){
				this.insertInstanceAt(0, model);
			}
			else{
				this.instances[0].setModel(model);
			}
		}
	},

	getAttributeKeyword: function(attrName){
		if( attrName == 'repeat' ){
			return 'in';
		}
		else if( attrName == 'bind' ){
			return 'as';
		}
		else{
			return '';
		}
	},

	parseAttributeValue: function(name, value){
		var result = [], index, keyword = this.getAttributeKeyword(name);

		if( keyword ){
			index = value.indexOf(' ' + keyword + ' ');

			if( index !== - 1 ){
				result.push(value.slice(0, index));
				result.push(keyword);
				result.push(value.slice(index + keyword.length + 2));

				return result;
			}
		}

		result.push(value);

		return result;
	},

	forEachInputs: function(node, fn, bind){
		var attrNames = ['if', 'repeat', 'bind'], i = 0, j = attrNames.length, attrName;

		bind = bind || this;
		for(;i<j;i++){
			attrName = attrNames[i];
			if( node.hasAttribute(attrName) ){
				fn.call(
					bind,
					attrName,
					node.getAttribute(attrName)
				);
			}
		}
	},

	checkAttribute: function(name, value){

		var parts = this.parseAttributeValue(name, value);

		if( parts.length > 1 ){
			this.scopeNamed = true;
			var linkers = this.template.getLinkers(), i = 0, j = linkers.length;
			for(;i<j;i++){
				linkers[i].namedScope(parts[0], parts[2]);
			}
		}

		this.inputs.observe(name, this.template.model, parts[0], true);
	},

	checkAttributes: function(){
		this.inputs = this.ComputedBinding.new(this.resolveInputs, this);
		this.forEachInputs(this.element, this.checkAttribute, this);
		this.inputs.resolve();
	},

	close: function(){
		if( this.closed === false ){
			this.unobserve();
			this.destroyInstances();
			this.closed = true;
		}
	}
};

module.exports = TemplateIterator;