require('Map');

var TemplateInstance = {
	template: null,
	fragment: null,
	firstNode: null,
	lastNode: null,
	model: null,
	hasModel: false,
	nodeMap: new Map(),	
	toString: function(){ return 'TemplateInstance'; },

	init: function(template){
		this.template = template;
		this.fragment = template.cloneContent();
		this.firstNode = this.fragment.firstChild;
		this.lastNode = this.fragment.lastChild;
		this.registerFragment(this.fragment);
	},

	toggleFragmentMap: function(fragment, link){
		var node = fragment.firstChild;

		while( node ){
			if( link ){
				this.nodeMap.set(node, this);
			}
			else{
				this.nodeMap.delete(node);
			}
			node = node.nextSibling;
		}
	},

	registerFragment: function(fragment){
		return this.toggleFragmentMap(fragment, true);
	},

	unregisterFragment: function(fragment){
		return this.toggleFragmentMap(fragment, false);
	},	

	getNodeAtPath: function(path){
		return this.firstNode ? this.firstNode.getNodeAtPath(path) : null;
	},

	findNode: function(path){
		var node = this.getNodeAtPath(path);
		if( node == null ){
			console.warn('node not found at', path, 'in', this.firstNode, this);
		}
		return node;
	},

	link: function(model){
		var linkers = this.template.getLinkers(), i = linkers.length, linker, node;

		while(i--){
			linker = linkers[i];
			node = this.findNode(linker.path);
			if( node ){
				linker.link(node, model);
			}
		}
	},

	unlink: function(model){
		var linkers = this.template.getLinkers(), i = linkers.length, linker, node;

		while(i--){
			linker = linkers[i];
			node = this.findNode(linker.path);
			if( node ) linker.unlink(node, model);
		}
	},

	setModel: function(model){
		this.unsetModel();
		this.model = model;
		this.hasModel = true;
		this.link(model);
	},

	unsetModel: function(model){
		if( this.hasModel === true ){
			this.unlink(model);
			this.hasModel = false;
			this.model = null;
		}
	},

	inDOM: function(){
		return this.firstNode !== null && this.firstNode.parentNode === this.fragment;
	},

	insert: function(parent, before){
		this.remove();

		if( before ){
			parent.insertBefore(this.fragment, before);
		}
		else{
			parent.appendChild(this.fragment);
		}
	},

	remove: function(){
		if( this.inDOM() ){
			var first = this.firstNode, last = this.lastNode, node = this.firstNode, next;

			// put back the node in the fragment
			// -> if insert is called after remove fragment is still filled with the nodeList
			while( node ){
				next = node.nextSibling;
				this.fragment.appendChild(node);
				if( node === last ) break;
				node = next;
			}
		}
	},

	destroy: function(){
		this.unsetModel();
		this.remove();
		this.unregisterFragment(this.fragment);
	}
};

var NodeProperties = {
	get templateInstance(){
		var instance = TemplateInstance.nodeMap.get(this);

		if( instance ) return instance;
		if( this.parentNode ) return this.parentNode.templateInstance;
		return undefined;
	},

	getNodeAt: function(){
		var node = this, i = 0, j = arguments.length, arg;

		for(;i<j;i++){
			arg = Number(arguments[i]);
			// on utilise nextSibling (car au premier tour on connait pas node.parentNode.childNodes)
			while( arg-- ){
				node = node.nextSibling;
				if( node == null ) return null;
			}

			if( i + 1 < j ){
				node = node.firstChild;
				if( node == null ) return null;
			}
		}

		return node;
	},

	getNodeAtPath: function(path){
		return this.getNodeAt.apply(this, path.split('.'));
	}
};

require('property').implement(window.Node, NodeProperties);

TemplateInstance.NodeProperties = NodeProperties;
module.exports = TemplateInstance;