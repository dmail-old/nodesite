/*

Handle multiple DuplexStream from one Duplex stream, the first stream can be Readable only

look at passthrougth()
faut que ça fonctionne même si je lui passe un stream qui n'est que writable
ou que readable, dans ce cas il se demerde pour gérer le passage des données d'un stream à l'autre

si je chain un writable qu'est ce que ça veut dire?

que ce que j'écris dans le writable doit arriver dans la précédent stream non?
donc this.lastStream.pipe(stream) c'est ok.

si ensuite je remet encore un writable qu'est ce que je fais?
ben je pipe le readable dans le writable encore

cependant ce que j'écris dans le writable devrait être readable

dans ce cas là ce que je peux faire c'est euhh

pour un stream que writable pas de solution miracle pour le moment
pour un readable je crée un passtrough qui le rend writable aussi

https://github.com/stream-utils/raw-body/blob/master/index.js


*/

var Duplex = new require('stream').Duplex;
var ComputedStream = Duplex.prototype.create({
	constructor: Duplex,
	resolving: false,
	streams: null,

	init: function(){
		this.constructor.apply(this, arguments); // or Dupplex.apply(this, arguments)
		this.streams = [];
		this.on('addListener', this.onAddListener);
	},

	_read: Duplex.prototype.read,
	
	_write: function(chunk){
		this.push(chunk);
	},

	chain: function(stream, isHead){
		if( this.resolving ){
			throw new Error('computedStream is resolving no more stream can be chained');
		}

		if( isHead ){
			this.streams.unshift(stream);
		}
		else{
			this.streams.push(stream);
		}
	},

	_resolve: function(){
		var stream, streams = this.streams, i = streams.length, prevStream = this;

		while(i--){
			var state = stream._readableState;
			if( state && state.encoding != null ){
				this.emit('error', 'stream encoding should not be set, it should emit buffers');
				break;
			}

			stream = streams[i];
			stream.pipe(prevStream);
			
			// computedStream handle error the stream he is composed with
			stream.on('error', function(stream, error){
				this.emit('error', error, stream);
			}.bind(this, stream));

			prevStream = stream;
		}
	},

	// pipe all streams starting the data manipulation
	resolve: function(){
		if( this.resolving ){
			return false;
		}

		this.resolving = true;
		this._resolve();

		return true;
	},

	// auto resolve when data listener is added
	onAddListener: function(listener){		
		if( listener == 'data' ){
			this.removeListener('addListener', this.onAddListener);
			process.nextTick(this.resolve.bind(this));
		}
	}
});

module.exports = ComputedStream;