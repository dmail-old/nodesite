//example à garder, voici comment faire se succéder des streams
exports['combine streams'] = function(){
	var fileStream = require('fs').createReadStream('test.txt');
	var stream = new require('stream').Duplex();
	var stream_a = new require('stream').Duplex();
	var stream_b = new require('stream').Duplex();

	stream._read = function(n){
		return this.read(n);
	};
	stream._write = function(chunk){
		this.push(chunk);
	};
	stream_a._read = function(n){
		return this.read(n);
	};
	stream_a._write = function(chunk){
		console.log('stream_a got', chunk.toString());
		this.push(chunk.toString() + 'stream_a');
	};
	stream_b._read = function(n){
		return this.read(n);
	};
	stream_b._write = function(chunk){
		console.log('stream_b got', chunk.toString());
		this.push(chunk.toString() + 'stream_b');
	};

	stream.on('data', function(chunk){
		console.log('stream got', chunk.toString());
	});

	stream.on('error', function(){
		console.log('stream error');
	});

	stream_a.on('error', function(){
		console.log('stream_a error');
	});
	fileStream.on('error', function(){
		console.log('filestream error');
	});

	//stream_b.pipe(stream);
	//stream_a.pipe(stream_b);
	//fileStream.pipe(stream_a);
	//stream_a.emit('error', new Error());

	var ComputedStream = require('computedStream');
	var computedStream = new ComputedStream();

	computedStream.chain(fileStream);
	computedStream.chain(stream_a);
	computedStream.chain(stream_b);

	computedStream.on('data', function(data){
		console.log('computedStream', data.toString());
	});
};