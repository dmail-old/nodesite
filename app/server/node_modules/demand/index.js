var demand = require('./demand');

// http://www.senchalabs.org/connect/
// need to do like connect to support multipart

// multipart parser
// https://github.com/mcavage/node-restify/blob/master/lib/plugins/multipart_parser.js

// very important, keep any async operation after bodyParser else request is aborted

// cookieParser
demand.use('cookieParser', function(next){
	this.cookieSource = this.request.headers.cookie;

	if( this.cookieSource ){
		this.cookieParams = this.parseCookie(this.cookieSource);
		if( this.cookieParams == null ){
			next(new Error('invalid cookies format'));
		}
		else if( this.cookieParams instanceof Error ){
			next(this.cookieParams);
		}
	}
	next();
});

// urlParser
demand.use('urlParser', function(next){
	this.url = this.parseUrl(this.request.url);
	// bad request
	if( this.url == null ) return this.send(400);
	next();
});

//queryParser
demand.use('queryParser', function(next){
	this.urlParams = this.parseQueryString(this.url.query);
	if( this.urlParams == null ) return next(new Error('invalid query params'));
	next();
});

// bodyParser
demand.use('bodyParser', function(next){
	if( this.method == this.METHODS.POST || this.method == this.METHODS.PUT ){
		var contentType = this.getRequestContentType();

		this.getRequestBody(function(error, body){

			if( error ) return next(error);
			this.bodySource = body;

			if( contentType == 'application/json' ){
				this.bodyParams = this.parseJSON(body);
			}
			else if( contentType == 'application/x-www-form-urlencoded' ){
				// check with connect
				this.bodyParams = this.parseQueryString(body);
			}
			else if( contentType == 'multipart/form-data' ){
				// TODO
			}

			if( this.bodyParams == null ) return next(new Error('invalid body params'));
			next();

		}, this);
	}
	else{
		next();
	}
});

// methodOverride
demand.use('methodOverride', function(next){
	this.originalMethod = this.method;

	if( '_method' in this.urlParams ){
		this.method = this.urlParams._method.toUpperCase();
	}
	else if( '_method' in this.bodyParams ){
		this.method = this.bodyParams._method.toUpperCase();
	}
	else if( 'x-http-method-override' in this.request.headers ){
		this.method = this.request.headers['x-http-method-override'].toUpperCase();
	}

	next();
});

// params
demand.use('params', function(next){
	this.params = Object.append({}, this.urlParams, this.bodyParams);
	next();
});

// jsonParam
demand.use('jsonParam', function(next){
	if( this.bodyParams.json ){
		this.bodyParams.json = this.parseJSON(this.bodyParams.json);
		this.params.json = this.bodyParams.json;
	}
	if( this.urlParams.json ){
		this.urlParams.json = this.parseJSON(this.urlParams.json);
		this.params.json = this.urlParams.json;
	}
	next();
});

// responseTime
demand.use('responseTime', function(next){
	this.startTime = new Date();
	this.emitter.on('header', function(){
		var time = new Date() - this.startTime;
		this.setHeader('x-response-time', time);
	});
	next();
});

// sendCORS
demand.use('sendCORS', function(next){
	if( this.method == this.METHODS.OPTIONS ){
		this.sendCORS();
	}
	else{
		next();
	}
});

// session, I need to know wich user is asking from now
demand.use('session', function(next){
	if( this.cookieParams.session ){
		this.user = DB.find('user', 'session:' + this.cookieParams.session, function(error, user){
			if( error ){
				next(error);
			}
			else{
				this.user = user;
				next();
			}
		}, this);
	}
	else{
		next();
	}	
});

// sendAction
demand.use('sendAction', function(next){
	if( this.url.pathname.slice(0, this.url.pathname.indexOf('/', 1)) == '/action' ){
		this.sendAction(this.url.pathname);
	}
	else{
		next();
	}
});

demand.getFirstDirName = function(){
	return this.url.pathname.slice(0, this.url.pathname.indexOf('/', 1)).slice(1);
};

// sendModule
demand.use('sendModule', function(next){
	if( (this.method == this.METHODS.HEAD || this.method == this.METHODS.GET) && this.url.pathname.startsWith('/node_modules/') ){
		this.sendModule(this.url.pathname.slice('/node_modules/'.length));
	}
	else{
		next();
	}
});

// sendFile
demand.use('sendFile', function(next){

	function isFileRequest(){
		if( this.method != this.METHODS.HEAD && this.method != this.METHODS.GET ) return false;

		var pathname = this.url.pathname, slash = pathname.indexOf('/', 1);		
		// on demande quelque chose Ã  la racine, ayant une extension
		if( slash === -1 && pathname.contains('.') ){
			return true;
		}

		var dirname = this.getFirstDirName();
		if( dirname == 'css' || dirname == 'js' || dirname == 'img' || dirname == 'element' || dirname == 'tests' ){
			return true;
		}

		return false;
	}

	if( isFileRequest.call(this) ){
		this.sendFile(global.CLIENT_PATH + this.url.pathname);
	}
	else{
		next();
	}
});

/* sendPage, always sendPage to every other URL

TODO: only send this to resolved routes, unresolved routes try to serve a file
specific behaviour like example being browsed client side must be defined in a file that is send to the client
and all concerned routes must be handled by this file
*/
demand.use('sendPage', function(next){
	this.sendPage();
});

module.exports = demand;