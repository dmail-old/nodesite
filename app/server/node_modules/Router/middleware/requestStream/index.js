/*

THE FINAL GOAL:

If a request send a file in content-encoding: gzip
If the appropriate behaviour is to save that file on the server
The bodyreader stream could just be piped to a filesystem write stream

TODO:

*/

var RequestMethods = {
	Stream: require('ChangeStream'),
	stream: null,
	maxLength: 1e6,
	defaultEncoding: 'identity',
	defaultMediaType: 'application/octet-stream', // RFC2616 section 7.2.1
	defaultCharset: 'utf8',

	bytesReceived: 0,
	bytesExpected: null,
	bytesLimit: -1,
	hash: null,
	md5: null,

	parseContentType: function(contentType){
		var mediaType = null, charset = null, search = ';charset=', index;

		if( typeof contentType == 'string' ){
			index = contentType.indexOf(search);

			if( index === -1 ){
				search = '; charset=';
				index = contentType.indexOf(search);
			}

			if( index === -1 ){
				mediaType = contentType;
			}
			else{
				mediaType = contentType.slice(0, index);
				charset = contentType.slice(index + search.length);
				if( charset == 'utf-8' ) charset = 'utf8';
			}
		}

		return [mediaType, charset];
	},

	get length(){
		return this.headers['content-length'];
	},

	get encoding(){
		if( this.hasHeader('content-encoding') ){
			return this.headers['content-encoding'];
		}
		return this.defaultEncoding;
	},

	get mediaType(){
		if( this.hasHeader('content-type') ){
			return this.parseContentType(this.headers['content-type'])[0];
		}
		return this.defaultMediaType;
	},

	get charset(){
		if( this.hasHeader('content-type') ){
			return this.parseContentType(this.headers['content-type'])[1];
		}
		return this.defaultCharset;
	},

	hasBody: function(){
		if( this.is('post', 'put') === false ){
			return false;
		}
		if( this.hasHeader('transfer-encoding') ){
			return true;
		}
		if( this.getHeader('transfer-encoding') === 'chunked' ){
			return false;
		}
		if( this.getHeader('content-length') == '0' ){
			return false;
		}
		return true;
	},

	// when request is aborted
	createAbortedError: function(){
		return new Error('request aborted');
	},

	createTooLargeError: function(received, limit){
		// this.request.connection.destroy();
		var error = new Error();

		error.message = 'Data too large: {received} > {limit}';
		error.data = {
			received: received,
			limit: limit
		};
		error.statusCode = 413; // too large
		error.code = 'TOO_LARGE';

		return error;
	},

	createBadSizeError: function(received, expected){
		var error = new Error();

		error.message = 'Received bytes must be equal to expected bytes: {received} != {expected}';
		error.data = {
			received: received,
			expected: expected
		};
		error.statusCode = 400; // bad request
		error.code = 'BAD_SIZE';

		return error;
	},

	createBadDigestError: function(digest, expected){
		var error = new Error();

		error.message = 'Bad digest error: md5 don\'t match: {digest} != {expected}';
		error.data = {
			digest: digest,
			expected: expected
		};
		error.statusCode = 400;
		error.code = 'BAD_DIGEST';

		return error;
	},

	createUnsupportedEncodingError: function(encoding){
		var error = new Error();

		error.message = 'Unsupported charset {encoding}. Supported encodings: {encodings}';
		error.data = {
			encoding: encoding,
			supporteds: Object.keys(this.Stream.decoders)
		};
		error.statusCode = 415;	// unsupported request header
		error.code = 'UNSUPPORTED_ENCODING';

		return error;
	},

	createUnsupportedCharsetError: function(charset){
		var error = new Error();

		error.message = 'Unsupported charset {charset}. Supported charsets: {charsets}';
		error.data = {
			charset: charset,
			supporteds: Object.keys(this.Stream.deconverters)
		};
		error.statusCode = 415;	// unsupported request header
		error.code = 'UNSUPPORTED_CHARSET';

		return error;
	},

	isTooLarge: function(byteCount){
		var limit = this.bytesLimit;
		return typeof byteCount === 'number' && typeof limit === 'number' && limit != -1 && byteCount > limit;
	},

	ondata: function(chunk){
		this.bytesReceived+= chunk.length;
		this.emit('progress', this.bytesReceived, this.bytesExpected);

		if( this.isTooLarge(this.bytesReceived) ){
			this.emit('error', this.createTooLargeError(this.bytesReceived, this.byteLimit));
		}
		else if( this.hash ){
			this.hash.write(chunk);
		}
	},

	onend: function(){
		if( typeof this.bytesExpected == 'number' && this.bytesExpected != -1 && this.bytesReceived != this.bytesExpected ){
			this.emit('error', this.createBadSizeError(this.bytesReceived, this.bytesExpected));
		}
		else if( this.hash && this.md5 != this.hash.digest() ){
			this.emit('error', this.createBadDigestError(this.hash.digest(), this.md5));
		}
	},	

	createStream: function(){
		var stream = this.Stream.new(), request = this;

		// content-md5
		if( 'content-md5' in request.headers ){
			request.hash = require('crypto').createHash('md5').setEncoding('base64');
			request.md5 = request.headers['content-md5'];
		}

		request.bytesExpected = request.length;
		request.bytesLimit = request.maxLength;
		if( this.isTooLarge(request.bytesExpected) ){
			throw this.createTooLargeError(request.bytesExpected, request.bytesLimit);
		}

		var encoding = request.encoding;
		if( stream.supportFromEncoding(encoding) ){
			stream.fromEncoding = encoding;
		}
		else{
			throw this.createUnsupportedEncodingError(encoding);
		}

		var charset = request.charset;
		if( stream.supportFromCharset(charset) ){
			stream.fromCharset = charset;
		}
		else{
			throw this.createUnsupportedCharsetError(charset);
		}

		stream.on('data', this.ondata.bind(this));
		stream.on('end', this.onend.bind(this));

		// start reading from the request stream
		stream.chain(request, true);
		// when request is aborted we have to stop reading from request stream
		request.on('abort', function(){
			this.unpipe();
			this.emit('error', this.createAbortedError());
		});

		request.stream = stream;
	},

	parsers: require('./parsers'),
	bodyParams: null,
	initStream: function(fn, bind){
		var request = this, mediaType;

		bind = bind || this;

		try{
			this.createStream();
		}
		catch(e){
			return fn.call(bind, e);
		}

		if( mediaType in this.parsers ){
			this.stream.resolve();
			this.parsers[mediaType](this.stream, fn.bind(bind));
		}
		else{
			fn.call(bind);
		}
	}
};

module.exports = {
	request: RequestMethods,

	handle: function(){
		if( this.request.hasBody() ){
			this.request.initStream(function(error, params){
				if( error ){
					this.error(error);
				}
				else{
					this.request.bodyParams = params;
					this.next();
				}
			}, this);
		}
		else{
			this.next();
		}
	}
};