/*

THE FINAL GOAL:

If a request send a file in content-encoding: gzip
If the appropriate behaviour is to save that file on the server
The bodyreader stream could just be piped to a filesystem write stream

TODO:

*/

var RequestMethods = {
	Stream: require('BodyReadStream'),
	stream: null,
	maxLength: 1e6,
	defaultEncoding: 'identity',
	defaultMediaType: 'application/octet-stream', // RFC2616 section 7.2.1
	defaultCharset: 'utf8',

	parseContentType: function(contentType){
		var mediaType = null, charset = null, search = ';charset=', index;

		if( typeof contentType == 'string' ){
			index = contentType.indexOf(search);

			if( index === -1 ){
				search = '; charset=';
				index = contentType.indexOf(search);
			}

			if( index === -1 ){
				mediaType = contentType;
			}
			else{
				mediaType = contentType.slice(0, index);
				charset = contentType.slice(index + search.length);
				if( charset == 'utf-8' ) charset = 'utf8';
			}
		}

		return [mediaType, charset];
	},

	get length(){
		return this.headers['content-length'];
	},

	get encoding(){
		if( this.hasHeader('content-encoding') ){
			return this.headers['content-encoding'];
		}
		return this.defaultEncoding;
	},

	get mediaType(){
		if( this.hasHeader('content-type') ){
			return this.parseContentType(this.headers['content-type'])[0];
		}
		return this.defaultMediaType;
	},

	get charset(){
		if( this.hasHeader('content-type') ){
			return this.parseContentType(this.headers['content-type'])[1];
		}
		return this.defaultCharset;
	},

	hasBody: function(){
		if( this.is('post', 'put') === false ){
			return false;
		}
		if( this.hasHeader('transfer-encoding') ){
			return true;
		}
		if( this.getHeader('transfer-encoding') === 'chunked' ){
			return false;
		}
		if( this.getHeader('content-length') == '0' ){
			return false;
		}
		return true;
	},

	// when request is aborted
	createAbortedError: function(){
		return new Error('request aborted');
	},

	createStream: function(){
		var stream = this.Stream.new(), request = this;

		// start reading from the request stream
		stream.chain(request, true);
		// when request is aborted we have to stop reading from request stream
		request.on('abort', function(){
			this.unpipe();
			this.emit('error', this.createAbortedError());
		});

		// content-md5
		if( 'content-md5' in request.headers ){
			var hash = require('crypto').createHash('md5').setEncoding('base64');
			stream.setHash(hash, request.headers['content-md5']);
		}

		stream.setBytesLimit(request.maxLength);
		stream.setBytesExpected(request.length);
		stream.setEncoding(request.encoding);
		stream.setCharset(request.charset);

		// on a fini on s'occupe plus que de content-type au besoin sinon on touche mÃªme pas le stream
		return stream;
	},

	parsers: require('./parsers'),
	bodyParams: null,
	getStream: function(fn, bind){
		var request = this, stream, mediaType;

		bind = bind || this;

		try{
			stream = this.createStream();
		}
		catch(e){
			return fn.call(bind, e);
		}

		if( mediaType in this.parsers ){
			stream.resolve();
			this.parsers[mediaType](stream, function(error, params){
				if( error ) return fn(error);
				request.bodyParams = params;
				fn.call(bind, null, stream);
			});
		}
		else{
			fn.call(bind, null, stream);
		}
	}
};

module.exports = {
	request: RequestMethods,

	handle: function(){
		if( this.request.hasBody() ){
			this.request.getStream(function(error, stream){
				if( error ){
					this.error(error);
				}
				else{
					this.request.stream = stream;
					this.next();
				}
			}, this);
		}
		else{
			this.next();
		}
	}
};