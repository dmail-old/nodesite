var ComputedStream = require('computedStream');
var BodyReadStream = ComputedStream.extend({
	decoders: require('./decoders'),
	converters: require('./converters'),

	bytesReceived: 0,
	bytesExpected: null,
	bytesLimit: -1,
	encoding: 'identity',
	charset: 'utf8',
	hash: null,
	digest: null,

	init: function(){
		this.on('data', this.ondata);
		this.on('end', this.onend);
	},

	createUnsupportedCharsetError: function(charset){
		var error = new Error();

		error.message = 'Unsupported charset {charset}. Supported charsets: {charsets}';
		error.data = {
			charset: charset,
			supporteds: Object.keys(this.decoders)
		};
		error.statusCode = 415;	// unsupported request header
		error.code = 'UNSUPPORTED_CHARSET';

		return error;
	},

	createUnsupportedEncodingError: function(encoding){
		var error = new Error();

		error.message = 'Unsupported charset {encoding}. Supported encodings: {encodings}';
		error.data = {
			encoding: encoding,
			supporteds: Object.keys(this.converters)
		};
		error.statusCode = 415;	// unsupported request header
		error.code = 'UNSUPPORTED_ENCODING';

		return error;
	},		

	createTooLargeError: function(received, limit){
		// this.request.connection.destroy();
		var error = new Error();

		error.message = 'Data too large: {received} > {limit}';
		error.data = {
			received: received,
			limit: limit
		};
		error.statusCode = 413; // too large
		error.code = 'TOO_LARGE';

		return error;
	},

	createBadSizeError: function(received, expected){
		var error = new Error();

		error.message = 'Received bytes must be equal to expected bytes: {received} != {expected}';
		error.data = {
			received: received,
			expected: expected
		};
		error.statusCode = 400;  // bad request
		error.code = 'BAD_SIZE';

		return error;
	},

	createBadDigestError: function(digest, expected){
		var error = new Error();

		error.message = 'Bad digest error: md5 don\'t match: {digest} != {expected}';
		error.data = {
			digest: digest,
			expected: expected
		};
		error.statusCode = 400;
		error.code = 'BAD_DIGEST';

		return error;
	},

	ondata: function(chunk){
		this.bytesReceived+= chunk.length;
		this.emit('progress', this.bytesReceived, this.bytesExpected);

		if( typeof this.byteLimit == 'number' && this.bytesLimit != -1 && this.bytesReceived > this.byteLimit ){
			this.emit('error', this.createTooLargeError(this.bytesReceived, this.byteLimit));
		}
		else if( this.hash ){
			this.hash.write(chunk);
		}
	},

	onend: function(){
		if( typeof this.bytesExpected == 'number' && this.bytesExpected != -1 && this.bytesReceived != this.bytesExpected ){
			this.emit('error', this.createBadSizeError(this.bytesReceived, this.bytesExpected));
		}
		else if( this.hash && this.digest != this.hash.digest() ){
			this.emit('error', this.createBadDigestError(this.hash.digest(), this.digest));
		}
	},

	setEncoding: function(encoding){
		this.encoding = encoding;
		this.chain(this.decoders[encoding].call(this));
	},

	setCharset: function(charset){
		this.charset = charset;
		this.chain(this.converters[charset].call(this));
	},

	setBytesExpected: function(bytesExpected){
		this.bytesExpected = bytesExpected;

		if( typeof bytesExpected === 'number'&& typeof this.bytesLimit === 'number' && bytesExpected > this.bytesLimit ){
			throw this.createTooLargeError(bytesExpected, this.bytesLimit);
		}
	},

	setBytesLimit: function(bytesLimit){
		this.bytesLimit = bytesLimit;
	},

	setHash: function(hash, digest){
		this.hash = hash;
		this.digest = digest;
	}
});

module.exports = BodyReadStream;