var proto = require('proto');

var Negotiator = require('negotiator');
var RequestProperties = {
	decoders: require('./decoders'),
	deconverters: require('./deconverters'),
	stream: null,
	defaultEncoding: 'identity',
	defaultCharset: 'utf8',

	cachedNegotiator: null,
	// NOTE: pourquoi je me permet d'imposer contenttype et charset si celui qui fait la requête ne le supporte pas
	// le comportement normal serait plutot de répondre par une erreur: désolé contenttype ou charset pas possible
	// surement parce que si ce n'est pas précisé c'est que donc on peut en théorie tout répondre
	defaultAcceptedContentType: '*/*',
	defaultAcceptedCharset: 'utf8',
	defaultAcceptedLanguage: 'fr',
	defaultAcceptedEncoding: 'identity',

	parseContentType: function(contentType){
		var mediaType = null, charset = null, search = ';charset=', index;

		if( typeof contentType == 'string' ){
			index = contentType.indexOf(search);

			if( index === -1 ){
				search = '; charset=';
				index = contentType.indexOf(search);
			}

			if( index === -1 ){
				mediaType = contentType;
			}
			else{
				mediaType = contentType.slice(0, index);
				charset = contentType.slice(index + search.length);
				if( charset == 'utf-8' ) charset = 'utf8';
			}
		}

		return [mediaType, charset];
	},

	get encoding(){
		if( this.hasHeader('content-encoding') ){
			return this.getHeader('content-encoding');
		}
		return this.defaultEncoding;
	},

	get charset(){
		if( this.hasHeader('content-type') ){
			return this.parseContentType(this.getHeader('content-type'))[1];
		}
		return this.defaultCharset;
	},

	get negotiator(){
		// en tout cas c'est quelque chose utiliser par la réponse et non la requête
		if( this.cachedNegotiator === null ){
			this.cachedNegotiator = new Negotiator({
				headers: {
					'accept': this.getHeader('accept', this.defaultAcceptedContentType),
					'accept-charset': this.getHeader('accept-charset', this.defaultAcceptedCharset),
					'accept-encoding': this.getHeader('accept-encoding', this.defaultAcceptedEncoding),
					'accept-language': this.getHeader('accept-language', this.defaultAcceptedLanguage)
				}
			});
		}
		return this.cachedNegotiator;
	},

	accept: function(name, value){
		if( name == 'contentType' ) name = 'mediaType';
		return Boolean(this.negotiator[name]([value]));
	},

	getPreffereds: function(name){
		if( name == 'contentType' ) name = 'mediaType';
		return this.negotiator[name + 's']();
	},

	createUnsupportedEncodingError: function(encoding){
		var error = new Error();

		error.message = 'Unsupported encoding '+encoding+'. Supported encodings: '+Object.keys(this.decoders);
		error.statusCode = 415;	// unsupported request header
		error.code = 'UNSUPPORTED_ENCODING';

		return error;
	},

	createUnsupportedCharsetError: function(charset){
		var error = new Error();

		error.message = 'Unsupported charset '+charset+' Supported charsets: '+Object.keys(this.deconverters);
		error.statusCode = 415;	// unsupported request header
		error.code = 'UNSUPPORTED_CHARSET';

		return error;
	},

	canDecode: function(encoding){
		return encoding === 'identity' || encoding in this.decoders;
	},

	canDeconvert: function(charset){
		return charset === 'utf8' || charset in this.deconverters;
	},

	initRawStream: function(){
		var rawStream = this.incomingMessage;

		var encoding = this.encoding;
		if( !this.canDecode(encoding) ){
			throw this.createUnsupportedEncodingError(encoding);
		}
		else if( encoding != 'identity' ){
			var decoder = this.decoders[encoding].call(this);
			rawStream = rawStream.pipe(decoder);
		}

		var charset = this.charset;
		if( !this.canDeconvert(charset) ){
			throw this.createUnsupportedCharsetError(charset);
		}
		else if( charset != 'utf8' ){
			var deconverter = this.deconverters[charset].call(this);
			rawStream = rawStream.pipe(deconverter);
		}

		this.stream = rawStream;
	},

	pipe: function(writableStream){
		return this.stream.pipe(writableStream);
	}
};

module.exports = {
	name: 'requestNegotiation',
	request: RequestProperties,

	use: function(router, options){
		if( options ){
			proto.define(router.Request, options);
		}
	},

	handle: function(request, response, handler){
		request.initRawStream();
		handler.next();
	}
};