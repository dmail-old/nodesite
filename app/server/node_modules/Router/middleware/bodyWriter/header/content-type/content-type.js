var ResponseHeader = require('./responseHeader');
var ContentType = ResponseHeader.extend({
	name: 'content-type',
	parsers: require('./parsers'),
	converters: require('./converters'),

	charsetErrorStatusCode: 500,
	charsetErrorMessage: 'Unsupported response header {headerName}:{headerValue}. Charset {charset} not supported, supported charsets: {supporteds}',
	mediaTypeAcceptErrorMessage: 'Not acceptable response header {headerName}:{headerValue}. MediaType {mediaType} is not in accept headers: {accepteds}',
	charsetAcceptErrorMessage: 'Not acceptable response header {headerName}:{headerValue}. Charset {charset} is not in accept headers: {accepteds}',

	isValidCharset: function(charset){
		return charset in this.converters;
	},

	isAcceptedCharset: function(charset){
		return Boolean(this.request.negotiator.charset(charset));
	},

	isAcceptedMediaType: function(mediaType){
		return Boolean(this.request.negotiator.mediaType(mediaType));
	},

	getSupportedCharsets: function(){
		return Object.keys(this.converters);
	},

	getAcceptedMediaTypes: function(){
		return this.request.negotiator.mediaTypes();
	},

	getAcceptedCharsets: function(){
		return this.request.negotiator.charsets();
	},

	createCharsetError: function(){
		return this.createError(this.charsetErrorStatusCode, this.charsetErrorMessage, {
			supporteds: this.getSupportedCharsets()
		});
	},

	createAcceptCharsetError: function(){
		this.acceptErrorMessage = this.charsetAcceptErrorMessage;
		this.getAccepteds = this.getAcceptedCharsets();
		return this.createAcceptError();
	},

	createAcceptMediaTypeError: function(){
		this.acceptErrorMessage = this.mediaTypeAcceptErrorMessage;
		this.getAccepteds = this.getAcceptedMediaTypes();
		return this.createAcceptError();
	},

	valid: function(){
		var parts = this.split(this.value), mediaType = parts[0], charset = parts[1];

		if( charset && this.isTextual(mediaType) ){
			if( !this.isValidCharset(charset) ){
				this.error = this.createCharsetError(charset);
				return false;
			}
			if( !this.isAcceptedCharset(charset) ){
				this.error = this.createAcceptCharsetError(charset);
				return false;
			}
		}

		if( !this.isAcceptedMediaType(mediaType) ){
			this.error = this.createAcceptMediaTypeError(mediaType);
			return false;
		}

		this.error = null;
		return true;
	},

	effect: function(){
		var parts = this.parse(this.value), mediaType = parts[0], charset = parts[1];

		// call parser giving a chance to chance to modify the writing behaviour 
		if( mediaType in this.parsers ){
			this.parsers[mediaType].call(this, mediaType);
		}

		// si charset spécifié par un header, on suppose que body au bon charset
		if( charset && charset != 'utf8' && this.isTextual(mediaType) ){
			this.response.removeHeader('content-length'); // content-length is modified
			this.converters[charset].call(this);
		}
	}
});

module.exports = ContentType;