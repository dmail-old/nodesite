var Handler = require('../handler');
var FileHandler = Handler.extend({
	fileSystem: require('fs'),
	modifiedSinceHeaderName: 'if-modified-since',

	path: null,
	stat: null,
	aliases: [],
	aliasIndex: 0,
	alias: null,

	getModifiedSinceHeader: function(){
		var modified = this.request.getHeader(this.modifiedSinceHeaderName);

		if( typeof modified == 'string' ){
			try{
				modified = new Date(modified);
			}
			catch(e){
				return null;
			}
		}

		return modified;
	},

	isModified: function(mtime){
		var modified = this.getModifiedSinceHeader();

		if( modified ){
			return mtime > modified;
		}

		return true;
	},

	isNotFoundError: function(error){
		return error.code == 'ENOENT' && error.errno == 34;
	},

	onstat: function(error, stat){
		// if the alias doesn't exists, try to send an other alias else the file
		if( this.alias ){
			if( error ){
				if( this.isNotFoundError(error) ){
					this.path = this.originalPath;
					this.sendAliasElseFile();
					return;
				}
			}
			else{
				this.alias.found();
			}
		}

		// erreur pendant la récupération de infos du fichier
		if( error ){
			if( this.isNotFoundError(error) ){
				return this.respond(404);
			}
			else{
				return this.error(error);
			}
		}
		// seul les fichiers sont autorisé
		if( !stat.isFile() ) return this.respond(403);
		// dit au navigateur que le fichier n'a pas changé
		if( !this.isModified(stat.mtime) ) return this.respond(304);

		this.respond({
			statusCode: 200,
			headers: {
				'content-type': config.getMimetype(this.originalPath),
				'last-modified': stat.mtime,
				'content-length': stat.size,
				// évite que chrome mette en cache et réutilise sans redemander au serveur les fichier HTML qu'on lui envoit
				'cache-control': 'no-cache'
			},
			body: this.fileSystem.createReadStream(this.path),
			// dont log body for files
			options: {
				logBody: false
			}
		});
	},

	getFileStat: function(){
		this.fileSystem.stat(this.path, this.onstat.bind(this));
	},

	nextAlias: function(){
		var aliases = this.aliases;

		if( aliases.length === 0 ) return null;
		if( this.aliasIndex >= aliases.length ) return null;
		return aliases[this.aliasIndex++].new(this);
	},

	nextPossibleAlias: function(){
		var alias;

		while( (alias = this.nextAlias()) && alias.handle() );

		return alias;
	},

	sendAliasElseFile: function(){
		this.path = this.originalPath;
		this.alias = this.nextPossibleAlias();
		if( this.alias ){
			this.path = this.alias.getPath(this.path);
		}
		this.getFileStat();
	},

	send: function(path){
		this.path = this.originalPath = path;
		this.sendAliasElseFile();
	},

	// this here is router not FileHandler
	handle: function(router){
		if( router.request.is('head', 'get') ){
			router.response.sendFile(global.CLIENT_PATH + router.request.url.pathname);
		}
		else{
			router.next();
		}
	}
});

//FileHandler.aliases.push(require('./gzipAlias'));

FileHandler.response = {
	sendFile: function(path){
		return FileHandler.new(this.router).send(path);
	}
};

module.exports = FileHandler;