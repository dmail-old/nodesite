var File = {
	fileSystem: require('fs'),
	_modified: null,
	path: null,
	stat: null,
	aliases: [],
	aliasIndex: 0,
	alias: null,

	init: function(path, modified){
		this.path = this.originalPath = path;
		this.modified = modified;
	},

	set modified(value){
		if( typeof value == 'string' ){
			try{
				value = new Date(value);
			}
			catch(e){
				value = null;
			}
		}

		this._modified = value;
	},

	get modified(){
		return this._modified;
	},

	isModified: function(mtime){
		var modified = this.modified;

		if( modified ){
			return mtime > modified;
		}
		return true;
	},

	isNotFoundError: function(error){
		return error.code == 'ENOENT' && error.errno == 34;
	},

	onstat: function(error, stat){
		// if the alias doesn't exists, try to send an other alias else the file
		if( this.alias ){
			if( error ){
				if( this.isNotFoundError(error) ){
					this.path = this.originalPath;
					this.sendAliasElseFile();
					return;
				}
			}
			else{
				this.alias.found();
			}
		}

		// erreur pendant la récupération de infos du fichier
		if( error ){
			if( this.isNotFoundError(error) ){
				return this.send(404);
			}
			else{
				return this.send(error);
			}
		}
		// seul les fichiers sont autorisé
		if( !stat.isFile() ) return this.send(403);
		// dit au navigateur que le fichier n'a pas changé
		if( !this.isModified(stat.mtime) ) return this.send(304);

		this.send({
			statusCode: 200,
			headers: {
				'content-type': config.getMimetype(this.originalPath),
				'last-modified': stat.mtime,
				'content-length': stat.size,
				// évite que chrome mette en cache et réutilise sans redemander au serveur les fichier HTML qu'on lui envoit
				'cache-control': 'no-cache'
			},
			body: this.fileSystem.createReadStream(this.path),
			// dont log body for files
			options: {
				logBody: false
			}
		});
	},

	getFileStat: function(){
		this.fileSystem.stat(this.path, this.onstat.bind(this));
	},

	nextAlias: function(){
		var aliases = this.aliases;

		if( aliases.length === 0 ) return null;
		if( this.aliasIndex >= aliases.length ) return null;
		return aliases[this.aliasIndex++].new(this);
	},

	nextPossibleAlias: function(){
		var alias;

		while( (alias = this.nextAlias()) && alias.handle() );

		return alias;
	},

	sendAliasElseFile: function(){
		this.path = this.originalPath;
		this.alias = this.nextPossibleAlias();
		if( this.alias ){
			this.path = this.alias.getPath(this.path);
		}
		this.getFileStat();
	},

	send: function(data){
		this.callback.call(this, data);
	},

	generate: function(callback){
		this.callback = callback;
		this.sendAliasElseFile();
	}
};

module.exports = File;