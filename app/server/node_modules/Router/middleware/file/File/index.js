var proto = require('proto');
var Path = require('path');
var File = proto.create({
	fileSystem: require('fs'),
	path: null,
	modifiedSince: null,
	acceptGzip: null,
	stat: null,
	aliases: [],
	aliasIndex: 0,
	alias: null,
	callback: null,
	bind: null,

	constructor: function(path){
		this.path = this.originalPath = Path.normalize(path);
		this.result = {};
	},

	isModified: function(mtime){
		return this.modifiedSince ? mtime > this.modifiedSince : true;
	},

	isNotFoundError: function(error){
		return error.code == 'ENOENT' && error.errno == 34;
	},

	onstat: function(error, stat){
		// if the alias doesn't exists, try to send an other alias else the file
		if( this.alias ){
			if( error ){
				if( this.isNotFoundError(error) ){
					this.path = this.originalPath;
					this.sendAliasElseFile();
					return;
				}
			}
			else{
				this.alias.found();
			}
		}

		// erreur pendant la récupération de infos du fichier
		if( error ){
			if( this.isNotFoundError(error) ){
				return this.send(404);
			}
			else{
				return this.send(error);
			}
		}
		// seul les fichiers sont autorisé
		if( !stat.isFile() ) return this.send(403);
		// dit au navigateur que le fichier n'a pas changé
		if( !this.isModified(stat.mtime) ) return this.send(304);

		this.send({
			statusCode: 200,
			headers: {
				'content-type': config.getMimetype(this.originalPath),
				'last-modified': stat.mtime,
				'content-length': stat.size,
				// évite que chrome mette en cache et réutilise sans redemander au serveur
				// les fichier HTML qu'on lui envoit
				'cache-control': 'no-cache'
			},
			body: require('fs').createReadStream(this.path), //this.fileSystem.createReadStream(this.path),
			// dont log body for files
			logBody: !false
		});
	},

	getFileStat: function(){
		this.fileSystem.stat(this.path, this.onstat.bind(this));
	},

	nextAlias: function(){
		var aliases = this.aliases;

		if( aliases.length === 0 ) return null;
		if( this.aliasIndex >= aliases.length ) return null;
		return aliases[this.aliasIndex++].new(this);
	},

	nextPossibleAlias: function(){
		var alias;

		while( (alias = this.nextAlias()) && alias.handle() );

		return alias;
	},

	sendAliasElseFile: function(){
		this.path = this.originalPath;
		this.alias = this.nextPossibleAlias();
		if( this.alias ){
			this.path = this.alias.getPath(this.path);
		}
		this.getFileStat();
	},

	send: function(data){
		if( data instanceof Error ){
			this.error = data;
		}
		else{
			this.result = data;
		}

		this.callback.call(this.bind, this.error, this.result);
	},

	generate: function(callback, bind){
		this.callback = callback;
		this.bind = bind;
		this.sendAliasElseFile();
	}
});

module.exports = File;