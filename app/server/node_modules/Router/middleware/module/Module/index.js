/*
TODO : ADD PATHS TO LOOK INTO TO MAKE SOME MODULE ACCESSIBLE TO THE CLIENT
module will need a way to differentiate where file resides and where the client thinks it resides
*/

var proto = require('proto');
var Module = proto.create({
	ModuleResolver: require('../ModuleResolver'),
	clientFolder: null,
	cache: {},
	resolvedPaths : null,
	meta: null, // data from package.json file

	constructor: function(filename, parent){
		filename = this.ModuleResolver.prototype.resolvePath(filename);

		if( filename in this.cache ){
			return this.cache[filename];
		}
		
		this.cache[filename] = this;
		this.filename = filename;
		this.parent = parent;
		this.resolvedPaths = {};
		this.children = [];

		if( parent ){
			parent.children.push(module);
		}
	},

	createChild: function(filename){
		return Module.new(filename, this);
	},

	isClientReadable: function(){
		if( this.clientFolder && this.filename.startsWith(this.clientFolder) ) return true;
		if( this.meta && this.meta.clientReadable === true ) return true;
		return false;
	},

	resolve: function(path, fn, bind){
		if( path in this.resolvedPaths ){
			process.nextTick(function(){
				fn.call(bind, null, this.resolvedPaths[path]);
			}.bind(this));
		}
		else{
			var resolver = this.ModuleResolver.new(this.filename, path);

			resolver.resolve(function(error, filename){
				if( error ){
					fn.call(bind, error);
				}
				else if( filename ){
					this.meta = resolver.packageBody;
					// make filename relative to the root path
					filename = resolver.relativePath(filename);

					this.resolvedPaths[path] = filename;
					this.createChild(filename);
					fn.call(bind, filename);
				}
				else{					
					fn.call(bind, new Error('not found'));
				}
			}.bind(this));
		}
	},

	toJSON: function(){
		return {
			filename: this.filename,
			resolvedPaths: this.resolvedPaths,
			children: this.children
		};
	}
});

module.exports = Module;
