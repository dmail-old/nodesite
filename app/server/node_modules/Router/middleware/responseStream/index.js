/*

Reste à faire le remplissage auto des headers
pour content-language, content-encoding, content-type
la mécanique de quand et comment on les remplis et puis ca seras bon en théorie

wrap avec auto content-length à vérifier selon quand j'apelle wrap à mon avis ça chier

bodyWriter et bodyReader sont trop lier à request et response alors qu'il devrait être indépendant
on doit pouvoir utiliser ces streams en dehors 

-> plus souple mais surtout rendras tout ça plus clair

*/

var ResponseProperties = {	
	defaultMediaType: 'text/plain',
	defaultCharset: 'utf8',
	defaultEncoding: 'identity',
	Stream: require('ChangeStream'),
	stream: null,

	autoEnd: true, // call end() when populate() is called

	populate: function(data){
		if( data ){
			if( typeof data == 'number' ){
				data = {
					statusCode: data,
					body: this.getStatusDescription(data)
				};
			}

			// je serais bien tenté ici de faire plutot un merge
			// Object.merge(this, data);
			if( data.headers ){
				Object.append(this.headers, data.headers);
			}
			if( data.statusCode ){
				this.statusCode = data.statusCode;
			}
			if( data.options ){
				Object.append(this, data.options);
			}
			if( data.body ){
				this.body = data.body;
			}
		}

		if( this.autoEnd ){
			this.end();
		}
	},

	send: function(){
		if( arguments.length == 1 ){
			if( typeof arguments[0] == 'number' ){
				this.populate(arguments[0]);
			}
			else{
				this.populate({
					body: arguments[0]
				});
			}
		}
		else if( arguments.length === 2 ){
			this.populate({
				statusCode: arguments[0],
				body: arguments[1]
			});
		}
		else{
			this.populate();
		}	
	},

	populateHeaders: function(){
		// status code 204 et 304 pas besoin de certain headers (not modified and no content)
		// https://github.com/mcavage/node-restify/blob/master/lib/response.js#L268
		var contentType, type, charset, parts;

		if( this.hasHeader('content-type') ){
			contentType = this.getHeader('content-type');
		}
		else{
			contentType = this.getDefault('content-type');
		}

		parts = this.ContentType.parse(contentType);

		this.type = parts[0];
		this.charset = this.ContentType.isTextual(this.type) ? parts[1] : null;

		if( this.charset ){
			if( this.hasHeader('content-language') ){
				this.language = this.getHeader('content-language');
			}
			else{
				// TODO, auto language
			}
		}

		if( this.hasHeader('content-encoding') ){
			this.encoding = this.getHeader('content-encoding');
		}
		else{
			// TODO, auto encoding
		}		
	},

	getDefault: function(headerName){
		var accepteds = this.getAccepteds(headerName), i = 0, j = accepteds.length, value;

		for(;i<j;i++){
			value = accepteds[i];
			if( this.isValidHeader(headerName, value) ){
				return value;
			}
		}

		return this.getDefault(headerName);
	},

	validHeaders: function(){
		if( !this.request.accept('mediaType', this.type) ){
			this.headerError = this.createHeaderAcceptError('type', this.type);
			return false;
		}

		if( this.charset ){
			if( !this.validHeader('charset', this.charset) ){
				this.headerError = this.createHeaderValueError('charset', this.charset);
				return false;
			}
			if( !this.request.accept('charset', this.charset) ){
				this.headerError = this.createHeaderAcceptError('charset', this.charset);
				return false;
			}
		}

		if( this.encoding ){
			if( !this.validHeader('encoding', this.encoding) ){
				this.headerError = this.createHeaderValueError('encoding', this.encoding);
				return false;
			}
			if( !this.request.accept('encoding', this.encoding) ){
				this.headerError = this.createHeaderAcceptError('encoding', this.encoding);
				return false;
			}
		}

		return true;
	},

	get length(){
		return parseInt(this.getHeader('content-length'));
	},

	set length(length){
		this.setHeader('content-length', length);
	},

	// là c'est carrément du délire aucune idée de comment je vais pouvoir faire
	format: function(buffer){
		return buffer;
	},

	stringifyObject: function(object){
		return JSON.stringify(object);
	},

	computeLength: function(body){
		return typeof body == 'string' ? Buffer.byteLength(body) : body.length;
	},
	
	writeBody: function(body){
		var stream = this.stream;

		if( Stream.isStream(body) ){
			// true force body to be the first stream of computedStream
			stream.chain(body, true);
		}
		else if( Buffer.isBuffer(body) ){
			stream.write(body);
			this.length = this.computeLength(body);
		}	
		else if( typeof body == 'string' ){
			stream.write(body);
			this.length = this.computeLength(body);
		}			
		else if( typeof body == 'object' ){
			if( body === null || body.toString !== Object.prototype.toString ){
				body = String(body);
			}
			else{
				try{
					body = this.stringifyObject(body);
				}
				catch(e){
					return this.error(e);
				}
			}
			stream.write(body);
			this.length = this.computeLength(body);
		}
	},

	prepareBody: function(done){
		// valid headers
		var error;
		this.headers.some(function(header){
			if( !header.valid() ){
				error = header.error;
				return true;
			}
		});
		if( error ) return this.error(error);

		// active headers effect
		this.headers.forEach(function(header){ header.effect(); });

		this.writeBody(this.body);
		this.body = this.stream;
		this.stream.resolve();

		done();
	},

	wrap: function(prefix, suffix){
		if( this.wrapped ) throw new Error('wrap can only be called once');
		this.wrapped = true;
		this.prefix = prefix;
		this.suffix = suffix;

		var stream = this.stream, self = this, write, end;		

		// first stream.write() will write prefix before data
		write = stream.write;
		stream.write = function(){
			this.write = write;
			this.write(prefix);
			return this.write.apply(this, arguments);
		};
		
		// first stream.end() will write suffix before ending stream
		end = stream.end;
		stream.end = function(chunk, encoding, callback){
			this.end = end;
			if( arguments.length > 0 ) this.write(chunk);
			return this.end(suffix, encoding, callback);
		};

		var setHeader = this.setHeader;
		this.setHeader = function(name, value){
			if( name == 'content-length' ){
				value+= self.getLength(prefix);
				value+= self.getLength(suffix);
				this.setHeader = setHeader;
			}
			return this.setHeader.apply(this, arguments);
		};
	}
};

module.exports = {
	response: ResponseProperties,

	handle: function(){
		this.response.stream = this.Stream.new();
		this.response.stream.on('error', this.error.bind(this));
	}
};