/*

Reste à faire le remplissage auto des headers
pour content-language, content-encoding, content-type
la mécanique de quand et comment on les remplis et puis ca seras bon en théorie

wrap avec auto content-length à vérifier selon quand j'apelle wrap à mon avis ça chier

response.forceEncoding = 'gzip'; // force la réponse à être en gzip, si le client supporte pas -> erreur
response.autoEncoding = true|false; // si la requête le peut on essaye d'encoder la réponse comme le préfère le client
// parmi les encodings supporté

response.forceCharset = '';
response.autoCharset = true|false;

response.forceLanguage = '';
response.autoLanguage = 

response.forceLength = '';
response.autoLength = true|false

response.

*/

var ResponseProperties = {
	defaultMediaType: 'text/plain',
	defaultCharset: 'utf8',
	defaultEncoding: 'identity',
	defaultLanguage: 'en',
	negotiateMediaType: false, // voir comment on peut faire
	negotiateCharset: true, // mais tfaçon j'en supporte aucun autre que utf8
	negotiateEncoding: false,
	negotiateLanguage: true,	

	Stream: require('ChangeStream'),
	stream: null,

	autoEnd: true, // call end() when populate() is called

	populate: function(data){
		if( data ){
			if( typeof data == 'number' ){
				data = {
					statusCode: data,
					body: this.getStatusDescription(data)
				};
			}

			// je serais bien tenté ici de faire plutot un merge
			// Object.merge(this, data);
			if( data.headers ){
				Object.append(this.headers, data.headers);
			}
			if( data.statusCode ){
				this.statusCode = data.statusCode;
			}
			if( data.options ){
				Object.append(this, data.options);
			}
			if( data.body ){
				this.body = data.body;
			}
		}

		if( this.autoEnd ){
			this.end();
		}
	},

	send: function(){
		if( arguments.length == 1 ){
			if( typeof arguments[0] == 'number' ){
				this.populate(arguments[0]);
			}
			else{
				this.populate({
					body: arguments[0]
				});
			}
		}
		else if( arguments.length === 2 ){
			this.populate({
				statusCode: arguments[0],
				body: arguments[1]
			});
		}
		else{
			this.populate();
		}	
	},

	get length(){
		return parseInt(this.getHeader('content-length'), 10);
	},

	set length(length){
		this.setHeader('content-length', length);
	},

	get mediaType(){
		if( this.hasHeader('content-type') ){
			return this.request.parseContentType(this.getHeader('content-type'))[0];
		}
		return this.defaultMediaType;
	},

	set mediaType(mediaType){
		this.setHeader('content-type', mediaType + ';charset=' + this.charset);
	},

	get charset(){
		if( this.hasHeader('content-type') ){
			return this.request.parseContentType(this.getHeader('content-type'))[1];
		}
		return this.defaultCharset;
	},

	set charset(charset){
		this.setHeader('content-type', this.mediaType + ';charset=' + charset);
	},

	populateHeaders: function(){
		// status code 204 et 304 pas besoin de certain headers (not modified and no content)
		// https://github.com/mcavage/node-restify/blob/master/lib/response.js#L268
		var contentType, type, charset, parts;

		if( this.charset ){
			if( this.hasHeader('content-language') ){
				this.language = this.getHeader('content-language');
			}
			else{
				// TODO, auto language
			}
		}

		if( this.hasHeader('content-encoding') ){
			this.encoding = this.getHeader('content-encoding');
		}
		else{
			// TODO, auto encoding
		}		
	},

	validHeaders: function(){
		var mediaType = this.mediaType;
		if( mediaType ){
			if( false === this.request.accept('mediaType', mediaType) ){
				this.headerError = this.createUnacceptedError('type', mediaType);
				return false;
			}
		}

		var charset = this.charset;
		if( charset ){
			if( false === this.stream.canConvert(charset) ){
				this.headerError = this.createUnsupportedError('charset', charset);
				return false;
			}
			if( false === this.request.accept('charset', charset) ){
				this.headerError = this.createUnacceptedError('charset', charset);
				return false;
			}
		}

		var encoding = this.encoding;
		if( encoding ){
			if( false === this.stream.canEncode(encoding) ){
				this.headerError = this.createUnsupportedError('encoding', encoding);
				return false;
			}
			if( false === this.request.accept('encoding', encoding) ){
				this.headerError = this.createUnacceptedError('encoding', encoding);
				return false;
			}
		}

		return true;
	},

	// là c'est carrément du délire aucune idée de comment je vais pouvoir faire
	format: function(buffer){
		return buffer;
	},

	stringifyObject: function(object){
		return JSON.stringify(object);
	},
	
	writeBody: function(body){
		var stream = this.stream;

		if( global.Stream.isStream(body) ){
			// true force body to be the first stream of computedStream
			stream.chain(body, true);
		}
		else if( Buffer.isBuffer(body) ){
			stream.write(body);
			this.length = body.length;
		}
		else if( typeof body == 'string' ){
			stream.write(body);
			this.length = Buffer.byteLength(body);
		}			
		else if( typeof body == 'object' ){
			// pourquoi pas toSource?
			if( body === null || body.toString !== Object.prototype.toString ){
				body = String(body);
			}
			else{
				try{
					body = this.stringifyObject(body);
				}
				catch(e){
					return this.error(e);
				}
			}
			stream.write(body);
			this.length = Buffer.byteLength(body);
		}
	},

	prepareBody: function(done){
		// tout ceci à des conséquence sur body puisque selon le language je changerais ptet ce que j'envoie
		// selon le charset stream.outputCharset est pas pareil
		// encoding pareil
		// mediaType change aussi comment body s'écrit

		if( !this.hasHeader('content-type') && this.negotiateMediaType ){
			//this.mediaType = ;
		}

		if( !this.hasHeader('content-language') && this.negotiateLanguage ){
			//this.language = ;
		}

		if( !this.hasHeader('content-type') && this.negotiateCharset ){
			//this.charset = ;
		}		

		if( !this.hasHeader('content-encoding') && this.negotiateEncoding ){
			//this.encoding = ;
		}

		if( this.validHeaders() ){
			this.writeBody(this.body);
			this.body = this.stream;
		}
		else{

		}		

		done();
	},

	wrap: function(prefix, suffix){
		if( this.wrapped ) throw new Error('wrap can only be called once');
		this.wrapped = true;
		this.prefix = prefix;
		this.suffix = suffix;

		var stream = this.stream, self = this, write, end;		

		// first stream.write() will write prefix before data
		write = stream.write;
		stream.write = function(){
			this.write = write;
			this.write(prefix);
			return this.write.apply(this, arguments);
		};
		
		// first stream.end() will write suffix before ending stream
		end = stream.end;
		stream.end = function(chunk, encoding, callback){
			this.end = end;
			if( arguments.length > 0 ) this.write(chunk);
			return this.end(suffix, encoding, callback);
		};

		var setHeader = this.setHeader;
		this.setHeader = function(name, value){
			if( name == 'content-length' ){
				value+= self.computeLength(prefix);
				value+= self.computeLength(suffix);
				this.setHeader = setHeader;
			}
			return this.setHeader.apply(this, arguments);
		};
	}
};

module.exports = {
	response: ResponseProperties,

	handle: function(router){
		router.response.stream = router.Stream.new();
		router.response.stream.on('error', router.error.bind(router));
	}
};