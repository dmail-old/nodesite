/*

*/

var ResponseProperties = {
	defaultMediaType: 'text/plain',
	defaultCharset: 'utf8', // by default data are considered using utf8 charset
	defaultEncoding: 'identity',  // by default data are considered not encoded
	defaultLanguage: 'en',
	negotiateMediaType: false, // voir comment on peut faire
	negotiateCharset: true, // mais tfaçon j'en supporte aucun autre que utf8
	negotiateEncoding: false,
	negotiateLanguage: true,

	Stream: require('ProcessedStream'),
	stream: null,

	bodyCharset: 'utf8',
	bodyEncoding: 'identity',

	autoLength: true, // computeLength from streams
	autoMD5: false,
	autoEnd: true, // call end() when populate() is called

	get encoding(){
		return this.getHeader('content-encoding') || this.defaultEncoding;
	},

	set encoding(encoding){
		this.setHeader('content-encoding', encoding);
	},

	get md5(){
		return this.getHeader('content-md5');
	},

	set md5(md5){
		this.setHeader('content-md5', md5);
	},

	get mediaType(){
		if( this.hasHeader('content-type') ){
			return this.request.parseContentType(this.getHeader('content-type'))[0];
		}
		return this.defaultMediaType;
	},

	set mediaType(mediaType){
		this.setHeader('content-type', mediaType + ';charset=' + this.charset);
	},

	get charset(){
		if( this.hasHeader('content-type') ){
			return this.request.parseContentType(this.getHeader('content-type'))[1];
		}
		return this.defaultCharset;
	},

	set charset(charset){
		this.setHeader('content-type', this.mediaType + ';charset=' + charset);
	},

	populate: function(data){
		if( data ){
			if( typeof data == 'number' ){
				data = {
					statusCode: data,
					body: this.getStatusDescription(data)
				};
			}

			// je serais bien tenté ici de faire plutot un merge
			// Object.merge(this, data);
			if( data.headers ){
				Object.append(this.headers, data.headers);
			}
			if( data.statusCode ){
				this.statusCode = data.statusCode;
			}
			if( data.options ){
				Object.append(this, data.options);
			}
			if( data.body ){
				this.body = data.body;
			}
		}

		if( this.autoEnd ){
			this.end();
		}
	},

	send: function(){
		if( arguments.length == 1 ){
			if( typeof arguments[0] == 'number' ){
				this.populate(arguments[0]);
			}
			else{
				this.populate({
					body: arguments[0]
				});
			}
		}
		else if( arguments.length === 2 ){
			this.populate({
				statusCode: arguments[0],
				body: arguments[1]
			});
		}
		else{
			this.populate();
		}	
	},

	populateHeaders: function(){
		// status code 204 et 304 pas besoin de certain headers (not modified and no content)
		// https://github.com/mcavage/node-restify/blob/master/lib/response.js#L268
		var contentType, type, charset, parts;

		if( this.charset ){
			if( this.hasHeader('content-language') ){
				this.language = this.getHeader('content-language');
			}
			else{
				// TODO, auto language
			}
		}

		if( this.hasHeader('content-encoding') ){
			this.encoding = this.getHeader('content-encoding');
		}
		else{
			// TODO, auto encoding
		}		
	},

	createUnacceptedError: function(){

	},

	createUnsupportedError: function(){

	},
	// là c'est carrément du délire aucune idée de comment je vais pouvoir faire
	format: function(buffer){
		return buffer;
	},

	// etagify: https://hacks.mozilla.org/2013/02/fantastic-front-end-performance-in-node-part-2-a-node-js-holiday-season-part-6/
	generateMD5: function(fn, bind){
		bind = bind || this;
		var stream = this.stream, hash = require('crypto').createHash('md5');

		stream.on('data', function(chunk){
			hash.update(chunk);
		});
		stream.on('end', function(){
			fn.call(bind, hash.digest('base64'));
		});		
	},

	generateLength: function(fn, bind){
		bind = bind || this;
		var stream = this.stream, length = 0;

		stream.on('data', function(chunk, encoding){
			length+= Buffer.isBuffer(chunk) ? chunk.length : Buffer.byteLength(chunk, encoding);
		});
		stream.on('end', function(){
			fn.call(bind, length);
		});
	},
	
	write: function(chunk, encoding){
		var stream = this.stream;

		if( global.Stream.isStream(chunk) ){
			// dont call end on response, end is automatically called
			return chunk.pipe(stream, {end: false});
		}
		else{
			// pourquoi pas toSource?
			if( chunk === null || chunk.toString !== Object.prototype.toString ){
				chunk = String(chunk);
			}
			else{
				try{
					chunk = this.stringifyObject(chunk);
				}
				catch(e){
					return this.emit('error', e);
				}
			}

			return stream.write(chunk, encoding);
		}
	},

	validHeaders: function(){
		var request = this.request, stream = this.stream, mediaType, charset, encoding;

		mediaType = this.mediaType;
		if( mediaType ){
			if( false === request.accept('mediaType', mediaType) ){
				this.headerError = this.createUnacceptedError('type', mediaType);
				return false;
			}
		}

		charset = this.charset;
		if( charset ){
			if( false === stream.supportCharset(charset) ){
				this.headerError = this.createUnsupportedError('charset', charset);
				return false;
			}
			stream.charset = charset;
			if( charset != this.charset ) this.removeHeader('content-length');

			if( false === request.accept('charset', charset) ){
				this.headerError = this.createUnacceptedError('charset', charset);
				return false;
			}
		}

		encoding = this.encoding;
		if( encoding ){
			if( false === stream.supportEncoding(encoding) ){
				this.headerError = this.createUnsupportedError('encoding', encoding);
				return false;
			}
			stream.encoding = encoding;
			if( encoding != this.encoding ) this.removeHeader('content-length');

			if( false === request.accept('encoding', encoding) ){
				this.headerError = this.createUnacceptedError('encoding', encoding);
				return false;
			}
		}

		return true;
	},

	prepareHeaders: function(done){
		if( !this.hasOwnProperty('body') ) done();

		if( false === this.hasHeader('content-language') && this.negotiateLanguage ){
			//this.language = ;
		}

		if( false === this.hasHeader('content-type') && this.negotiateMediaType ){
			//this.mediaType = ;
		}

		if( false === this.hasHeader('content-type') && this.negotiateCharset ){
			//this.charset = ;
		}

		if( false === this.hasHeader('content-encoding') && this.negotiateEncoding ){
			//this.encoding = ;
		}

		if( false === this.validHeaders() ){
			this.error(this.headerError);
			return;
		}
		
		this.write(this.body);
		this.body = this.stream;

		if( false === this.hasHeader('content-length') && this.autoLength ){
			this.wait(function(done){
				this.generateLength(function(length){
					this.length+= length;
					done();
				});
			});
		}

		if( false === this.hasHeader('content-md5') && this.autoMD5 ){
			this.wait(function(done){
				this.generateMD5(function(md5){
					this.setHeader('content-md5', md5);
					done();
				});
			});
		}

		done();
	},

	wrap: function(prefix, suffix){
		if( this.wrapped ) throw new Error('wrap can only be called once');
		this.wrapped = true;
		this.prefix = prefix;
		this.suffix = suffix;

		var stream = this.stream, write, end, setHeader;

		// first stream.write() will write prefix before data
		write = stream.write;
		stream.write = function(){
			this.write = write;
			this.write(prefix);
			return this.write.apply(this, arguments);
		};
		
		// first stream.end() will write suffix before ending stream
		end = stream.end;
		stream.end = function(chunk, encoding, callback){
			this.end = end;
			if( arguments.length > 0 ) this.write(chunk);
			return this.end(suffix, encoding, callback);
		};

		setHeader = this.setHeader;
		this.setHeader = function(name, value){
			if( name == 'content-length' ){
				value+= this.computeLength(prefix);
				value+= this.computeLength(suffix);
				this.setHeader = setHeader;
			}
			return this.setHeader.apply(this, arguments);
		};
	}
};

module.exports = {
	response: ResponseProperties,

	handle: function(router){
		router.response.stream = router.Stream.new();
		router.response.stream.on('error', router.error.bind(router));
	}
};