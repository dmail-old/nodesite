/*
on va utiliser tabletemplate
*/

var StringTemplate = require('StringTemplate');
var ConsoleTemplate = require('LogStream/Log/ConsoleTemplate');
var TableTemplate = require('TableTemplate');

module.exports = {
	name: 'logger',

	request: {
		stringTemplate: '{method} {url} HTTP/{httpVersion}\n{headers}',

		get stringScope(){
			/*
			var headerTemplate = ConsoleTemplate.new('{key}: {value}');
			var headerString = headerTemplate.repeat(this.headers, '\n', function(headerValue, headerName){
				return {
					key: headerName,
					value: headerValue
				};
			});*/

			var table = new TableTemplate();

			table.addRows(Object.keys(this.headers).map(function(name){
				return [name, this.headers[name]];
			}, this));
			table.className = 'headless';
			table.cellStyle.minWidth = 20;
			table.defineClass('headerName', ['bold', 'grey']);
			//table.column(0).set('width', 20);
			table.column(0).setClass('headerName');

			//args: request.args ? ' ' + request.args : '',
			// request.method
			// user: request.user ? request.user.name : 'Anonymous',

			return {
				method: this.method,
				url: String(this.url),
				httpVersion: this.httpVersion,
				headers: table.toString()
			};
		},

		toString: function(){
			return ConsoleTemplate.new(this.stringTemplate).render(this.stringScope);
		}
	},

	response: {
		logBody: true,
		stringTemplate: '{statusCode} {statusMessage} {url} HTTP/1.1\n{headers}{body}',

		get stringScope(){
			var headerString = '';

			/*
			faudrais récup les vrais headers depuis cette chaine
			if( this.serverResponse._headerSent ){
				headerString = this.serverResponse._header;
				// remove first line statusCode + statusMessage + HTTP/1.1
				headerString = headerString.slice(headerString.indexOf('\n')+1);
				headerString = headerString.slice(0, -4); // header ends with \n\n I remove them
			}
			*/


			/*
			var headerTemplate = ConsoleTemplate.new('{key}: {value}');
			headerString = headerTemplate.repeat(this.headers, '\n', function(headerValue, headerName){
				return {
					key: headerName,
					value: headerValue
				};
			});
			*/

			var table = new TableTemplate();

			table.addRows(Object.keys(this.headers).map(function(name){
				return [name, this.headers[name]];
			}, this));
			table.style.width = 'auto';
			table.className = 'human';
			table.cellStyle.minWidth = 20;
			table.defineClass('headerName', ['bold', 'grey']);
			//table.column(0).set('width', 20);
			table.column(0).setClass('headerName');

			headerString = table.toString();

			//'{user} {status} {url} {time}ms {body}''

			var body = this.logBody ? Buffer.concat(this.buffers) : 'body hidden';

			if( this.bodyLogLengthExceeded ) body+= '...';

			return {
				statusCode: this.statusCode,
				statusMessage: require('http').STATUS_CODES[this.statusCode] || 'unknown',
				url: this.request.url.pathname,
				body: body.length ? '\n' + body : '',
				headers: headerString
			};
		},

		getStatusStyle: function(){
			var status = this.statusCode;

			if( status >= 500 ){
				return 'red';
			}
			if( status >= 400 ){
				return 'yellow';
			}
			if( status >= 300 ){
				return 'cyan';
			}
			if( status >= 200 ){
				return 'green';
			}
			return 'inherit';
		}
	},

	handle: function(request, response, handler){
		var logger = handler.router.logger;

		logger.log(request.stringTemplate, request.stringScope, {
			method : 'magenta'
		});

		var startTime = new Date().getTime();

		var length = 0;
		response.buffers = [];
		response.stream.on('data', function(chunk, encoding){
			if( response.logBody && !response.bodyLogLengthExceeded ){
				if( typeof chunk == 'string' ){
					chunk = new Buffer(chunk, encoding);
				}

				var chunkLength = chunk.length;

				if( typeof response.bodyLogMaxLength === 'number' ){
					var diff = (length + chunkLength) - response.bodyLogMaxLength;
					if( diff > 0 ){
						chunk = chunk.slice(0, chunkLength - diff);
						response.bodyLogLengthExceeded = true;
					}
				}

				response.buffers.push(chunk);
				length+= chunkLength;
			}
		});

		// lorsque la requête est terminée, on la log
		// 'finish' c'est lorsque tout à été écrit (sinon x-response-time serait faussement court)
		response.serverResponse.on('finish', function(){
			logger.log(response.stringTemplate, response.stringScope, {
				statusCode: response.getStatusStyle(),
				time: 'grey',
				body: 'grey'
			});
		});
	},

	use: function(router, logger){
		if( logger ) router.logger = logger;
	}
};