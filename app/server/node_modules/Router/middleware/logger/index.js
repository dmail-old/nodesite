var ansi = require('ansi');
var Logger = {
	logger: console,

	getLogLevel: function(){
		var status = this.statusCode, level;

		if( status >= 500 ){
			level = 'error';
		}
		else if( status >= 400 ){
			level = 'warn';
		}
		else{
			level = 'info';
		}

		return level;	
	}
};

var StringTemplate = require('StringTemplate');
var ConsoleTemplate = require('LogStream/Log/ConsoleTemplate');

module.exports = {
	request: {
		stringTemplate: '{method} {url} HTTP/{httpVersion}\n{headers}',

		get stringScope(){
			var headerTemplate = ConsoleTemplate.new('{key}: {value}');
			var headerString = headerTemplate.repeat(this.headers, '\n', function(headerValue, headerName){
				return {
					key: headerName,
					value: headerValue
				};
			});
			
			//args: request.args ? ' ' + request.args : '',
			// request.method
			// user: request.user ? request.user.name : 'Anonymous',	

			return {
				method: this.method,
				url: this.url,
				httpVersion: this.httpVersion,
				headers: headerString
			};
		},			

		toString: function(){
			return ConsoleTemplate.new(this.stringTemplate).render(this.stringScope);
		}
	},

	response: {
		stringTemplate: '{statusCode} {statusMessage} HTTP/1.1\n{headers}',

		get stringScope(){
			var headerString = '';

			if( this.serverResponse._headerSent ){
				headerString = this.serverResponse._header;
			}
			else{
				var headerTemplate = ConsoleTemplate.new('{key}: {value}');
				headerString = headerTemplate.repeat(this.headers, '\n', function(headerValue, headerName){
					return {
						key: headerName,
						value: headerValue
					};
				});
			}
				

			//'{user} {status} {url} {time}ms {body}''
			// url: request.url.pathname
			// body: response.logBody ? Buffer.concat(buffers) : ''
			// url: request.url.pathname

			return {
				statusCode: this.statusCode,
				statusMessage: require('http').STATUS_CODES[this.statusCode] || 'unknown',
				headers: headerString
			};
		},

		getStatusStyle: function(){
			var status = this.statusCode;

			if( status >= 500 ){
				return 'red';
			}
			if( status >= 400 ){
				return 'yellow';
			}
			if( status >= 300 ){
				return 'cyan';
			}
			if( status >= 200 ){
				return 'green';
			}		
			return 'inherit';
		}
	},

	handle: function(router){
		var response = router.response, request = response.request;
		
		router.logger.log(request.stringTemplate, request.stringScope, {
			method : 'magenta'
		});

		var startTime = new Date().getTime();
		var buffers = [];

		response.on('write', function(chunk, encoding){
			if( response.logBody ){
				if( typeof chunk == 'string' ){
					chunk = new Buffer(chunk, encoding);
				}
				buffers.push(chunk);
			}
		});

		// lorsque la requête est terminée, on la log
		// 'finish' c'est lorsque tout à été écrit (sinon x-response-time serait faussement court)
		response.serverResponse.on('finish', function(){
			
			router.logger.log(response.stringTemplate, response.stringScope, {
				statusCode: response.getStatusStyle(),
				time: 'grey',
				body: 'grey'
			});

		});

		router.next();
	},

	use: function(router, args){
		var logger = args[0];

		if( logger ) router.logger = logger;
	}
};