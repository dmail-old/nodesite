var StringTemplate = require('StringTemplate');
var ConsoleTemplate = require('LogStream/Log/ConsoleTemplate');

module.exports = {
	request: {
		stringTemplate: '{method} {url} HTTP/{httpVersion}\n{headers}',

		get stringScope(){
			var headerTemplate = ConsoleTemplate.new('{key}: {value}');
			var headerString = headerTemplate.repeat(this.headers, '\n', function(headerValue, headerName){
				return {
					key: headerName,
					value: headerValue
				};
			});
			
			//args: request.args ? ' ' + request.args : '',
			// request.method
			// user: request.user ? request.user.name : 'Anonymous',	

			return {
				method: this.method,
				url: String(this.url),
				httpVersion: this.httpVersion,
				headers: headerString
			};
		},			

		toString: function(){
			return ConsoleTemplate.new(this.stringTemplate).render(this.stringScope);
		}
	},

	response: {
		logBody: true,
		stringTemplate: '{statusCode} {statusMessage} {url} HTTP/1.1\n{headers} {body}',

		get stringScope(){
			var headerString = '';

			if( this.serverResponse._headerSent ){
				headerString = this.serverResponse._header;
				// remove first line statusCode + statusMessage + HTTP/1.1
				headerString = headerString.slice(headerString.indexOf('\n')+1);
				headerString = headerString.slice(0, -4); // header ends with \n\n I remove them
			}
			else{
				var headerTemplate = ConsoleTemplate.new('{key}: {value}');
				headerString = headerTemplate.repeat(this.headers, '\n', function(headerValue, headerName){
					return {
						key: headerName,
						value: headerValue
					};
				});
			}

			//'{user} {status} {url} {time}ms {body}''

			return {
				statusCode: this.statusCode,
				statusMessage: require('http').STATUS_CODES[this.statusCode] || 'unknown',
				url: this.request.url.pathname,
				body: this.logBody ? Buffer.concat(this.buffers) : 'body hidden',
				headers: headerString
			};
		},

		getStatusStyle: function(){
			var status = this.statusCode;

			if( status >= 500 ){
				return 'red';
			}
			if( status >= 400 ){
				return 'yellow';
			}
			if( status >= 300 ){
				return 'cyan';
			}
			if( status >= 200 ){
				return 'green';
			}		
			return 'inherit';
		}
	},

	handle: function(request, response, handler){
		var logger = handler.router.logger;

		logger.log(request.stringTemplate, request.stringScope, {
			method : 'magenta'
		});

		var startTime = new Date().getTime();
		

		response.buffers = [];
		response.on('write', function(chunk, encoding){
			if( response.logBody ){
				if( typeof chunk == 'string' ){
					chunk = new Buffer(chunk, encoding);
				}
				this.buffers.push(chunk);
			}
		});

		// lorsque la requête est terminée, on la log
		// 'finish' c'est lorsque tout à été écrit (sinon x-response-time serait faussement court)
		response.serverResponse.on('finish', function(){
			logger.log(response.stringTemplate, response.stringScope, {
				statusCode: response.getStatusStyle(),
				time: 'grey',
				body: 'grey'
			});
		});

		handler.next();
	},

	use: function(router, logger){
		if( logger ) router.logger = logger;
	}
};