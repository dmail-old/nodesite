/*
- auto content-language:
les fichiers non binaire (hormis fichier langue) sont tous en anglais
-> comment le navigateur gère si on précise que c'est des fichiers anglais
pour les réponses genre pages/json etc le language semble approprié par contre mais aucune idée de comment le gérer
pour le moment
-> on désactive le content-language jusqu'à ce qu'on ai à s'en occuper

- auto content-encoding:
pouvoir configurer quand et comment j'encode ce que je réponds
*/

var util = require('Stream-util');

var ResponseProperties = {
	Stream: require('ProcessedStream'),
	cachedStream: null,

	//defaultMediaType: 'text/plain',
	defaultMediaType: 'application/octet-stream', // RFC2616 section 7.2.1
	defaultCharset: 'utf8', // by default data are considered using utf8 charset
	defaultEncoding: 'identity',  // by default data are considered not encoded
	defaultLanguage: 'en',
	negotiateMediaType: false, // voir comment on peut faire
	negotiateCharset: true, // mais tfaçon j'en supporte aucun autre que utf8
	negotiateEncoding: false,
	negotiateLanguage: true,

	bodyCharset: 'utf8',
	bodyEncoding: 'identity',

	get encoding(){
		return this.getHeader('content-encoding') || this.defaultEncoding;
	},

	set encoding(encoding){
		this.setHeader('content-encoding', encoding);
	},

	get mediaType(){
		if( this.hasHeader('content-type') ){
			return this.request.parseContentType(this.getHeader('content-type'))[0];
		}
		return this.defaultMediaType;
	},

	set mediaType(mediaType){
		this.setHeader('content-type', mediaType + ';charset=' + this.charset);
	},

	get charset(){
		if( this.hasHeader('content-type') ){
			return this.request.parseContentType(this.getHeader('content-type'))[1];
		}
		return this.defaultCharset;
	},

	set charset(charset){
		this.setHeader('content-type', this.mediaType + ';charset=' + charset);
	},

	populateContentHeaders: function(){
		// status code 204 et 304 pas besoin de certain headers (not modified and no content)
		// https://github.com/mcavage/node-restify/blob/master/lib/response.js#L268

		if( false === this.hasHeader('content-type') && this.negotiateMediaType ){
			//this.mediaType = ;
		}

		if( false === this.hasHeader('content-type') && this.negotiateCharset ){
			//this.charset = ;
		}

		if( this.charset && false === this.hasHeader('content-language') && this.negotiateLanguage ){
			//this.language = ;
		}

		if( false === this.hasHeader('content-encoding') && this.negotiateEncoding ){
			//this.encoding = ;
		}
	},

	validContentHeaders: function(){
		var request = this.request, mediaType, charset, encoding;

		mediaType = this.mediaType;
		if( mediaType ){
			if( false === request.accept('mediaType', mediaType) ){
				this.headerError = this.createUnacceptedError('type', mediaType);
				return false;
			}
		}

		charset = this.charset;
		if( charset ){
			if( charset != this.charset ) this.removeHeader('content-length');
			if( false === request.accept('charset', charset) ){
				this.headerError = this.createUnacceptedError('charset', charset);
				return false;
			}
		}

		encoding = this.encoding;
		if( encoding ){
			if( encoding != this.encoding ) this.removeHeader('content-length');
			if( false === request.accept('encoding', encoding) ){
				this.headerError = this.createUnacceptedError('encoding', encoding);
				return false;
			}
		}

		return true;
	},

	generateContentHeaders: function(){
		this.populateContentHeaders();
		if( false === this.validContentHeaders() ){
			return this.error(this.headerError);
		}
	},

	createUnacceptedError: function(){

	},

	get stream(){
		if( this.cachedStream === null ){
			var stream = this.cachedStream = new this.Stream();

			/*
			if( false === stream.supportEncoding(encoding) ){
				this.headerError = this.createUnsupportedError('encoding', encoding);
				return false;
			}
			stream.encoding = encoding;
			*/

			stream.encoding = this.encoding;
			stream.charset = this.charset;
			stream.on('error', this.error.bind(this));
			stream.pipe(this.serverResponse);
		}
		return this.cachedStream;
	},

	// use the stream to transform the data before writing them back into response
	// (because the stream is piped to response)
	handlePipe: function(readableStream){
		this.serverResponse.unpipe(readableStream);
		readableStream.pipe(this.stream);
	},

	write: function(chunk, encoding, callback){
		return this.stream.write.apply(this.stream, arguments);
	}
};

module.exports = {
	response: ResponseProperties,

	handle: function(router){
		var response = router.response;

		response.on('beforeSendingHeaders', response.generateContentHeaders);
		response.serverResponse.on('pipe', response.handlePipe.bind(response));
		
		router.next();
	}
};