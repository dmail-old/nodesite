/*

THE FINAL GOAL:

If a request send a file in content-encoding: gzip
If the appropriate behaviour is to save that file on the server
The request stream could just be piped to a filesystem write stream

Negotiator:
https://github.com/federomero/negotiator

*/

var Negotiator = require('negotiator');
var Router = require('Router');

var RequestProperties = {
	Stream: require('RawStream'),
	cachedStream: null,
	defaultEncoding: 'identity',
	defaultCharset: 'utf8',

	cachedNegotiator: null,
	// NOTE: pourquoi je me permet d'imposer contenttype et charset si celui qui fait la requête ne le supporte pas
	// le comportement normal serait plutot de répondre par une erreur: désolé contenttype ou charset pas possible
	// surement parce que si ce n'est pas précisé c'est que donc on peut en théorie tout répondre
	defaultAcceptedContentType: '*/*',
	defaultAcceptedCharset: 'utf8',
	defaultAcceptedLanguage: 'fr',
	defaultAcceptedEncoding: 'identity',

	parseContentType: function(contentType){
		var mediaType = null, charset = null, search = ';charset=', index;

		if( typeof contentType == 'string' ){
			index = contentType.indexOf(search);

			if( index === -1 ){
				search = '; charset=';
				index = contentType.indexOf(search);
			}

			if( index === -1 ){
				mediaType = contentType;
			}
			else{
				mediaType = contentType.slice(0, index);
				charset = contentType.slice(index + search.length);
				if( charset == 'utf-8' ) charset = 'utf8';
			}
		}

		return [mediaType, charset];
	},

	get encoding(){
		if( this.hasHeader('content-encoding') ){
			return this.getHeader('content-encoding');
		}
		return this.defaultEncoding;
	},

	get charset(){
		if( this.hasHeader('content-type') ){
			return this.parseContentType(this.getHeader('content-type'))[1];
		}
		return this.defaultCharset;
	},

	get negotiator(){
		// en tout cas c'est quelque chose utiliser par la réponse et non la requête
		if( this.cachedNegotiator === null ){
			this.cachedNegotiator = new Negotiator({
				headers: {
					'accept': this.getHeader('accept', this.defaultAcceptedContentType),
					'accept-charset': this.getHeader('accept-charset', this.defaultAcceptedCharset),
					'accept-encoding': this.getHeader('accept-encoding', this.defaultAcceptedEncoding),
					'accept-language': this.getHeader('accept-language', this.defaultAcceptedLanguage)
				}
			});	
		}
		return this.cachedNegotiator;
	},

	accept: function(name, value){
		if( name == 'contentType' ) name = 'mediaType';
		return Boolean(this.negotiator[name](value));
	},

	getPreffereds: function(name){
		if( name == 'contentType' ) name = 'mediaType';
		return this.negotiator[name + 's']();
	},

	createUnsupportedEncodingError: function(encoding){
		var error = new Error();

		error.message = 'Unsupported charset {encoding}. Supported encodings: {encodings}';
		error.data = {
			encoding: encoding,
			supporteds: Object.keys(this.Stream.decoders)
		};
		error.statusCode = 415;	// unsupported request header
		error.code = 'UNSUPPORTED_ENCODING';

		return error;
	},

	createUnsupportedCharsetError: function(charset){
		var error = new Error();

		error.message = 'Unsupported charset {charset}. Supported charsets: {charsets}';
		error.data = {
			charset: charset,
			supporteds: Object.keys(this.Stream.deconverters)
		};
		error.statusCode = 415;	// unsupported request header
		error.code = 'UNSUPPORTED_CHARSET';

		return error;
	},

	get stream(){
		if( this.cachedStream === null ){
			var stream = this.cachedStream = new this.Stream();

			var encoding = this.encoding;
			if( stream.supportEncoding(encoding) ){
				stream.encoding = encoding;
			}
			else{
				throw this.createUnsupportedEncodingError(encoding);
			}

			var charset = this.charset;
			if( stream.supportCharset(charset) ){
				stream.charset = charset;
			}
			else{
				throw this.createUnsupportedCharsetError(charset);
			}

			// read from the request stream
			stream.chain(this.incomingMessage, true);
		}
		return this.cachedStream;
	},

	pipe: function(writableStream){
		return this.stream.pipe(writableStream);
	}
};

module.exports = {
	request: RequestProperties,

	handle: function(router){
		router.request.incomingMessage.on('addListener', function(event){
			// create the stream
			if( event == 'data') var stream = router.request.stream;
		});
		router.next();
	}
};