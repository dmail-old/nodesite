/*

on pourrait séparer handler de page de sorte que la page n'a pas besoin de requestHandler
ni de request/response et Page est responsable d'apeller le handler depuis le module qu'on lui passe

*/

require('core/function');
var proto = require('proto');
var Page = proto.create({
	Path: require('path'),
	Access: require('../Access'),
	Template: require('../Template'),

	requestHandler: null,
	request: null,
	response: null,
	
	path: null,
	pageExports: null,
	handler: null,
	access: null,
	callback: null,
	bind: null,

	constructor: function(requestHandler, path){
		this.requestHandler = requestHandler;
		this.request = requestHandler.request;
		this.response = requestHandler.response;
		this.path = path;

		// this.Template.prototype.fileSystem = requestHandler.fileSystem;
	},

	createHandler: function(fn, bind){
		return PageHandler.new(this, fn, bind);
	},

	createHandlerFromExports: function(pageExports){
		
		// accept all method
		if( typeof pageExports == 'function' ){
			return this.createHandler(pageExports);			
		}		
		if( typeof pageExports == 'object' ){	
			// accept all method
			if( '*' in pageExports ){
				return this.createHandler(pageExports['*'], pageExports);
			}
			// accept a specific method
			if( this.request.method in pageExports ){
				return this.createHandler(pageExports[this.request.method], pageExports);
			}

			if( typeof handler == 'object' ){
				// faudrais vérifier si l'url correspond au clé de l'objet, si oui on apelle les fonction en valeur
				// sauf que c'est surement une feature pas si utile que ça, on fait pas ça pour le moment
			}
		}

		return null;
	},

	createRouteNotFoundError: function(){
		var error = new Error();
		error.code = 'ROUTE_NOT_FOUND';
		error.status = 501;
		return error;
	},

	compile: function(){
		try{
			this.pageExports = require(this.path);
		}
		catch(e){
			if( e.code == 'MODULE_NOT_FOUND' ) e.statusCode = 404;
			throw e;
		}

		this.handler = this.createHandlerFromExports(this.pageExports);

		if( !this.handler ){
			throw this.createRouteNotFoundError();
		}
		else{
			this.handler.setArgumentsFromRequest(this.request);
		}
	},

	generate: function(callback, bind){
		this.callback = callback;
		this.bind = bind;

		process.nextTick(function(){
			try{
				this.compile();

				this.access = this.Access.new(this.path);
				// this request has no right to call this page
				if( this.access.has(this.handler.args) === false ){
					throw this.access.error;
				}

				this.handler.handle();
			}
			catch(e){
				callback.call(bind, e);
			}
		}.bind(this));		
	},

	// for a page in 'folder/page.page', search for 'folder/html/page.html'
	getTemplatePath: function(path){
		return this.Path.join(this.Path.dirname(path), 'html', this.Path.basename(path, '.page') + '.html');
	},

	createTemplate: function(path){
		if( arguments.length === 0 ) path = this.getTemplatePath(this.path);
		return this.Template.new(path);
	},

	send: function(data){
		if( typeof data == 'object' ){
			var template;

			if( this.Template.isPrototypeOf(data) ){
				data = template;
			}
			else{
				template = this.createTemplate();

				try{
					template.render(data);
					data = template.result;
				}
				catch(e){
					// le template n'existe pas on envoit les données tel quel
					if( e.code === 'ENOENT' ){

					}
					else{
						throw e;
					}				
				}
			}
		}

		this.callback.call(this.bind, null, data);
	}
});

var PageHandler = proto.create({
	page: null,
	fn: null,
	bind: null,
	args: null,

	constructor: function(page, fn, bind){
		this.page = page;
		this.fn = fn;
		this.bind = bind;
	},

	getArguments: function(request){
		var args, params;

		if( Array.isArray(request.bodyParams) ){
			args = request.bodyParams;
		}
		else{
			params = request.urlParams;

			if( params == null ){
				args = [];
			}
			else if( Array.isArray(params) ){
				args = params;
			}
			else if( typeof params == 'object' ){
				args = [];
				if( typeof this.fn == 'function' ){
					var names = Function.argumentNames(this.fn), i = 0, j = names.length - 1, name;

					for(;i<j;i++){
						name = names[i];
						args.push(params[name]);
					}
				}
			}
			else{
				args = [];
			}
		}

		return args;
	},

	createArgumentsLengthError: function(){
		var error = new Error();
		error.code = 'ARGUMENTS_LENGTH_ERROR';
		return error;
	},

	setArgumentsFromRequest: function(request){
		this.args = this.getArguments(request);
		if( this.args.length != (this.fn.length - 1) ){
			throw this.createArgumentsLengthError();
		}
	},

	handle: function(){
		this.fn.apply(this.bind, [this.page].concat(this.args));
	}
});

module.exports = Page;