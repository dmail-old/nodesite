/*
- auto content-language:
les fichiers non binaire (hormis fichier langue) sont tous en anglais
-> comment le navigateur gère si on précise que c'est des fichiers anglais
pour les réponses genre pages/json etc le language semble approprié par contre mais aucune idée de comment le gérer
pour le moment
-> on désactive le content-language jusqu'à ce qu'on ai à s'en occuper

- auto content-encoding:
pouvoir configurer quand et comment j'encode ce que je réponds

*/

var proto = require('proto');
var util = require('Stream-util');

var ResponseProperties = {
	Stream: require('ProcessedStream'),
	cachedStream: null,

	//defaultMediaType: 'text/plain',
	defaultMediaType: 'application/octet-stream', // RFC2616 section 7.2.1
	defaultCharset: 'utf8', // by default data are considered using utf8 charset
	defaultEncoding: 'identity',  // by default data are considered not encoded
	defaultLanguage: 'en',
	negotiateMediaType: false, // voir comment on peut faire
	negotiateCharset: true, // mais tfaçon j'en supporte aucun autre que utf8
	negotiateEncoding: false,
	negotiateLanguage: true,

	bodyCharset: 'utf8',
	bodyEncoding: 'identity',

	get encoding(){
		return this.getHeader('content-encoding') || this.defaultEncoding;
	},

	set encoding(encoding){
		this.setHeader('content-encoding', encoding);
	},

	get mediaType(){
		if( this.hasHeader('content-type') ){
			return this.request.parseContentType(this.getHeader('content-type'))[0];
		}
		return this.defaultMediaType;
	},

	set mediaType(mediaType){
		this.setHeader('content-type', mediaType + ';charset=' + this.charset);
	},

	get charset(){
		if( this.hasHeader('content-type') ){
			return this.request.parseContentType(this.getHeader('content-type'))[1];
		}
		return this.defaultCharset;
	},

	set charset(charset){
		this.setHeader('content-type', this.mediaType + ';charset=' + charset);
	},

	populateContentHeaders: function(){
		// status code 204 et 304 pas besoin de certain headers (not modified and no content)
		// https://github.com/mcavage/node-restify/blob/master/lib/response.js#L268

		if( false === this.hasHeader('content-type') && this.negotiateMediaType ){
			//this.mediaType = ;
		}

		if( false === this.hasHeader('content-type') && this.negotiateCharset ){
			//this.charset = ;
		}

		if( this.charset && false === this.hasHeader('content-language') && this.negotiateLanguage ){
			//this.language = ;
		}

		if( false === this.hasHeader('content-encoding') && this.negotiateEncoding ){
			//this.encoding = ;
		}
	},

	validContentHeaders: function(){
		var request = this.request, mediaType, charset, encoding;

		mediaType = this.mediaType;
		if( mediaType ){
			if( false === request.accept('mediaType', mediaType) ){
				this.headerError = this.createUnacceptedError('type', mediaType);
				return false;
			}
		}

		charset = this.charset;
		if( charset ){
			if( charset != this.charset ) this.removeHeader('content-length');
			if( false === request.accept('charset', charset) ){
				this.headerError = this.createUnacceptedError('charset', charset);
				return false;
			}
		}

		encoding = this.encoding;
		if( encoding ){
			if( encoding != this.encoding ) this.removeHeader('content-length');
			if( false === request.accept('encoding', encoding) ){
				this.headerError = this.createUnacceptedError('encoding', encoding);
				return false;
			}
		}

		return true;
	},

	generateContentHeaders: function(){
		if( this.hasBody() ){
			this.populateContentHeaders();
			if( false === this.validContentHeaders() ){
				return this.error(this.headerError);
			}
		}	
	},

	createUnacceptedError: function(){

	},

	get stream(){
		if( this.cachedStream === null ){
			var stream = this.cachedStream = new this.Stream();

			/*
			if( false === stream.supportEncoding(encoding) ){
				this.headerError = this.createUnsupportedError('encoding', encoding);
				return false;
			}
			stream.encoding = encoding;
			*/

			stream.encoding = this.encoding;
			stream.charset = this.charset;
			stream.on('error', this.error.bind(this));
			stream.pipe(this.serverResponse);
		}
		return this.cachedStream;
	},

	// use the stream to transform the data before writing them back into response
	// (because the stream is piped to response)
	redirectPipe: function(readableStream){
		this.serverResponse.unpipe(readableStream);
		readableStream.pipe(this.stream);
	},

	write: function(chunk, encoding, callback){
		return this.stream.write(chunk, encoding, callback);
	}
};

// wrapBody
require('property');
Object.define(ResponseProperties, {
	wrapped: false,
	prefix: null,
	suffix: null,
	prefixEncoding: 'utf8',
	suffixEncoding: 'utf8',

	surround: function(prefix, suffix, encoding){
		this.prefix = prefix;
		this.suffix = suffix;
		if( typeof encoding === 'string' ) this.prefixEncoding = this.suffixEncoding = encoding;
	},

	wrapBody: function(){
		if( this.wrapped ) throw new Error('wrap can only be called once');
		this.wrapped = true;

		var response = this, write, end, setHeader;

		// first stream.write() will write prefix before data
		write = response.write;
		response.write = function(chunk, encoding){
			this.write = write;				
			if( this.prefix !== null ){
				this.write(this.prefix, this.prefixEncoding);
			}
			return this.write(chunk, encoding);				
		};
		
		// first stream.end() will write suffix before ending stream
		end = response.end;
		response.end = function(chunk, encoding){
			this.end = end;

			if( arguments.length > 0 ) this.write(chunk, encoding);
			if( this.suffix !== null ) this.write(this.suffix, this.suffixEncoding);

			return this.end();
		};

		setHeader = response.setHeader;
		response.setHeader = function(name, value){
			if( name == 'content-length' ){
				if( !this.generatingLength ){ // length is generated so it's the right length
					if( this.prefix !== null ) value+= this.computeLength(this.prefix);
					if( this.suffix !== null ) value+= this.computeLength(this.suffix);
				}
				this.setHeader = setHeader;
			}
			return setHeader.call(this, name, value);
		};
	}
});

module.exports = {
	requires: 'requestNegotiation',
	response: ResponseProperties,

	use: function(router, options){
		if( options ){
			proto.define(router.Response, options);
		}
	},

	handle: function(request, response, handler){
		// response
		response.on('beforeSendingHeaders', response.generateContentHeaders);
		response.serverResponse.on('pipe', response.redirectPipe.bind(response));
		response.wrapBody();

		handler.next();
	}
};