/*
- auto content-language:
les fichiers non binaire (hormis fichier langue) sont tous en anglais
-> comment le navigateur gère si on précise que c'est des fichiers anglais
pour les réponses genre pages/json etc le language semble approprié par contre mais aucune idée de comment le gérer
pour le moment
-> on désactive le content-language jusqu'à ce qu'on ai à s'en occuper

- auto content-encoding:
pouvoir configurer quand et comment j'encode ce que je réponds

*/

require('Object.toSource');
var proto = require('proto');
var util = require('Stream-util');
var ParentStream = require('ProcessedStream');

var ResponseProperties = {
	Stream: proto.extend(ParentStream, {
		prefixed: false,
		prefix: null,
		suffix: null,
		prefixEncoding: 'utf8',
		suffixEncoding: 'utf8',

		write: function(chunk, encoding){				
			if( typeof chunk != 'string' && !Buffer.isBuffer(chunk) ){
				chunk = Object.toSource(chunk);
			}

			if( this.prefix !== null && this.prefixed === false ){
				this.prefixed = true;
				this.write(this.prefix, this.prefixEncoding);
			}

			return ParentStream.prototype.write.call(this, chunk, encoding);
		},

		end: function(chunk, encoding){
			if( arguments.length > 0 ) this.write(chunk, encoding);
			if( this.suffix !== null ) this.write(this.suffix, this.suffixEncoding);

			return ParentStream.prototype.end.call(this);
		}
	}),

	//defaultMediaType: 'text/plain',
	defaultMediaType: 'application/octet-stream', // RFC2616 section 7.2.1
	defaultCharset: 'utf8', // by default data are considered using utf8 charset
	defaultEncoding: 'identity',  // by default data are considered not encoded
	defaultLanguage: 'en',
	negotiateMediaType: false, // voir comment on peut faire
	negotiateCharset: true, // mais tfaçon j'en supporte aucun autre que utf8
	negotiateEncoding: false,
	negotiateLanguage: true,

	bodyCharset: 'utf8',
	bodyEncoding: 'identity',

	surround: function(prefix, suffix, encoding){
		this.stream.prefix = prefix;
		this.stream.suffix = suffix;
		if( typeof encoding === 'string' ) this.stream.prefixEncoding = this.stream.suffixEncoding = encoding;
	},

	setHeader: function(name, value){
		if( name == 'content-length' ){
			if( !!this.generatingLength ){ // length is generated so it's the right length
				if( this.stream.prefix !== null ) value+= this.computeLength(this.stream.prefix);
				if( this.stream.suffix !== null ) value+= this.computeLength(this.stream.suffix);
			}
		}
		return this.serverResponse.setHeader(name, value);
	},

	get encoding(){
		return this.getHeader('content-encoding') || this.defaultEncoding;
	},

	set encoding(encoding){
		this.setHeader('content-encoding', encoding);
	},

	get mediaType(){
		if( this.hasHeader('content-type') ){
			return this.request.parseContentType(this.getHeader('content-type'))[0];
		}
		return this.defaultMediaType;
	},

	set mediaType(mediaType){
		this.setHeader('content-type', mediaType + ';charset=' + this.charset);
	},

	get charset(){
		if( this.hasHeader('content-type') ){
			return this.request.parseContentType(this.getHeader('content-type'))[1];
		}
		return this.defaultCharset;
	},

	set charset(charset){
		this.setHeader('content-type', this.mediaType + ';charset=' + charset);
	},

	populateContentHeaders: function(){
		// status code 204 et 304 pas besoin de certain headers (not modified and no content)
		// https://github.com/mcavage/node-restify/blob/master/lib/response.js#L268

		if( false === this.hasHeader('content-type') && this.negotiateMediaType ){
			//this.mediaType = ;
		}

		if( false === this.hasHeader('content-type') && this.negotiateCharset ){
			//this.charset = ;
		}

		if( this.charset && false === this.hasHeader('content-language') && this.negotiateLanguage ){
			//this.language = ;
		}

		if( false === this.hasHeader('content-encoding') && this.negotiateEncoding ){
			//this.encoding = ;
		}
	},

	createUnacceptedError: function(){

	},

	validContentHeaders: function(){
		var request = this.request, mediaType, charset, encoding;

		mediaType = this.mediaType;
		if( mediaType ){
			if( false === request.accept('mediaType', mediaType) ){
				this.headerError = this.createUnacceptedError('type', mediaType);
				return false;
			}
		}

		charset = this.charset;
		if( charset ){
			if( charset != this.charset ) this.removeHeader('content-length');
			if( false === request.accept('charset', charset) ){
				this.headerError = this.createUnacceptedError('charset', charset);
				return false;
			}
			//this.stream.charset = charset;
		}

		encoding = this.encoding;
		if( encoding ){
			if( encoding != this.encoding ) this.removeHeader('content-length');
			if( false === request.accept('encoding', encoding) ){
				this.headerError = this.createUnacceptedError('encoding', encoding);
				return false;
			}
			/*
			if( false === stream.supportEncoding(encoding) ){
				this.headerError = this.createUnsupportedError('encoding', encoding);
				return false;
			}
			stream.encoding = encoding;
			*/
			this.stream.encoding = encoding;
		}

		return true;
	},

	generateContentHeaders: function(){
		if( this.hasBody() ){
			this.populateContentHeaders();
			if( false === this.validContentHeaders() ){
				return this.error(this.headerError);
			}
		}	
	},

	createStream: function(){
		this.useStream(new this.Stream());
	}
};

module.exports = {
	requires: 'requestNegotiation',
	response: ResponseProperties,

	use: function(router, options){
		if( options ){
			proto.define(router.Response, options);
		}
	},

	handle: function(request, response, handler){
		// response
		response.createStream();
		response.on('beforeSendingHeaders', response.generateContentHeaders);

		handler.next();
	}
};