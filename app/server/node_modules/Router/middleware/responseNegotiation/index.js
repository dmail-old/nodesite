/*
- auto content-language:
les fichiers non binaire (hormis fichier langue) sont tous en anglais
-> comment le navigateur gère si on précise que c'est des fichiers anglais
pour les réponses genre pages/json etc le language semble approprié par contre mais aucune idée de comment le gérer
pour le moment
-> on désactive le content-language jusqu'à ce qu'on ai à s'en occuper

- auto content-encoding:
pouvoir configurer quand et comment j'encode ce que je réponds

*/

require('Object.toSource');
var proto = require('proto');

var ResponseProperties = {
	encoders: require('./encoders'),
	converters: require('./converters'),
	//defaultMediaType: 'text/plain',
	defaultMediaType: 'application/octet-stream', // RFC2616 section 7.2.1
	defaultCharset: 'utf8', // by default data are considered using utf8 charset
	defaultEncoding: 'identity',  // by default data are considered not encoded
	defaultLanguage: 'en',
	negotiateMediaType: false, // voir comment on peut faire
	negotiateCharset: true, // mais tfaçon j'en supporte aucun autre que utf8
	negotiateEncoding: false,
	negotiateLanguage: true,

	bodyCharset: 'utf8',
	bodyEncoding: 'identity',

	get encoding(){
		return this.getHeader('content-encoding') || this.defaultEncoding;
	},

	set encoding(encoding){
		this.setHeader('content-encoding', encoding);
	},

	get mediaType(){
		if( this.hasHeader('content-type') ){
			return this.request.parseContentType(this.getHeader('content-type'))[0];
		}
		return this.defaultMediaType;
	},

	set mediaType(mediaType){
		this.setHeader('content-type', mediaType + ';charset=' + this.charset);
	},

	get charset(){
		if( this.hasHeader('content-type') ){
			return this.request.parseContentType(this.getHeader('content-type'))[1];
		}
		return this.defaultCharset;
	},

	set charset(charset){
		this.setHeader('content-type', this.mediaType + ';charset=' + charset);
	},

	populateContentHeaders: function(){
		// status code 204 et 304 pas besoin de certain headers (not modified and no content)
		// https://github.com/mcavage/node-restify/blob/master/lib/response.js#L268

		if( false === this.hasHeader('content-type') && this.negotiateMediaType ){
			//this.mediaType = ;
		}

		if( false === this.hasHeader('content-type') && this.negotiateCharset ){
			//this.charset = ;
		}

		if( this.charset && false === this.hasHeader('content-language') && this.negotiateLanguage ){
			//this.language = ;
		}

		if( false === this.hasHeader('content-encoding') && this.negotiateEncoding ){
			//this.encoding = ;
		}
	},

	createUnacceptedError: function(){
		return new Error('unaccepted error');
	},

	canConvert: function(charset){
		return charset === 'utf8' || charset in this.converters;
	},

	canEncode: function(encoding){
		return encoding === 'identity' || encoding in this.encoders;
	},

	generateContentHeaders: function(){
		if( this.hasBody() ){
			this.populateContentHeaders();
			if( false === this.validContentHeaders() ){
				return this.error(this.headerError);
			}
		}
	},

	validContentHeaders: function(){
		var request = this.request, mediaType, charset, encoding;

		// var processedStream = this.response;

		mediaType = this.mediaType;
		if( mediaType ){
			if( false === request.accept('mediaType', mediaType) ){
				this.headerError = this.createUnacceptedError('type', mediaType);
				return false;
			}
		}

		charset = this.charset;
		if( charset ){
			if( charset != this.charset ) this.removeHeader('content-length');
			if( false === request.accept('charset', charset) ){
				this.headerError = this.createUnacceptedError('charset', charset);
				return false;
			}
			if( false === this.canConvert(charset) ){
				this.headerError = this.createUnsupportedError('charset', charset);
				return false;
			}
			else if( charset != 'utf8' ){
				var converter = this.encoders[charset].call(this);
				this.addTransformer(converter);
			}
		}

		encoding = this.encoding;
		if( encoding ){
			if( encoding != this.encoding ) this.removeHeader('content-length');
			if( false === request.accept('encoding', encoding) ){
				this.headerError = this.createUnacceptedError('encoding', encoding);
				return false;
			}

			if( false === this.canEncode(encoding) ){
				this.headerError = this.createUnsupportedError('encoding', encoding);
				return false;
			}
			else if( encoding != 'identity' ){
				var encoder = this.encoders[encoding].call(this);
				this.addTransformer(encoder);
			}
		}

		return true;
	},

	initProcessedStream: function(){
		var Stream = require('stream');
		var wrapStream =  proto.extend(Stream.Transform, {
			prefixed: false,
			prefix: null,
			suffix: null,
			prefixEncoding: 'utf8',
			suffixEncoding: 'utf8',

			constructor: function(options){
				Stream.Transform.call(this, options);
			},

			pushPrefix: function(){
				if( this.prefix !== null && this.prefixed === false ){
					this.prefixed = true;
					this.push(this.prefix, this.prefixEncoding);
				}
			},

			_write: function(chunk, encoding, done){
				if( typeof chunk != 'string' && !Buffer.isBuffer(chunk) ){
					chunk = Object.toSource(chunk);
				}

				this.pushPrefix();
				this.push(chunk, encoding);
				done();
			},

			_flush: function(done){
				this.pushPrefix();
				if( this.suffix !== null ){
					this.write(this.suffix, this.suffixEncoding);
				}
				done();
			}
		});

		this.addTransformer(new wrapStream());
	}
};

module.exports = {
	name: 'responseNegotiation',
	requires: 'requestNegotiation',
	response: ResponseProperties,

	use: function(router, options){
		if( options ){
			proto.define(router.Response, options);
		}
	},

	handle: function(handler){
		var response = handler.response;
		// response
		response.initProcessedStream();
		response.on('beforeSendingHeaders', response.generateContentHeaders.bind(response));
	}
};