module.exports = {
	name: 'requestLength',

	request: {
		bytesLimit: -1, // 1e6
		bytesExpected: null,
		bytesReceived: 0,

		get length(){
			return parseInt(this.getHeader('content-length'), 10);
		},

		createTooLargeError: function(received, limit){
			// this.request.connection.destroy();
			var error = new Error();

			error.message = 'Data too large: {received} > {limit}';
			error.data = {
				received: received,
				limit: limit
			};
			error.statusCode = 413; // too large
			error.code = 'TOO_LARGE';

			return error;
		},

		createBadSizeError: function(received, expected){
			var error = new Error();

			error.message = 'Received bytes must be equal to expected bytes: {received} != {expected}';
			error.data = {
				received: received,
				expected: expected
			};
			error.statusCode = 400; // bad request
			error.code = 'BAD_SIZE';

			return error;
		},

		isTooLarge: function(byteCount){
			var limit = this.bytesLimit;
			return typeof byteCount === 'number' && typeof limit === 'number' && limit != -1 && byteCount > limit;
		},

		checkLength: function(){
			this.bytesExpected = this.length;
			if( this.isTooLarge(this.bytesExpected) ){
				throw this.createTooLargeError(this.bytesExpected, this.bytesLimit);
			}

			this.on('data', function(chunk, encoding){
				this.bytesReceived+= Buffer.isBuffer(chunk) ? chunk.length : Buffer.byteLength(chunk, encoding);

				if( this.isTooLarge(this.bytesReceived) ){
					this.emit('error', this.createTooLargeError(this.bytesReceived, this.byteLimit));
				}
			});

			this.on('end', function(){
				var expected = this.bytesExpected;
				if( typeof expected == 'number' && expected != -1 && this.bytesReceived != expected ){
					this.emit('error', this.createBadSizeError(this.bytesReceived, expected));
				}
			});
		}
	},

	handle: function(request){
		request.checkLength();
	}
};
