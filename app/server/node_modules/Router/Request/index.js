/*

name: Request

description: Wrapper for the native node request object

Negotiator:
https://github.com/federomero/negotiator

making response & request streamable
https://github.com/mjijackson/mach/blob/master/modules/request.js

inspiration:
restify: https://github.com/mcavage/node-restify

*/

var sprintf = require('util').format;
var Negotiator = require('negotiator');
var QueryString = require('querystring');
var URL = require('url');

var Request = {
	METHODS: {
		OPTIONS: 'OPTIONS',
		HEAD: 'HEAD',
		GET: 'GET',
		POST: 'POST',
		PUT: 'PUT',
		DELETE: 'DELETE'
	},
	HEADERS: {
		CONTENT_TYPE: 'content-type',
		CONTENT_LENGTH: 'content-length',
		CONTENT_ENCODING: 'content-encoding',
		CONTENT_MD5: 'content-md5',
		COOKIE: 'cookie',
		REQUESTED_WITH: 'x-requested-with',
		HTTP_METHOD_OVERRIDE: 'x-http-method-override'
	},
	AJAX_HEADER_VALUE: 'xmlhttprequest',

	router: null,
	response: null,
	urlParams: null,
	
	negotiator: null,
	// NOTE: pourquoi je me permet d'imposer contenttype et charset si celui qui fait la requête ne le supporte pas
	// le comportement normal serait plutot de répondre par une erreur: désolé contenttype ou charset pas possible
	// surement parce que si ce n'est pas précisé c'est que donc on peut en théorie tout répondre
	defaultAcceptedContentType: '*/*',
	defaultAcceptedCharset: 'utf8',
	defaultAcceptedLanguage: 'fr',	
	defaultAcceptedEncoding: 'identity',

	/*
	if we wrap thoose methods we will be able to catch fileSystem and database call for this request
	*/
	fileSystem: require('fs'),
	// database: require('db'),

	new: function(request, router){
		// add this property to the request object
		// then create an instance of that object and call the create method
		return Object.prototype.new.call(Object.supplement(request, this), router);
	},

	init: function(router){
		this.router = router;

		this.url = URL.parse(this.url);
		this.url.toString = function(){ return this.href; };
		this.url.pathname = QueryString.unescape(this.url.pathname);
		this.urlParams = QueryString.parse(this.urlObject.query);

		// ça c'est limite dans bodyWriter qu'il faut le mettre en fait
		// en tout cas c'est quelque chose utiliser par la réponse et non la requête
		this.negotiator = new Negotiator({
			headers: {
				'accept': this.getHeader('accept', this.defaultAcceptedContentType),
				'accept-charset': this.getHeader('accept-charset', this.defaultAcceptedCharset),
				'accept-encoding': this.getHeader('accept-encoding', this.defaultAcceptedEncoding),
				'accept-language': this.getHeader('accept-language', this.defaultAcceptedLanguage)
			}
		});
	},

	hasHeader: function(name){
		name = name.toLowerCase();
		return name in this.headers;
	},

	getHeader: function(name, defaultValue){
		if( this.hasHeader(name) ){
			name = name.toLowerCase();
			return this.headers[name];
		}
		return defaultValue || null;		
	},

	is: function(){
		var i = 0, j = arguments.length, arg, method = this.method.toLowerCase();
		for(;i<j;i++){
			arg = arguments[i];
			if( arg == 'all' || arg == '*' || arg === method ) return true;
		}
		return false;
	},

	isAjax: function(){
		return this.getHeader(this.HEADERS.REQUESTED_WITH) == this.AJAX_HEADER_VALUE;
	},

	accept: function(name, value){
		if( name == 'contentType' ) name = 'mediaType';
		return Boolean(this.negotiator[name](value));
	},

	getPreffereds: function(name){
		if( name == 'contentType' ) name = 'mediaType';
		return this.negotiator[name + 's']();
	},

	error: function(error){
		return this.router.next(error);
	},

	next: function(error){
		return this.router.next(error);
	},

	toString: function() {
		var headers = this.headers;
		var headerString = '';
		var self = this;
		var str;

		Object.keys(headers).forEach(function(k){
			headerString+= sprintf('%s: %s\n', k, headers[k]);
		});

		str = sprintf('%s %s HTTP/%s\n%s', this.method, this.url, this.httpVersion, headerString);

		return str;
	}
};

module.exports = Request;