/*

name: Request

description: Helper for node request

making response & request streamable
https://github.com/mjijackson/mach/blob/master/modules/request.js

inspiration:
restify: https://github.com/mcavage/node-restify

*/

var QueryString = require('querystring');
var URL = require('url');
var StringTemplate = require('StringTemplate');
var proto = require('proto');
var Emitter = require('Emitter');
var proto = require('proto');

var Request = proto.extend(Emitter, {
	router: null,
	response: null,
	urlParams: null,

	/*
	if we wrap fileSystem we could be able to catch fileSystem call for this request, same for database
	*/
	fileSystem: require('fs'),
	// database: require('db'),

	constructor: function(incomingMessage, router){
		Emitter.init.call(this);
		this.incomingMessage = incomingMessage;
		this.router = router;

		this.url = URL.parse(this.url);
		this.url.toString = function(){ return this.href; };
		this.url.pathname = QueryString.unescape(this.url.pathname);
		this.urlParams = QueryString.parse(this.url.query);
	},

	hasHeader: function(name){
		name = name.toLowerCase();
		return name in this.headers;
	},

	getHeader: function(name, defaultValue){
		if( this.hasHeader(name) ){
			name = name.toLowerCase();
			return this.headers[name];
		}
		return defaultValue || null;		
	},

	is: function(){
		var i = 0, j = arguments.length, arg, method = this.method.toLowerCase();
		for(;i<j;i++){
			arg = arguments[i];
			if( arg == 'all' || arg == '*' || arg === method ) return true;
		}
		return false;
	},

	hasBody: function(){
		if( this.is('post', 'put') === false ){
			return false;
		}
		if( this.hasHeader('transfer-encoding') ){
			return true;
		}
		if( this.getHeader('transfer-encoding') === 'chunked' ){
			return false; // why??
		}
		if( this.getHeader('content-length') == '0' ){
			return false;
		}
		return true;
	},

	isAjax: function(){
		return this.getHeader(this.router.HEADERS.REQUESTED_WITH) == this.router.HEADER_VALUES.AJAX;
	},

	error: function(error){
		return this.router.next(error);
	},

	next: function(error){
		return this.router.next(error);
	}
});

['setTimeout'].forEach(function(name){
	Request[name] = function(){
		return this.incomingMessage[name].apply(this.incomingMessage, arguments);
	};
});

['httpVersion', 'headers', 'trailers', 'method', 'url', 'statusCode', 'socket'].forEach(function(name){
	Object.defineProperty(Request, name, {
		get: function(){
			return this.incomingMessage[name];
		},

		set: function(value){
			this.incomingMessage[name] = value;
		}
	});
});

module.exports = Request;