/*

name: Request

description: Helper for node request

making response & request streamable
https://github.com/mjijackson/mach/blob/master/modules/request.js

inspiration:
restify: https://github.com/mcavage/node-restify

*/

var proto = require('proto');
var Emitter = require('Emitter');

var Request = proto.extend(Emitter, {
	URL: require('url'),
	QueryString: require('querystring'),
	response: null,
	urlParams: null,

	/*
	if we wrap fileSystem we could be able to catch fileSystem call for this request, same for database
	*/
	fileSystem: require('fs'),
	// database: require('db'),

	constructor: function(incomingMessage){
		Emitter.call(this);
		this.incomingMessage = incomingMessage;

		this.url = this.URL.parse(this.url);
		this.url.toString = function(){ return this.href; };
		this.url.pathname = this.QueryString.unescape(this.url.pathname);
		this.urlParams = this.QueryString.parse(this.url.query);
	},

	getSourceObject: function(){
		return this.incomingMessage;
	},

	hasHeader: function(name){
		name = name.toLowerCase();
		return name in this.headers;
	},

	getHeader: function(name, defaultValue){
		if( this.hasHeader(name) ){
			name = name.toLowerCase();
			return this.headers[name];
		}
		return defaultValue || null;		
	},

	is: function(){
		var i = 0, j = arguments.length, arg, method = this.method.toLowerCase();
		for(;i<j;i++){
			arg = arguments[i];
			if( arg == 'all' || arg == '*' || arg === method ) return true;
		}
		return false;
	},

	hasBody: function(){
		if( !this.is('post', 'put') ){
			return false;
		}
		if( this.hasHeader('transfer-encoding') ){
			return true;
		}
		if( this.getHeader('transfer-encoding') === 'chunked' ){
			return false; // why??
		}
		if( this.getHeader('content-length') == '0' ){
			return false;
		}
		return true;
	},

	isAjax: function(){
		return this.getHeader('x-requested-with') == 'xmlhttprequest';
	},

	error: function(error){
		this.emit('error', error);
	}
});

['setTimeout'].forEach(function(name){
	proto.define(Request, name, function(){
		return this.incomingMessage[name].apply(this.incomingMessage, arguments);
	});
});

['httpVersion', 'headers', 'trailers', 'method', 'url', 'statusCode', 'socket'].forEach(function(name){
	proto.defineProperty(Request, name, {
		get: function(){
			return this.incomingMessage[name];
		},

		set: function(value){
			this.incomingMessage[name] = value;
		}
	});
});

module.exports = Request;