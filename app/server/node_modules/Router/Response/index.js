/*

helper to manipulate the serverResponse

inspired from
https://github.com/mcavage/node-restify/blob/master/lib/response.js

node response source : 
https://github.com/joyent/node/blob/master/lib/_http_server.js

HOW TO SEND STATUS

response.statusCode = 200;

HOW TO SEND STATUS MESSAGE

response.statusMessage = 'ok'; 

HOW TO SEND BODY (prefer A or B)

A) readableStream.pipe(response);
B) response.end([String | Buffer], [encoding], [callback]);
C) response.body = String | Buffer | ReadableStream; response.end();
C) readableStream.pipe(response, {end: false}); response.end(); 
D) response.write(String | Buffer, [encoding], [callback]); response.end();

------------- WITH CONTENT NEGOTIATION MIDDLEWARE -------------------

HOW TO SEND LENGTH

A) response.length = 10; // never touched
B) response.autoLength = true; // computed from the body

HOW TO SEND ENCODING

A) response.encoding = 'gzip'; // force gzip (can throw error)
B) response.negotiateEncoding = true; // use preferred encoding (can throw if no encoding is supported)

*/

var Stream = require('stream');
var Emitter = require('Emitter');
var proto = require('proto');

var Response = proto.extend(Emitter, {
	ServerResponse: require('http').ServerResponse.prototype,
	serverResponse: null,
	request: null,
	writeCalls: null,
	waitCount: 0,

	constructor: function(serverResponse){
		Emitter.call(this);
		this.serverResponse = serverResponse;

		serverResponse.writeHead = this.responseWriteHead.bind(this);
		serverResponse.write = this.responseWrite.bind(this);
		serverResponse.end = this.responseEnd.bind(this);
		serverResponse.on('error', this.error.bind(this));

		/*
		node.js does this automatically
		this.on('beforeSendingHeaders', function(){
			if( this.hasHeader('content-length') === false ){
				// there is a body without content-length header, tell that to the browser
				this.setHeader('transfer-encoding', 'chunked');
				this.setHeader('accept-ranges', 'bytes');
			}
		});
		*/
	},

	getSourceObject: function(){
		var response = this.serverResponse;

		//response.write = this.ServerResponse.write;
		//response.end = this.ServerResponse.end;
		//response.removeListener('error', this.onerror);

		return response;
	},

	hasBody: function(){
		if( this.request.is('head') ){
			return false;
		}

		// https://github.com/joyent/node/blob/master/lib/_http_server.js#L205
		var statusCode = this.statusCode;
		if( statusCode === 204 || statusCode === 304 ){
			return false;
		}
		if( 100 <= statusCode && statusCode <= 199 ){
			return false;
		}

		return true;
	},

	responseWriteHead: function(){
		if( !this.headersSent ){
			this.emit('beforeSendingHeaders');
		}

		return this.ServerResponse.writeHead.apply(this.serverResponse, arguments);
	},

	responseWrite: function(chunk, encoding){
		if( !this.headersSent ){
			// IRRELEVANT?? AJAX request need a 200 statusCode to read the response
			if( this.statusCode < 200 && this.statusCode >= 400 && this.request.isAjax() ){
				this.setHeader('x-status-code', this.statusCode); // error status are put in a header
				this.statusCode = 200;
			}

			//this.emit('beforeSendingHeaders');
		}

		this.emit('write', chunk, encoding);
		if( this.writeCalls ){
			this.writeCalls.push(arguments);
			return false;
		}

		return this.ServerResponse.write.call(this.serverResponse, chunk, encoding);
	},

	responseEnd: function(chunk, encoding){
		if( arguments.length !== 0 ){
			this.write(chunk, encoding);
		}

		this.emit('beforeEnd');

		var ret;
		if( this.writeCalls ){
			ret = false;
		}
		else{
			ret = this.ServerResponse.end.call(this.serverResponse);
		}

		this.emit('end');
		return ret;
	},

	pause: function(){
		if( !this.writeCalls ){
			this.writeCalls = [];
		}
	},

	resume: function(){
		this.writeCalls.forEach(function(args){
			this.ServerResponse.write.apply(this, args);
		}, this);
		this.ServerResponse.end.call(this);
	},

	wait: function(ProgressPrototype){
		this.pause();
		this.waitCount++;

		function Progress(response){
			this.response = response;
			ProgressPrototype.constructor.call(this);
		}

		Progress.prototype = ProgressPrototype;

		var progress = new Progress(this);

		this.on('write', progress.ondata.bind(progress));
		this.on('beforeEnd', function(){
			progress.onend();
			
			// ce qu'on devait faire est terminé on peut appelé end
			this.waitCount--;
			if( this.waitCount === 0 ){
				this.resume();
			}
		}.bind(this));
	},

	get headers(){
		return this.serverResponse._headers;
	},

	set headers(object){
		this.setHeaders(object);
	},

	set body(value){
		if( value instanceof Stream.Readable ){
			value.pipe(this, {end: false});
		}
		else{
			this.pause(); // don't call implicit headers until response.end() is called
			this.write(value);
		}
	},

	error: function(error){
		this.emit('error', error);
	},

	setHeaders: function(headers){
		for(var key in headers){
			this.setHeader(key, headers[key]);
		}
	},

	hasHeader: function(name){
		return typeof this.getHeader(name) != 'undefined';
	},

	send: function(status, chunk, encoding, callback){
		this.statusCode = status;
		return this.end(chunk, encoding, callback);
	}
});

// methods
['writeContinue', 'writeHead', 'setTimeout', 'setHeader',
'getHeader', 'removeHeader', /*'write',*/'addTrailers', 'end'].forEach(function(name){
	proto.define(Response, name, function(){
		return this.serverResponse[name].apply(this.serverResponse, arguments);
	});
});

// properties
['statusCode', 'headersSent', 'sendDate', 'statusMessage'].forEach(function(name){
	proto.defineProperty(Response, name, {
		get: function(){
			return this.serverResponse[name];
		},

		set: function(value){
			this.serverResponse[name] = value;
		}
	});
});

module.exports = Response;