/*

helper to manipulate the serverResponse

inspired from
https://github.com/mcavage/node-restify/blob/master/lib/response.js

node response source :
https://github.com/joyent/node/blob/master/lib/_http_server.js

HOW TO SEND STATUS

response.statusCode = 200;

HOW TO SEND STATUS MESSAGE

response.statusMessage = 'ok';

HOW TO SEND BODY (prefer A or B)

A) readableStream.pipe(response); !! Ne marche pas response n'est pas un stream!
B) response.end([String | Buffer], [encoding], [callback]);
C) response.body = String | Buffer | ReadableStream; response.end();
C) readableStream.pipe(response, {end: false}); response.end();
D) response.write(String | Buffer, [encoding], [callback]); response.end();

------------- WITH CONTENT NEGOTIATION MIDDLEWARE -------------------

HOW TO SEND LENGTH

A) response.length = 10; // never touched
B) response.autoLength = true; // computed from the body

HOW TO SEND ENCODING

A) response.encoding = 'gzip'; // force gzip (can throw error)
B) response.negotiateEncoding = true; // use preferred encoding (can throw if no encoding is supported)

*/

require('Object.assign');
var debug = require('debug');
var stream = require('stream');
var Emitter = require('Emitter');
var proto = require('proto');
var debug = require('debug');
var PassThrough = stream.PassThrough;

var Response = proto.extend(Emitter, {
	ServerResponse: require('http').ServerResponse,
	serverResponse: null,
	request: null,
	stream: null,
	body: null,
	bodyEncoding: null,
	piped: false,

	constructor: function(serverResponse, options){
		Emitter.call(this);
		this.bind = this;

		this.serverResponse = serverResponse;
		this.stream = new stream.PassThrough(options);
		this.stream.on('error', this.error.bind(this));

		/*
		node.js does this automatically, yes but I may need this to know it in logger
		this.on('beforeSendingHeaders', function(){
			if( this.hasHeader('content-length') === false ){
				// there is a body without content-length header, tell that to the browser
				this.setHeader('transfer-encoding', 'chunked');
				this.setHeader('accept-ranges', 'bytes');
			}
		});
		*/
	},

	beforeSendingHeaders: function(){
		if( this.serverResponse.sendDate && !this.hasHeader('date') ){
			this.setHeader('date', new Date().toUTCString());
		}

		// IRRELEVANT?? AJAX request need a 200 statusCode to read the response
		if( this.statusCode < 200 && this.statusCode >= 400 && this.request.isAjax() ){
			this.setHeader('x-status-code', this.statusCode); // error status are put in a header
			this.statusCode = 200;
		}

		this.emit('beforeSendingHeaders');
	},

	setHeaders: function(headers){
		for(var key in headers){
			this.setHeader(key, headers[key]);
		}
	},

	get headers(){
		return this.serverResponse._headers;
	},

	set headers(object){
		this.setHeaders(object);
	},

	error: function(error){
		this.emit('error', error);
	},

	hasHeader: function(name){
		return typeof this.getHeader(name) != 'undefined';
	},

	hasBody: function(){
		if( this.request.is('head') ){
			return false;
		}

		// https://github.com/joyent/node/blob/master/lib/_http_server.js#L205
		var statusCode = this.statusCode;
		if( statusCode === 204 || statusCode === 304 ){
			return false;
		}
		if( 100 <= statusCode && statusCode <= 199 ){
			return false;
		}

		return true;
	},

	prefetchers: null,
	dataBuffer: null,
	ondata: function(chunk, encoding){
		debug('prefetch data');
		this.dataBuffer.push(arguments);
		this.prefetchers.forEach(function(prefetcher){
			prefetcher.ondata(chunk, encoding);
		});
	},

	onend: function(){
		debug('end prefetchers');
		this.prefetchers.forEach(function(prefetcher){
			prefetcher.onend();
		});
		this.prefetchers = null;
		debug('writing data buffers back into response');
		this.dataBuffer.forEach(function(args){
			this.serverResponse.write.apply(this.serverResponse, args);
		}, this);
		this.dataBuffer = null;
		debug('ending response');
		this.serverResponse.end();
	},

	prefetch: function(prefetcherPrototype){
		if( this.piped === true ){
			throw new Error('cannot prefetch, serverResponse is being written');
		}

		function Prefetcher(response){
			this.response = response;
			prefetcherPrototype.constructor.call(this);
		}

		Prefetcher.prototype = prefetcherPrototype;

		var prefetcher = new Prefetcher(this);

		if( this.prefetchers === null ){
			this.dataBuffer = [];
			this.prefetchers = [];
			debug('prefetching data');
			this.stream.on('data', this.ondata.bind(this));
			this.stream.on('end', this.onend.bind(this));
		}
		this.prefetchers.push(prefetcher);
	},

	addTransformer: function(transformStream){
		if( this.piped ){
			throw new Error('cannot addTransformer, serverResponse is being written');
		}

		debug('a stream become the new stream');
		// transformStream.on('error', this.error.bind(this))
		transformStream.pipe(this.stream);
		this.stream = transformStream;
	},

	openPipe: function(){
		if( this.piped === false ){
			this.piped = true;
			if( this.prefetchers === null ){
				debug('piping to serverResponse');
				this.stream.pipe(this.serverResponse);
			}
			else{
				debug('waiting prefetch to write response');
			}
		}
	},

	pipeBody: function(stream){
		this.openPipe();
		return stream.pipe(this.stream);
	},

	writeBody: function(body, encoding){
		this.openPipe();
		return this.stream.write(body, encoding);
	},

	end: function(data, encoding){
		this.openPipe(); // if writeBody or pipeBody is never call I must still call serverResponse.end()
		if( arguments.length ) this.writeBody(data, encoding);
		return this.stream.end();
	},

	send: function(object){
		if( this.headersSent ) throw new Error('headers already sent');

		if( typeof object === 'number' ) object = {statusCode: object};
		else if( typeof object === 'string' ) object = {body: object};

		if( Object(object) == object ){
			if( typeof object.then === 'function' ){
				debug('response.send() called with a promise');
				object.then(
					function(value){
						this.send(value);
					}.bind(this),
					function(value){
						this.error(value);
					}.bind(this)
				);
				return;
			}

			debug('writing response informations');

			if( object.statusCode ) this.statusCode = object.statusCode;
			if( object.statusMessage ) this.statusMessage = object.statusMessage;
			if( object.headers ) this.setHeaders(object.headers);
			if( object.options ) Object.assign(this, object.options);
			this.beforeSendingHeaders();

			if( object.hasOwnProperty('body') ){
				if( object.body instanceof stream.Readable ){
					this.pipeBody(object.body);
					return;
				}

				this.writeBody(object.body, object.bodyEncoding);
			}
		}
		else{
			this.beforeSendingHeaders();
		}

		return this.end();
	},

	getSourceObject: function(){
		var response = this.serverResponse;

		//response.write = this.ServerResponse.write;
		//response.end = this.ServerResponse.end;
		//response.removeListener('error', this.onerror);

		return response;
	}
});

// methods
['setTimeout', 'setHeader', 'getHeader', 'removeHeader'].forEach(function(name){
	Response.prototype[name] = function(){
		return this.serverResponse[name].apply(this.serverResponse, arguments);
	};
});

// properties
['statusCode', 'headersSent', 'sendDate', 'statusMessage', 'ended'].forEach(function(name){
	proto.defineProperty(Response, name, {
		get: function(){
			return this.serverResponse[name];
		},

		set: function(value){
			this.serverResponse[name] = value;
		}
	});
});

module.exports = Response;