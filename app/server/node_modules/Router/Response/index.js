/*

wrapper for the native Response Nodejs object

inspired from
https://github.com/mcavage/node-restify/blob/master/lib/response.js

NOTE

- auto content-language:
les fichiers non binaire (hormis fichier langue) sont tous en anglais
-> comment le navigateur gère si on précise que c'est des fichiers anglais
pour les réponses genre pages/json etc le language semble approprié par contre mais aucune idée de comment le gérer
pour le moment
-> on désactive le content-language jusqu'à ce qu'on ai à s'en occuper

- auto content-encoding:
pouvoir configurer quand et comment j'encode ce que je réponds

FIX

*/

var Stream = require('stream');

global.Stream = Stream;

Stream.isStream = function(a){
	return a instanceof Stream.Readable || a instanceof Stream.Writable || a instanceof Stream.Duplex;
};

global.isReadableStream = function(a){
	return a instanceof Stream.Readable;
};

var http = require('http');
var ServerResponse = http.ServerResponse.prototype;

var Response = {
	sprintf: require('util').format,
	HEADERS: {
		CONTENT_TYPE: 'content-type',
		CONTENT_LENGTH: 'content-length',
		CONTENT_ENCODING: 'content-encoding',
		CONTENT_LANGUAGE: 'content-language',
		SET_COOKIE: 'set-cookie',
		STATUS_CODE: 'x-status-code',
		RESPONSE_TIME: 'x-response-time'
	},
	statusMessages: http.STATUS_CODES,

	router: null,
	request: null,
	statusCode: 200,
	headers: null,
	body: undefined,
	bodyPrepared: false,
	waitCount: 0,

	new: function(response, router){
		return Object.prototype.new.call(response.supplement(this), router);
	},

	init: function(router){
		this.router = router;
		this.request = router.request;
		this.headers = {};
	},

	error: function(error){
		this.router.next(error);
	},

	next: function(error){
		this.router.next(error);
	},

	hasHeader: function(name){
		return name in this.headers;
	},

	getHeader: function(name){
		return this.headers[name];
	},

	/*
	setHeader: function(name, value){
		this.headers[name] = value;
		return this;
	},
	*/

	prepareHeaders: function(done){
		done();
	},

	removeHeader: function(name){
		delete this.headers[name];
		return this;
	},

	stringifyObject: function(object){
		return JSON.stringify(object);
	},

	get length(){
		return this.hasHeader('content-length') ? parseInt(this.getHeader('content-length'), 10) : 0;
	},

	set length(length){
		this.setHeader('content-length', length);
	},

	// tention ServerResponse.write va appeller les implicit headers donc faut que tous les headers soit set avant
	write: function(chunk, encoding){
		this.emit('write', chunk, encoding);
		return ServerResponse.write.call(this, chunk, encoding);	
	},

	wait: function(fn, bind){
		bind = bind || this;

		this.waitCount++;
		fn.call(bind, function(){
			// ce qu'on devait faire est terminé on peut appelé end
			this.waitCount--;
			if( this.waitCount === 0 ){
				this.end();
			}
		}.bind(this));
	},

	end: function(){
		return ServerResponse.end.call(this);

		/*
		if( this.headersSent ){
			return this.request.socket.destroy();
		}
		*/

		if( this.headersPrepared === false ){
			this.headersPrepared = true;
			this.wait(this.prepareHeaders);
			return;
		}

		if( this.hasOwnProperty('body') && this.body instanceof Error ){
			this.error(this.body);
			return;
		}

		// AJAX request need a 200 statusCode to read the response, error status are put in a specific header
		// NOTE: vraiment besoin de ça?
		if( this.statusCode < 200 && this.statusCode >= 400 && this.request.isAjax() ){
			this.setHeader(this.HEADERS.STATUS_CODE, this.statusCode);
			this.statusCode = 200;
		}		
		
		if( this.hasOwnProperty('body') && this.hasHeader('content-length') === false ){
			// there is a body without content-length header, tell that to the browser
			this.setHeader('transfer-encoding', 'chunked');
			this.setHeader('accept-ranges', 'bytes');
		}

		this.emit('header');

		var name, headers;
		headers = this.headers;
		for( name in headers ){
			ServerResponse.setHeader.call(this, name, headers[name]);
		}

		if( this.request.is('head') === false && this.hasOwnProperty('body') ){
			// handle response error (response is a writable stream able to emit errors)
			// ok mais qu'est ce qu'on fait dans ce cas là puisque les headers seront envoyés?
			// this.on('error', this.error);
			this.write(this.body);
		}

		this.emit('end');
		return ServerResponse.end.call(this);
	},

	getStatusDescription: function(status){
		return status in this.statusMessages ? this.statusMessages[status] : null;
	},

	toString: function(){
		var headers = this.headers, headerString = '', str;

		Object.keys(headers).forEach(function(k){
			headerString += k + ': ' + headers[k] + '\n';
		});

		str = this.sprintf('HTTP/1.1 %s %s\n%s', this.statusCode, this.getStatusDescription(this.statusCode), headerString);

		return str;
	}
};

module.exports = Response;