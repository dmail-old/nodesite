/*

Route the request, response couple to a response

TODO : handle children errors

*/

function escapeHTML(html){
	return String(html).replace(/&(?!\w+;)/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

require('object/define');
var proto = require('proto');
var debug = require('debug');
require('promise/route');
require('promise/from');

/*
application of express example http://expressjs.com/guide/error-handling.html

function logErrors(handler, error){
	console.error(err.stack);
	return Promise.reject(error);
}
function clientErrorHandler(handler, error){
	if( handler.xhr ){
		return {
			statusCode: 500,
			body: {error: 'Something blew up!'}
		};
	}
	return Promise.reject(error);
}

function errorHandler(handler, error){
	return {
		statusCode: 500,
		body: {error: 'Something blew up!'}
	}
}

Promise.route([
	function(name){
		throw 'world';
	},
	logErrors,
	clientErrorHandler,
	errorHandler
], null, {xhr: false}).then(function(value){
	// 'world' error has been logged and value is the result of errorHandler
});

*/

var RequestHandler = proto.create({
	request: null,
	response: null,
	index: 0,
	router: null,
	fileSystem: require('fs'), // we will wrap all methods to measure request fileSystem calls
	//database: require('db'),

	constructor: function(router, request, response){
		if( !(this instanceof this.constructor) ) throw new Error('new needed');

		this.router = router;
		this.request = request;
		this.response = response;
		request.handler = this;
		response.handler = this;
	},

	isErrorTraceAllowed: function(){
		return this.allowErrorTrace || (this.request.user && this.request.user.level == 1);
	},

	formatError: function(error){
		var object = {
			name: error.name,
			message: error.message
		};

		if( this.isErrorTraceAllowed(error) ){
			object.stack = error.stack;
		}

		for(var prop in error) object[prop] = error[prop];

		return object;
	},

	// default error handler, here we try to use as much as possible native methods
	createErrorPromise: function(error){
		var request = this.request.getSourceObject(), status = 500;
		var accept = request.headers['accept'] || '';

		if( error.status ) status = error.status;

		// html
		if( ~accept.indexOf('html') ){
			var fs = require('fs'), self = this;

			return Promise.all([
				Promise.from(function(complete){
					fs.readFile(__dirname + '/error.css', 'utf8', complete);
				}),
				Promise.from(function(complete){
					fs.readFile(__dirname + '/error.html', 'utf8', complete);
				})
			]).then(function(values){
				var style = values[0], html = values[1], stack = error.stack || '';

				stack = stack.split('\n').slice(1);
				stack = stack.map(function(value){ return '<li>' + value + '</li>'; }).join('');

				html = html.replace('{style}', style);
				html = html.replace('{stack}', stack);
				html = html.replace('{title}', 'Error');
				html = html.replace('{statusCode}', status);
				html = html.replace(/\{error\}/g, escapeHTML(error.toString()).replace(/\n/g, '<br/>'));

				return {
					statusCode: status,
					headers: {
						'content-type': 'text/html;charset=utf-8',
						'content-length': Buffer.byteLength(html)
					},
					body: html
				};
			});
		}

		// json
		if( ~accept.indexOf('json') ){
			var object = this.formatError(error);
			var json = JSON.stringify({error: object});

			return {
				statusCode: status,
				headers: {
					'content-type': 'application/json',
					'content-length': Buffer.byteLength(json)
				},
				body: json
			};
		}

		// plain text
		var text = error.stack;
		return {
			statusCode: status,
			headers: {
				'content-type': 'text/plain',
				'content-length': Buffer.byteLength(text)
			},
			body: text
		};
	},

	createPromise: function(){
		var middlewares = this.router.middlewares.map(function(middleware){
			if( typeof middleware == 'function' ){
				return middleware;
			}
			else if( typeof middleware == 'object' ){
				return middleware.handle.bind(middleware);
			}
		});
		var p = Promise.route(middlewares, null, this);

		p = p.then(function(value){
			if( value === null ) return 501; // not implemented
			return value;
		}).catch(function(error){
			return this.createErrorPromise(error);
		}.bind(this));

		return p;
	}
});

function requireWithoutCache(path){
	path = require.resolve(path);
	delete require.cache[path];
	return require(path);
}

var Router = proto.create({
	Request: null,
	Response: null,
	middlewares: null,
	allowErrorTrace: false,
	RequestHandler: RequestHandler,
	METHODS: {
		OPTIONS: 'OPTIONS',
		HEAD: 'HEAD',
		GET: 'GET',
		POST: 'POST',
		PUT: 'PUT',
		DELETE: 'DELETE'
	},
	HEADERS: {
		STATUS_CODE: 'x-status-code',
		RESPONSE_TIME: 'x-response-time',
		REQUESTED_WITH: 'x-requested-with'
	},
	PARAMS: {

	},
	HEADER_VALUES: {
		AJAX: 'xmlhttprequest'
	},

	constructor: function(options){
		this.middlewares = [];
		this.Request = requireWithoutCache('./Request');
		this.Response = requireWithoutCache('./Response');
		if( options ) Object.define(this, options);
	},

	get: function(name){
		var middleware;

		if( typeof name === 'string' ) middleware = require('./middleware/' + name);
		else if( typeof name == 'function' ) middleware = {handle: name};
		else if( typeof name === 'object' ) middleware = name;

		if( typeof middleware != 'object' ){
			throw new TypeError('a middleware must be a function or an object ' + middleware + ' given');
		}

		return middleware;
	},

	has: function(middleware){
		return this.middlewares.indexOf(this.get(middleware)) !== -1;
	},

	use: function(middleware){
		middleware = this.get(middleware);

		if( middleware.requires ){
			var dependencies = middleware.requires, i = 0, j, dependency;
			if( typeof dependencies == 'string' ) dependencies = [dependencies];
			j = dependencies.length;

			for(;i<j;i++){
				dependency = dependencies[i];
				if( !this.has(dependency) ){
					throw new Error('this middleware require the ' + dependency + ' middleware');
				}
			}
		}

		if( middleware.request ){
			proto.define(this.Request, middleware.request);
		}
		if( middleware.response ){
			proto.define(this.Response, middleware.response);
		}
		if( middleware.use ){
			middleware.use.apply(middleware, [this].concat(Array.prototype.slice.call(arguments, 1)));
		}

		this.middlewares.push(middleware);

		return this;
	},

	createRequestHandler: function(request, response){
		request = new this.Request(request);
		response = new this.Response(response);

		request.response = response;
		response.request = request;

		var handler = new RequestHandler(this, request, response);

		//request.on('error', handler.next.bind(handler));
		//response.on('error', handler.next.bind(handler));

		return handler;
	}
});

module.exports = Router;