/*

Route the request, response couple to a response

TODO : handle children errors

*/

function escapeHTML(html){
	return String(html).replace(/&(?!\w+;)/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

require('Object.define');
var proto = require('proto');

var RequestHandler = proto.create({
	request: null,
	response: null,
	index: 0,
	lastError: null,
	router: null,
	fileSystem: require('fs'), // we will wrap all methods to measure request fileSystem calls
	//database: require('db'),

	constructor: function(router, request, response){
		if( !(this instanceof this.constructor) ) throw new Error('new needed');

		this.router = router;
		this.request = request;
		this.response = response;
		request.handler = this;
		response.handler = this;
	},

	isErrorTraceAllowed: function(){
		return this.allowErrorTrace || (this.request.user && this.request.user.level == 1);
	},

	formatError: function(error){
		var object = {
			name: error.name,
			message: error.message
		};

		if( this.isErrorTraceAllowed(error) ){
			object.stack = error.stack;
		}

		for(var prop in error) object[prop] = error[prop];

		return object;
	},

	// default error handler, here we try to use as much as possible native methods
	handleError: function(error){
		var request = this.request.getSourceObject(), response = this.response.getSourceObject(), status = 500;
		var accept = request.headers['accept'] || '';

		if( error.status ) status = error.status;

		// html
		if( ~accept.indexOf('html') ){
			var fs = require('fs'), self = this;
			fs.readFile(__dirname + '/error.css', 'utf8', function(e, style){
				fs.readFile(__dirname + '/error.html', 'utf8', function(e, html){
					var stack = error.stack || '';

					stack = stack.split('\n').slice(1);
					stack = stack.map(function(value){ return '<li>' + value + '</li>'; }).join('');

					html = html.replace('{style}', style);
					html = html.replace('{stack}', stack);
					html = html.replace('{title}', 'Error');
					html = html.replace('{statusCode}', status);
					html = html.replace(/\{error\}/g, escapeHTML(error.toString()).replace(/\n/g, '<br/>'));

					response.statusCode = status;
					response.setHeader('content-type', 'text/html;charset=utf-8');
					response.setHeader('content-length', Buffer.byteLength(html));
					response.write(html);
					response.end();
				});
			});
		}
		// json
		else if( ~accept.indexOf('json') ){
			var object = this.formatError(error);
			var json = JSON.stringify({error: object});

			response.statusCode = status;
			response.setHeader('content-type', 'application/json');
			response.setHeader('content-length', Buffer.byteLength(json));
			response.write(json);
			response.end();
		}
		// plain text
		else{
			var text = error.stack;

			response.statusCode = status;
			response.setHeader('content-type', 'text/plain');
			response.setHeader('content-length', Buffer.byteLength(text));
			response.write(text);
			response.end();
		}

		console.error(error.stack);
	},

	// default handler
	handle: function(){
		var response = this.response.getSourceObject();

		response.writeHead(501, 'Not implemented');
		response.end();
	},

	next: function(error){
		/*
		an example of context where error has children errors :

		router.use(function(){
			var fooError = new TypeError('foo');
			throw fooError;
		});
		// this is supposed to be an error handler, but it's throwing also an error :s
		router.use(function(router, error){
			var barError =  new Error('bar');
			throw barError;
		});

		handleError will receive barError with barError.parentError = fooError;
		*/

		// there is an error that need to be handled
		if( this.lastError ){
			var lastError = this.lastError;
			// an other error occured
			if( error && lastError != error ){
				lastError.children = lastError.children || [];
				lastError.children.push(error);
			}
			error = lastError;
		}

		var middlewares, middleware, handler, bind, index;

		middlewares = this.router.middlewares;
		index = this.index;

		// no matching handler, call defaultHandler
		if( index >= middlewares.length ){
			if( !error.stack ) throw error;

			// catch defaultHandler error
			try{
				if( error ){
					this.handleError(error);
				}
				else{
					this.handle();
				}
			}
			catch(e){
				// nothing could handle the error without creating an error
				// just send 500: Server Internal error
				try{
					var response = this.response.getSourceObject();

					response.writeHead(500, 'Server Internal error');
					response.end();

					console.log('default handler error', e.stack);
				}
				// when even the above fails, throw
				catch(e){
					throw e;
				}
			}
			return;
		}

		middleware = middlewares[index];
		index = ++this.index;

		if( typeof middleware == 'function' ){
			handler = middleware;
			bind = handler;
		}
		else if( typeof middleware == 'object' ){
			handler = middleware.handle;
			bind = middleware;
		}

		if( typeof handler === 'function' ){
			if( error ){
				if( handler.length === 4 ){
					this.lastError = error;

					// catch errorHandler error
					try{
						handler.call(bind, this.request, this.response, this, error);
					}
					catch(e){
						this.next(e);
					}
				}
				else{
					this.next(error);
				}
			}
			else{
				// catch handler error
				try{
					if( this.router.debug ){
						console.log('calling middleware ' + middleware.name);
					}
					handler.call(bind, this.request, this.response, this);
				}
				catch(e){
					this.next(e);
				}
			}
		}
		// else this.next(); ??
	}
});

function requireWithoutCache(path){
	path = require.resolve(path);
	delete require.cache[path];
	return require(path);
}

var Router = proto.create({
	debug: true,
	Request: null,
	Response: null,
	middlewares: null,
	allowErrorTrace: false,
	RequestHandler: RequestHandler,
	METHODS: {
		OPTIONS: 'OPTIONS',
		HEAD: 'HEAD',
		GET: 'GET',
		POST: 'POST',
		PUT: 'PUT',
		DELETE: 'DELETE'
	},
	HEADERS: {
		STATUS_CODE: 'x-status-code',
		RESPONSE_TIME: 'x-response-time',
		REQUESTED_WITH: 'x-requested-with'
	},
	PARAMS: {

	},
	HEADER_VALUES: {
		AJAX: 'xmlhttprequest'
	},

	constructor: function(options){
		this.middlewares = [];
		this.Request = requireWithoutCache('./Request');
		this.Response = requireWithoutCache('./Response');
		if( options ) Object.define(this, options);
	},

	get: function(name){
		var middleware;

		if( typeof name === 'string' ) middleware = require('./middleware/' + name);
		else if( typeof name == 'function' ) middleware = {handle: name};
		else if( typeof name === 'object' ) middleware = name;

		if( typeof middleware != 'object' ){
			throw new TypeError('a middleware must be a function or an object ' + middleware + ' given');
		}

		return middleware;
	},

	has: function(middleware){
		return this.middlewares.indexOf(this.get(middleware)) !== -1;
	},

	use: function(middleware){
		middleware = this.get(middleware);

		if( middleware.requires ){
			var dependencies = middleware.requires, i = 0, j, dependency;
			if( typeof dependencies == 'string' ) dependencies = [dependencies];
			j = dependencies.length;

			for(;i<j;i++){
				dependency = dependencies[i];
				if( !this.has(dependency) ){
					throw new Error('this middleware require the ' + dependency + ' middleware');
				}
			}
		}

		if( middleware.request ){
			proto.define(this.Request, middleware.request);
		}
		if( middleware.response ){
			proto.define(this.Response, middleware.response);
		}
		if( middleware.use ){
			middleware.use.apply(middleware, [this].concat(Array.prototype.slice.call(arguments, 1)));
		}

		this.middlewares.push(middleware);

		return this;
	},

	createRequestHandler: function(request, response){
		request = this.Request.new(request);
		response = this.Response.new(response);

		request.response = response;
		response.request = request;

		var handler = new RequestHandler(this, request, response);

		request.on('error', handler.next.bind(handler));
		response.on('error', handler.next.bind(handler));

		return handler;
	}
});

module.exports = Router;