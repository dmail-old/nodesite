/*

Route the request, response couple to a response

*/

function escapeHTML(html){
	return String(html).replace(/&(?!\w+;)/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

var proto = require('proto');

var Router = {
	Request: require('./Request'),
	Response: require('./Response'),

	middlewares: [],
	allowErrorTrace: false,
	METHODS: {
		OPTIONS: 'OPTIONS',
		HEAD: 'HEAD',
		GET: 'GET',
		POST: 'POST',
		PUT: 'PUT',
		DELETE: 'DELETE'
	},
	HEADERS: {
		STATUS_CODE: 'x-status-code',
		RESPONSE_TIME: 'x-response-time',
		REQUESTED_WITH: 'x-requested-with'
	},
	PARAMS: {
		
	},
	HEADER_VALUES: {
		AJAX: 'xmlhttprequest'
	},
	
	mid: function(name){
		return require('./middleware/' + name);
	},

	use: function(middleware){
		if( typeof middleware == 'string' ){
			middleware = require('./middleware/' + middleware);
		}

		if( typeof middleware == 'function' ){
			middleware = {
				handle: middleware
			};
		}
		
		if( typeof middleware == 'object' ){
			if( middleware.request ){
				proto.define(this.Request, middleware.request);
			}
			if( middleware.response ){
				proto.define(this.Response, middleware.response);
			}
			if( middleware.use ){
				middleware.use(this, Array.prototype.slice.call(arguments, 1));
			}

			this.middlewares.push(middleware);
		}
		else{
			throw new TypeError('a middleware must be a function or an object ' + middleware + ' given');
		}

		return this;
	},

	createRequestHandler: function(request, response){
		request = this.Request.new(request);
		response = this.Response.new(response);

		request.response = response;
		response.request = request;

		var handler = new RequestHandler(request, response);

		request.on('error', handler.next.bind(handler));
		response.on('error', handler.next.bind(handler));
		
		return handler;
	}
};

var RequestHandler = proto.create({
	request: null,
	response: null,
	index: 0,
	lastError: null,

	constructor: function(request, response){
		this.request = request;
		this.response = response;
	},

	isErrorTraceAllowed: function(){
		return this.allowErrorTrace || (this.request.user && this.request.user.level == 1);
	},

	formatError: function(error){
		var object = {
			name: error.name,
			message: error.message
		};

		if( this.isErrorTraceAllowed(error) ){
			object.stack = error.stack;
		}

		for(var prop in error) object[prop] = error[prop];

		return object;
	},

	// default error handler, here we try to use as much as possible native methods
	handleError: function(error){
		var request = this.request.getSourceObject(), response = this.response.getSourceObject(), status = 500;

		if( error.status ) status = error.status;
		console.error(error.stack);

		var accept = request.headers['accept'] || '';

		// html
		if( ~accept.indexOf('html') ){
			var fs = require('fs'), self = this;
			fs.readFile(__dirname + '/error.css', 'utf8', function(e, style){
				fs.readFile(__dirname + '/error.html', 'utf8', function(e, html){
					var stack = error.stack || '';

					stack = stack.split('\n').slice(1);
					stack = stack.map(function(value){ return '<li>' + value + '</li>'; }).join('');

					html = html.replace('{style}', style);
					html = html.replace('{stack}', stack);
					html = html.replace('{title}', 'Error');
					html = html.replace('{statusCode}', status);
					html = html.replace(/\{error\}/g, escapeHTML(error.toString()).replace(/\n/g, '<br/>'));

					response.statusCode = status;
					response.setHeader('content-type', 'text/html;charset=utf-8');
					response.setHeader('content-length', Buffer.byteLength(html));
					response.write(html);
					response.end();
				});
			});
		}
		// json
		else if( ~accept.indexOf('json') ){
			var object = this.formatError(error);
			var json = JSON.stringify({error: object});

			response.statusCode = status;
			response.setHeader('content-type', 'application/json');
			response.setHeader('content-length', Buffer.byteLength(json));
			response.write(json);
			response.end();
		}
		// plain text
		else{
			var text = error.stack;

			response.statusCode = status;
			response.setHeader('content-type', 'text/plain');
			response.setHeader('content-length', Buffer.byteLength(text));
			response.write(text);
			response.end();
		}
	},

	// default handler
	handle: function(){
		var response = this.response.getSourceObject();

		response.writeHead(501, 'Not implemented');
		response.end();
	},

	next: function(error){
		/*
		an example of context where parentError occur:
		
		router.use(function(){
			var fooError = new TypeError('foo');
			throw fooError;
		});
		// this is supposed to be an error handler, but it's throwing also an error :s
		router.use(function(router, error){
			var barError =  new Error('bar');
			throw barError;
		});

		handleError will receive barError with barError.parentError = fooError;
		*/

		// there is an error that need to be handled
		if( this.lastError ){
			// moreover an other error occured
			if( error && this.lastError != error ){
				error.parentError = this.lastError;
			}
			else{
				error = this.lastError;
			}
		}

		var middlewares, middleware, handler, bind, index;

		middlewares = Router.middlewares;
		index = this.index;

		// no matching handler, call defaultHandler
		if( index >= middlewares.length ){
			// catch defaultHandler error
			try{
				if( error ){				
					this.handleError(error);
				}
				else{
					this.handle();
				}
			}
			catch(e){
				// nothing could handle the error without creating an error
				// just send 500: Server Internal error
				console.log('default handler error', e.stack || e);
				this.response.writeHead(500, 'Server Internal error');
				this.response.end();
			}
			return;
		}

		middleware = middlewares[index];
		index = ++this.index;

		if( typeof middleware == 'function' ){
			handler = middleware;
			bind = handler;
		}
		else if( typeof middleware == 'object' ){
			handler = middleware.handle;
			bind = middleware;
		}

		if( typeof handler === 'function' ){
			if( error ){
				if( handler.length === 4 ){
					this.lastError = error;

					// catch errorHandler error
					try{
						handler.call(bind, this.request, this.response, this, error);
					}
					catch(e){
						this.next(e);
					}
				}
				else{
					this.next(error);
				}
			}
			else{
				// catch handler error
				try{
					handler.call(bind, this.request, this.response, this);
				}			
				catch(e){
					this.next(e);
				}
			}
		}
		// else this.next(); ??
	}
});

module.exports = Router;