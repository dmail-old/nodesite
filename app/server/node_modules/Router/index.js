/*

Route the request, response couple to a response

*/

function escapeHTML(html){
	return String(html).replace(/&(?!\w+;)/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

var property = require('property');

var Router = {
	Request: require('./Request'),
	Response: require('./Response'),
	originalRequest: null,
	originalResponse: null,
	request: null,
	response: null,

	index: 0,
	middleware: null,
	middlewares: [],
	error: null,
	allowErrorTrace: false,
	
	new: function(request, response){
		this.originalRequest = request;
		this.originalResponse = response;				
		this.request = this.Request.new(request, this);
		this.response = this.Response.new(response, this);
		
		this.request.response = this.response;
		this.response.request = this.request;

		if( this.request.is('head') ){
			this.response.write = function(){
				console.warn('HEAD request expect empty body, write call ignored');
				return true;
			};
		}

		return this;
	},

	mid: function(name){
		return require('./middleware/' + name);
	},

	use: function(middleware){
		if( typeof middleware == 'string' ){
			middleware = require('./middleware/' + middleware);
		}

		if( typeof middleware == 'function' ){
			middleware = {
				handle: middleware
			};
		}
		
		if( typeof middleware == 'object' ){
			if( middleware.request ){
				Object.assign(this.Request, middleware.request);
			}
			if( middleware.response ){
				Object.assign(this.Response, middleware.response);
			}
			if( middleware.use ){
				middleware.use(this, Array.slice(arguments, 1));
			}

			this.middlewares.push(middleware);
		}
		else{
			throw new TypeError('a middleware must be a function or an object ' + middleware + ' given');
		}

		return this;
	},

	isErrorTraceAllowed: function(){
		return this.allowErrorTrace || (this.request.user && this.request.user.level == 1);
	},

	formatError: function(error){
		var object = {
			name: error.name,
			message: error.message
		};

		if( this.isErrorTraceAllowed(error) ){
			object.stack = error.stack;
		}

		for(var prop in error) object[prop] = error[prop];

		return object;
	},

	// default error handler, here we try to use as much as possible native methods
	handleError: function(error){
		var request = this.originalRequest, response = this.originalResponse, status = 500;

		if( error.status ) status = error.status;
		console.error(error);

		var accept = request.headers['accept'] || '';

		// html
		if( ~accept.indexOf('html') ){
			var fs = require('fs'), self = this;
			fs.readFile(__dirname + '/error.css', 'utf8', function(e, style){
				fs.readFile(__dirname + '/error.html', 'utf8', function(e, html){
					var stack = error.stack || '';

					stack = stack.split('\n').slice(1);
					stack = stack.map(function(value){ return '<li>' + value + '</li>'; }).join('');

					html = html.replace('{style}', style);
					html = html.replace('{stack}', stack);
					html = html.replace('{title}', 'Error');
					html = html.replace('{statusCode}', status);
					html = html.replace(/\{error\}/g, escapeHTML(error.toString()).replace(/\n/g, '<br/>'));

					response.statusCode = status;
					response.setHeader('content-type', 'text/html;charset=utf-8');
					response.setHeader('content-length', Buffer.byteLength(html));
					response.write(html);
					response.end();
				});
			});
		}
		// json
		else if( ~accept.indexOf('json') ){
			var object = this.formatError(error);
			var json = JSON.stringify({error: object});

			response.statusCode = status;
			response.setHeader('content-type', 'application/json');
			response.setHeader('content-length', Buffer.byteLength(json));
			response.write(json);
			response.end();
		}
		// plain text
		else{
			var text = error.stack;

			response.statusCode = status;
			response.setHeader('content-type', 'text/plain');
			response.setHeader('content-length', Buffer.byteLength(text));
			response.write(text);
			response.end();
		}
	},

	// default handler
	handle: function(){
		var response = this.originalResponse;

		response.writeHead(501, 'Not implemented');
		response.end();
	},

	next: function(error){
		/*
		an example of context where parentError occur:
		
		router.use(function(){
			var fooError = new TypeError('foo');
			throw fooError;
		});
		// this is supposed to be an error handler, but it's throwing also an error :s
		router.use(function(router, error){
			var barError =  new Error('bar');
			throw barError;
		});

		handleError will receive barError with barError.parentError = fooError;
		*/

		// there is an error that need to be handled
		if( this.error ){
			// moreover an other error occured
			if( error && this.error != error ){
				error.parentError = this.error;
			}
			else{
				error = this.error;
			}
		}

		var middlewares, middleware, handler, bind, index;

		middlewares = this.middlewares;
		index = this.index;

		// no matching handler, call defaultHandler
		if( index >= middlewares.length ){
			// catch defaultHandler error
			try{
				if( error ){				
					this.handleError(error);
				}
				else{
					this.handle();
				}
			}
			catch(e){
				// nothing could handle the error without creating an error
				// just send 500: Server Internal error
				console.log('default handler error', e.stack || e);
				this.response.writeHead(500, 'Server Internal error');
				this.response.end();
			}
			return;
		}

		middleware = this.middleware = middlewares[index];
		index = ++this.index;

		if( typeof middleware == 'function' ){
			handler = middleware;
			bind = handler;
		}
		else if( typeof middleware == 'object' ){
			handler = middleware.handle;
			bind = middleware;
		}

		if( typeof handler === 'function' ){		
			if( error ){
				if( handler.length === 2 ){
					this.error = error;

					// catch error handler error
					try{
						handler.call(bind, this, error);
					}
					catch(e){
						this.next(e);
					}
				}
				else{
					this.next(error);
				}
			}
			else{
				// catch handler error
				try{
					handler.call(bind, this);
				}			
				catch(e){
					this.next(e);
				}
			}
		}
	},

	start: function(){
		this.next();
	}
};

module.exports = Router;