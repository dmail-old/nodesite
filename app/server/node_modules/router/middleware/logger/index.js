/*

Response is missing the connection keep alive and transfer encoding chunked headers
because of this
https://github.com/joyent/node/blob/master/lib/_http_outgoing.js#L261

*/

var StringTemplate = require('StringTemplate');
var ConsoleTemplate = require('LogStream/Log/ConsoleTemplate');
var TableTemplate = require('TableTemplate');
var debug = require('debug');

module.exports = {
	name: 'logger',

	properties: {
		logRequest: true,
		logRequestBody: true,
		logRequestBodyMaxLength: 100,
		logRequestTemplate: '{method} {url} HTTP/{httpVersion}\n{headers}{body}',

		getRequestLogScope: function(){
			var request = this.request, table = new TableTemplate();

			table.addRows(Object.keys(request.headers || {}).map(function(name){
				return [name, request.headers[name]];
			}, this));
			table.className = 'headless';
			table.defineClass('headerName', ['bold', 'grey']);
			table.column(0).setWidth(20).setClass('headerName');

			var headerString = table.toString();

			return {
				method: request.method.toUpperCase(),
				url: String(request.url),
				httpVersion: request.httpVersion,
				headers: headerString
			};
		},

		logResponse: true,
		logResponseBody: true,
		logResponseBodyMaxLength: 100,
		logResponseTemplate: '{status} {statusMessage} HTTP/1.1\n{headers}{body}',

		getStatusStyle: function(){
			var status = this.statusCode;

			if( status >= 500 ){
				return 'red';
			}
			if( status >= 400 ){
				return 'yellow';
			}
			if( status >= 300 ){
				return 'cyan';
			}
			if( status >= 200 ){
				return 'green';
			}
			return 'inherit';
		},

		getResponseLogScope: function(response){
			var table = new TableTemplate();

			table.addRows(Object.keys(response.headers).map(function(name){
				return [name, response.headers[name]];
			}, this));

			table.className = 'human';
			table.defineClass('headerName', ['bold', 'grey']);
			table.column(0).setWidth(20).setClass('headerName');
			table.sortRows(0, 1);

			var headerString = table.toString();

			return {
				status: response.status,
				statusMessage: require('http').STATUS_CODES[response.status] || 'unknown',
				headers: headerString
			};
		}
	},

	use: function(router, logger){
		if( logger ){
			router.RequestHandler.prototype.logger = logger;
		}
	},

	task: function(handler){
		var request = handler.request, logger = handler.logger;

		// request-body has consumed the body streama
		// non parsed body is ignored because of if( mediaType && mediaType in request.parsers )
		if( handler.logRequest ){
			var scope = handler.getRequestLogScope();
			var body;

			if( request.hasBody() && request.rawBody ){
				body = request.rawBody;
				if( body.length > handler.logRequestBodyMaxLength ){
					body = body.slice(0, handler.logRequestBodyMaxLength) + '...';
				}
			}
			else{
				body = '';
			}
			scope.body = body.length ? '\n' + body : '';

			logger.log(handler.logRequestTemplate, scope, {
				method : 'magenta'
			});
		}

		if( handler.logResponse ){
			// when the response is ready
			handler.promise.then(function(response){
				debug('creating response log');

				var scope = handler.getResponseLogScope(response);

				Promise.resolve(handler.logResponseBody ? response.createBodyPromise() : '').then(function(body){
					debug('response body resolved');

					if( body.length > handler.logResponseBodyMaxLength ){
						body = body.slice(0, handler.logResponseBodyMaxLength) + '...';
					}
					scope.body = body.length ? '\n' + body : '';

					logger.log(handler.logResponseTemplate, scope, {
						status: handler.getStatusStyle(response.status),
						time: 'grey',
						body: 'grey'
					});
					return response;
				});
			});
		}
	}
};