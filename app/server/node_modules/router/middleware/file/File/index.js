var debug = require('debug');
var proto = require('@dmail/proto');
var Path = require('path');
require('promise/from');

var File = proto.extend({
	fileSystem: require('fs'),
	path: null,
	modifiedSince: null,
	acceptGzip: null,
	stat: null,
	aliases: [],
	aliasIndex: 0,
	alias: null,

	constructor: function(path){
		this.path = this.originalPath = Path.normalize(path);
		this.result = {};
	},

	isModified: function(mtime){
		return this.modifiedSince ? mtime > this.modifiedSince : true;
	},

	isNotFoundError: function(error){
		return error.code == 'ENOENT'; // && error.errno == 34 || error.errno = -4058;
	},

	getStat: function(path){
		return Promise.from(function(complete){
			this.fileSystem.stat(path, complete);
		}, this);
	},

	nextAlias: function(){
		var aliases = this.aliases;

		if( aliases.length === 0 ) return null;
		if( this.aliasIndex >= aliases.length ) return null;
		return aliases[this.aliasIndex++].create(this);
	},

	nextPossibleAlias: function(){
		var alias;

		while( (alias = this.nextAlias()) && alias.handle() );

		return alias;
	},

	sendAliasElseFile: function(){
		this.path = this.originalPath;
		this.alias = this.nextPossibleAlias();

		var promise;

		if( this.alias ){
			this.path = this.alias.getPath(this.path);
			promise = this.getStat(this.path);
			debug('trying to serve alias at', this.path);

			promise = promise.catch(function(error){
				if( this.isNotFoundError(error) ){
					return this.sendAliasElseFile();
				}
				return Promise.reject(error);
			}.bind(this));
		}
		else{
			debug('trying to serve file at', this.path);

			promise = this.getStat(this.path);
		}

		return promise.then(function(stat){
			debug('file stat found');

			// seul les fichiers sont autorisé
			if( !stat.isFile() ){
				debug(this.path, 'is not a file');
				return 403;
			}
			if( this.modifiedSince ){
				debug('file is modified since ?',  stat.mtime, '>',
					this.modifiedSince, stat.mtime > this.modifiedSince);
			}
			// dit au navigateur que le fichier n'a pas changé
			if( !this.isModified(stat.mtime) ){
				debug('file not modified');
				return 304;
			}

			debug('serving file...');

			return {
				status: 200,
				headers: {
					'content-type': config.getMimetype(this.originalPath),
					'last-modified': new Date(), //stat.mtime.toUTCString(),
					'content-length': stat.size,
					// évite que chrome mette en cache et réutilise sans redemander au serveur
					// les fichier HTML qu'on lui envoit
					'cache-control': 'no-cache'
				},
				stream: this.fileSystem.createReadStream(this.path)
			};
		}.bind(this)).catch(function(error){
			debug('file stat failed', error);

			if( error && this.isNotFoundError(error) ) return 404;
			return Promise.reject(error);
		}.bind(this));
	},

	createPromise: function(){
		return this.sendAliasElseFile();
	}
});

module.exports = File;