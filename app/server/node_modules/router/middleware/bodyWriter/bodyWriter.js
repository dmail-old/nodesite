/*

Reste à faire le remplissage auto des headers
pour content-language, content-encoding, content-type
la mécanique de quand et comment on les remplis et puis ca seras bon en théorie

*/

var http = require('http');
var ServerResponse = http.ServerResponse;

var BodyWriter = {	
	response: null,
	autoEnd: true, // call end() when populate() is called

	init: function(response){
		this.response = response;
	},

	populateHeaders: function(){
		// status code 204 et 304 pas besoin de certain headers (not modified and no content)
		// https://github.com/mcavage/node-restify/blob/master/lib/response.js#L268
		var contentType, type, charset, parts;

		if( this.hasHeader('content-type') ){
			contentType = this.getHeader('content-type');
		}
		else{
			contentType = this.getDefault('content-type');
		}

		parts = this.ContentType.parse(contentType);

		this.type = parts[0];
		this.charset = this.ContentType.isTextual(this.type) ? parts[1] : null;

		if( this.charset ){
			if( this.hasHeader('content-language') ){
				this.language = this.getHeader('content-language');
			}
			else{
				// TODO, auto language
			}
		}

		if( this.hasHeader('content-encoding') ){
			this.encoding = this.getHeader('content-encoding');
		}
		else{
			// TODO, auto encoding
		}		
	},

	getDefault: function(headerName){
		var accepteds = this.getAccepteds(headerName), i = 0, j = accepteds.length, value;

		for(;i<j;i++){
			value = accepteds[i];
			if( this.isValidHeader(headerName, value) ){
				return value;
			}
		}

		return this.getDefault(headerName);
	},	

	validHeaders: function(){
		if( !this.request.accept('mediaType', this.type) ){
			this.headerError = this.createHeaderAcceptError('type', this.type);
			return false;
		}

		if( this.charset ){
			if( !this.validHeader('charset', this.charset) ){
				this.headerError = this.createHeaderValueError('charset', this.charset);
				return false;
			}
			if( !this.request.accept('charset', this.charset) ){
				this.headerError = this.createHeaderAcceptError('charset', this.charset);
				return false;
			}
		}

		if( this.encoding ){
			if( !this.validHeader('encoding', this.encoding) ){
				this.headerError = this.createHeaderValueError('encoding', this.encoding);
				return false;
			}
			if( !this.request.accept('encoding', this.encoding) ){
				this.headerError = this.createHeaderAcceptError('encoding', this.encoding);
				return false;
			}
		}

		return true;
	},

	getLength: function(body){
		return typeof body == 'string' ? Buffer.byteLength(body) : body.length;
	},

	setLength: function(body){
		if( !this.response.hasHeader('content-length') ){
			this.response.setHeader('content-length', this.getLength(body));
		}
	},

	// là c'est carrément du délire aucune idée de comment je vais pouvoir faire
	format: function(buffer){
		return buffer;
	},

	stringifyObject: function(object){
		return JSON.stringify(object);
	},

	// write body in computedStream
	writeBody: function(body){
		var computedStream = this.computedStream;

		if( global.isStream(body) ){
			// true force body to be the first stream of computedStream
			computedStream.chain(body, true);
		}
		else if( Buffer.isBuffer(body) ){
			computedStream.write(body);
			this.setLength(body);
		}	
		else if( typeof body == 'string' ){
			computedStream.write(body);
			this.setLength(body);
		}			
		else if( typeof body == 'object' ){
			if( body == null || !body.hasOwnProperty('toString') || typeof body.toString != 'function' ){
				body = String(body);
			}
			else{
				try{
					body = this.stringifyObject(body);
				}
				catch(e){
					return this.error(e);
				}
			}
			computedStream.write(body);
			this.setLength(body);
		}
	},

	end: function(){
		return this.callback.apply(this.bind, arguments);
	},

	error: function(error){
		return this.end(error);
	},

	done: function(data){
		return this.end(null, data);	
	},

	wrap: function(prefix, suffix){
		var ComputedStream = this.ComputedStream;
		var computedStream = this.computedStream;

		this.prefix = prefix;
		this.suffix = suffix;

		computedStream.write = function(){
			this.write(prefix);
			this.write = ComputedStream.write;
			return this.write.apply(this, arguments);
		};
		computedStream.end = function(){
			this.write(suffix);
			this.end = ComputedStream.end;
			return this.end.apply(this, arguments);
		};

		var setHeader = this.response.setHeader;
		var self = this;
		this.response.setHeader = function(name, value){
			if( name == 'content-length' ){
				value+= self.getLength(prefix);
				value+= self.getLength(suffix);
				this.setHeader = setHeader;
			}
			return this.setHeader.apply(this, arguments);
		};
	},

	write: function(body, callback, bind){
		this.callback = callback;
		this.bind = bind || this;

		// valid headers
		var error;
		this.headers.some(function(header){
			if( !header.valid() ){
				error = header.error;
				return true;
			}
		});
		if( error ) return this.error(error);

		// prepare a computedstream to write
		this.computedStream = new this.ComputedStream();
		this.computedStream.on('error', this.error.bind(this));

		// active headers effect
		this.headers.forEach(function(header){ header.effect(); });
		// write body in the computedStrem
		this.writeBody(body);
		// start computed stream writing
		this.computedStream.resolve();
	}
};

module.exports = {
	response: {
		type: 'text/plain',
		charset: 'utf8',
		encoding: 'identity',
		bodyWriter: null,

		populate: function(data){
			if( data ){
				if( typeof data == 'number' ){
					data = {
						statusCode: data,
						body: this.getStatusDescription(data)
					};
				}

				// je serais bien tenté ici de faire plutot un merge
				// Object.merge(this, data);
				if( data.headers ){
					Object.append(this.headers, data.headers);
				}
				if( data.statusCode ){
					this.statusCode = data.statusCode;
				}
				if( data.options ){
					Object.append(this, data.options);
				}
				if( data.body ){
					this.body = data.body;
				}
			}

			if( this.autoEnd ){
				this.end();
			}
		},

		send: function(){
			if( arguments.length == 1 ){
				if( typeof arguments[0] == 'number' ){
					this.populate(arguments[0]);
				}
				else{
					this.populate({
						body: arguments[0]
					});
				}
			}
			else if( arguments.length === 2 ){
				this.populate({
					statusCode: arguments[0],
					body: arguments[1]
				});
			}
			else{
				this.populate();
			}	
		},

		prepareBody: function(done){			
			this.bodyWriter.write(this.body, function(error, body){
				if( error ) return this.error(error);
				// body is a stream here
				this.body = body;
				done();
			}, this);
		}
	},

	handle: function(){
		this.response.bodyWriter = BodyWriter.new(this.response);
	}
};