/*

for a page at path

1. try to load a file at path ending by .page
2. try to load a file named path + '/' + index.page
3. repeat for all parent directories

examples:

resolve('/') -> 'index.page'
resolve('/index' | '/index.json')-> 'index.page' or 'index/index.page'
resolve('/user/32/edit') ->
	'user/32/edit.page' or 'user/32/edit/index.page',
	'user/32.page' or 'user/32/index.page',
	'user.page' or 'user/index.page'

*/
require('promise/from');
require('promise/first');
require('promise/mapFirst');
var proto = require('@dmail/proto');
var debug = require('debug');
var PageResolver = proto.extend({
	fileSystem: require('fs'),
	Path: require('path'),

	indexFileName: 'index',
	extension: 'page.js',
	sep: '/',

	path: null,

	constructor: function(path, relative){
		this.path = path;
		this.relative = relative;
	},

	createNotFoundError: function(){
		var error = new Error('Cannot find page \''+ this.path +'\'');
		error.code = 'PAGE_NOT_FOUND';
		return error;
	},

	isNotFoundError: function(error){
		debug('this is a not found error');
		return error && error.code === 'PAGE_NOT_FOUND';
	},

	loadAsFile: function(path){
		var extension = this.Path.extname(path);

		// remove the extension (index.json should redirect to index.page and outputs json)
		if( extension ) path = path.slice(0, path.lastIndexOf('.'));
		// add the page extension
		if( this.extension ) path+= '.' + this.extension;

		path = this.Path.join(this.relative, path);

		debug('trying to load page at ', path);

		return Promise.from(function(complete){
			this.fileSystem.stat(path, complete);
		}, this).then(
			function(stat){
				// it's a file, return the path
				if( stat.isFile() || stat.isFIFO() ){
					debug('page found at', path);
					return path;
				}
				debug('page is not a file', path);
				// it's something else
				throw this.createNotFoundError();
			}.bind(this),
			function(error){
				// file not found
				if( error.code === 'ENOENT' ){
					debug('no page at', path);
					throw this.createNotFoundError();
				}
				return Promise.reject(error);
			}.bind(this)
		);
	},

	loadAsDirectory: function(path){
		return this.loadAsFile(path + this.sep + this.indexFileName);
	},

	load: function(path){
		return Promise.first([
			this.loadAsFile,
			this.loadAsDirectory
		], this, path, this.isNotFoundError, this);
	},

	pagePaths: function(start){
		//start = start.slice(1); // remove first '/'

		var Path = this.Path, parts = start.split(this.sep), dirs, dir, i, part;

		i = parts.length - 1;
		dirs = [];
		while( i > 0 ){
			part = parts.pop();
			dir = Path.join.apply(Path, parts);
			dirs.push(dir);

			i--;
		}

		return dirs;
	},

	loadPages: function(path){
		var dirs = this.pagePaths(path);

		if( dirs.length === 0 ) return Promise.reject(this.createNotFoundError());
		return Promise.mapFirst(dirs, function(directory){
			return this.load(directory + this.Path.sep + path);
		}, this, null, this.isNotFoundError, this);
	},

	resolve: function(){
		return this.loadPages(this.path);
	}
});

module.exports = PageResolver;