/*
- auto content-language:
les fichiers non binaire (hormis fichier langue) sont tous en anglais
-> comment le navigateur gère si on précise que c'est des fichiers anglais
pour les réponses genre pages/json etc le language semble approprié par contre mais aucune idée de comment le gérer
pour le moment
-> on désactive le content-language jusqu'à ce qu'on ai à s'en occuper

- auto content-encoding:
pouvoir configurer quand et comment j'encode ce que je réponds

!!! response.charset = 'utf8' set response.mediaType et response.hasHeader('content-type') retourne true

*/

require('object/toSource');
var proto = require('proto');
var stream = require('stream');
var contentType = require('content-type');

var ResponseProperties = {
	encoders: require('./encoders'),
	converters: require('./converters'),
	//defaultMediaType: 'text/plain',
	defaultMediaType: 'application/octet-stream', // RFC2616 section 7.2.1
	defaultCharset: 'utf8', // by default data are considered using utf8 charset
	defaultEncoding: 'identity',  // by default data are considered not encoded
	defaultLanguage: 'en',
	negotiateMediaType: false, // voir comment on peut faire
	negotiateCharset: true, // mais tfaçon j'en supporte aucun autre que utf8
	negotiateEncoding: false,
	negotiateLanguage: true,

	bodyCharset: 'utf8',
	bodyEncoding: 'identity',

	get encoding(){
		return this.getHeader('content-encoding') || this.defaultEncoding;
	},

	set encoding(encoding){
		this.setHeader('content-encoding', encoding);
	},

	get mediaType(){
		if( this.hasHeader('content-type') ){
			return contentType.parse(this.getHeader('content-type'))[0];
		}
		return this.defaultMediaType;
	},

	set mediaType(mediaType){
		this.setHeader('content-type', mediaType + ';charset=' + this.charset);
	},

	get charset(){
		if( this.hasHeader('content-type') ){
			return contentType.parse(this.getHeader('content-type'))[1];
		}
		return this.defaultCharset;
	},

	set charset(charset){
		this.setHeader('content-type', this.mediaType + ';charset=' + charset);
	},

	populateContentHeaders: function(){
		if( false === this.hasHeader('content-type') && this.negotiateMediaType ){
			//this.mediaType = ;
		}

		if( false === this.hasHeader('content-type') && this.negotiateCharset ){
			//this.charset = ;
		}

		if( this.charset && false === this.hasHeader('content-language') && this.negotiateLanguage ){
			//this.language = ;
		}

		if( false === this.hasHeader('content-encoding') && this.negotiateEncoding ){
			//this.encoding = ;
		}
	},

	canConvert: function(charset){
		return charset === 'utf8' || charset in this.converters;
	},

	canEncode: function(encoding){
		return encoding === 'identity' || encoding in this.encoders;
	},

	createUnsupportedError: function(){
		return new Error('unsupported header');
	},

	validContentHeaders: function(){

		var charset = this.charset;
		if( charset ){
			if( false === this.canConvert(charset) ){
				throw this.createUnsupportedError('charset', charset);
			}
			else if( charset != 'utf8' ){
				this.removeHeader('content-length'); // must be recomputed

				var converter = this.encoders[charset].call(this);
				this.transform(converter);
			}
		}

		var encoding = this.encoding;
		if( encoding ){
			if( false === this.canEncode(encoding) ){
				throw this.createUnsupportedError('encoding', encoding);
			}
			else if( encoding != 'identity' ){
				this.removeHeader('content-length'); // must be recomputed

				var encoder = this.encoders[encoding].call(this);
				this.transform(encoder);
			}
		}
	}
};

module.exports = {
	name: 'responseNegotiation',
	requires: 'requestNegotiation',
	response: ResponseProperties,

	extend: {
		createUnacceptedError: function(){
			return new Error('unaccepted error');
		},

		acceptContentHeaders: function(response){
			var request = this.request;

			var mediaType = response.mediaType;
			if( mediaType && false === request.accept('mediaType', mediaType) ){
				throw this.createUnacceptedError('type', mediaType);
			}

			var charset = response.charset;
			if( charset && false === request.accept('charset', charset) ){
				throw this.createUnacceptedError('charset', charset);
			}

			var encoding = response.encoding;
			if( encoding && false === request.accept('encoding', encoding) ){
				throw this.createUnacceptedError('encoding', encoding);
			}
		}
	},

	use: function(router, options){
		if( options ){
			proto.define(router.RequestHandler.prototype.Response, options);
		}
	},

	handle: function(handler){
		handler.addTask(function(response){
			if( response.hasBody() ){
				response.populateContentHeaders();
				handler.acceptContentHeaders(response);
				response.validContentHeaders();
			}
			return response;
		});
	}
};