/*

*/

var ComputedStream =require('computedStream');
var BodyReadStream = ComputedStream.extend({
	decoders: require('./decoders'),
	converters: require('./converters'),

	bytesReceived: 0,
	bytesExpected: null,
	bytesLimit: -1,
	encoding: 'identity',
	charset: 'utf8',
	hash: null,
	digest: null,

	init: function(){
		this.on('data', this.ondata);
		this.on('end', this.onend);
	},

	ondata: function(chunk){
		this.bytesReceived+= chunk.length;
		this.emit('progress', this.bytesReceived, this.bytesExpected);

		if( typeof this.byteLimit == 'number' && this.bytesLimit != -1 && this.bytesReceived > this.byteLimit ){
			this.emit('error', this.createTooLargeError(this.bytesReceived, this.byteLimit));
		}
		else if( this.hash ){
			this.hash.write(chunk);
		}
	},

	onend: function(){
		if( typeof this.bytesExpected == 'number' && this.bytesExpected != -1 && this.bytesReceived != this.bytesExpected ){
			this.emit('error', this.createInvalidSizeError(this.bytesReceived, this.bytesExpected));
		}
		else if( this.hash && this.digest != this.hash.digest() ){
			this.emit('error', this.createBadDigestError(this.hash.digest(), this.digest));
		}
	},

	supporteds: function(name){
		switch(name){
		case 'encoding': 
			return Object.keys(this.decoders);
		case 'charset':
			return Object.keys(this.converters);
		}
	},

	support: function(name, value){
		switch(name){
		case 'encoding': 
			return value in this.decoders;
		case 'charset':
			return value in this.converters;
		}
	},

	setEncoding: function(encoding){
		this.chain(this.decoders[encoding].call(this));
	},

	setCharset: function(charset){
		this.chain(this.converters[charset].call(this));
	},

	setBytesExpected: function(bytesExpected){
		this.bytesExpected = bytesExpected;
	},

	setBytesLimit: function(bytesLimit){
		this.bytesLimit = bytesLimit;
	},

	setHash: function(hash, digest){
		this.hash = hash;
		this.digest = digest;
	}
});

module.exports = BodyReadStream;