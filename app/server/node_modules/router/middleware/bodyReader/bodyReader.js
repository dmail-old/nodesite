/*

very important: keep any async operation after bodyParser else request is aborted

THE FINAL GOAL:

If a request send a file in content-encoding: gzip
If the appropriate behaviour is to save that file on the server

The bodyreader stream could just be piped to a filesystem write stream

TODO:

*/

var BodyReader = {
	headers: [],
	ComputedStream: require('computedStream'),
	computedStream: null,
	request: null,

	addHeader: function(name){
		this.headers.push(require('./header/' + name));
	},

	create: function(request){
		this.request = request;
		this.headers = this.createHeaders();
	},

	createHeaders: function(){
		var headers = this.headers, i = 0, j = headers.length, header, result = [];
		
		for(;i<j;i++){
			header = headers[i].new(this);
			if( header ) result.push(header);
		}

		return result;
	},

	end: function(){
		return this.callback.apply(this.bind, arguments);
	},

	error: function(error){
		return this.end(error);
	},

	done: function(data){
		return this.end(null, data);	
	},

	read: function(callback, bind){
		this.callback = callback;
		this.bind = bind || this;

		// valid headers
		var error;
		this.headers.some(function(header){
			if( !header.valid() ){
				error = header.error;
				return true;
			}
		});
		if( error ) return this.error(error);

		// prepare a computedStream to read body
		this.computedStream = new this.ComputedStream();
		// the stream is the first stream to provide data to computedStream
		this.computedStream.chain(this.request, true);

		// when request is aborted we have to stop reading from request stream
		this.request.on('abort', function(){
			this.unpipe();
			this.emit('error', new Error('request aborted'));
		});

		this.headers.forEach(function(header){ header.effect(); });		
	}
};

// keep that order to active effect in that order
BodyReader.addHeader('content-md5');
BodyReader.addHeader('content-length');
BodyReader.addHeader('content-encoding');
BodyReader.addHeader('content-type');

module.exports = {
	request: {
		body: null,
		bodyParams: null,
		maxLength: 1e6,
		encoding: 'identity',
		type: 'application/octet-stream', // RFC2616 section 7.2.1
		charset: 'utf8',

		hasBody: function(){
			if( !this.is('post', 'put') ){
				return false;
			}
			if( this.hasHeader('transfer-encoding') ){
				return true;
			}
			if( this.getHeader('transfer-encoding') === 'chunked' ){
				return false;
			}
			if( this.getHeader('content-length') == '0' ){
				return false;
			}

			return true;
		},

		readBody: function(){
			var bodyReader = BodyReader.new(this);

			bodyReader.read(function(error, body){
				if( error ) return this.error(error);

				this.body = body;
				// currently body can be a stream "application/octet-stream"
				// or an object for "application/json" & "application/form-url-encoded"
				if( typeof body == "object" ){
					this.bodyParams = body;
				}

				this.next();

			}, this);
		}
	},

	handle: function(){
		if( this.request.hasBody() ){
			this.request.readBody();
		}
		else{
			this.next();
		}
	}
};