/*

if .js not specified it looks for pathname + '/index.js' then pathname + '.js'
it will try to locate those files in app/client/node_modules then app/node_modules

http://nodejs.org/api/modules.html#modules_all_together

*/

var ModulePathResolver = {
	cache: {},
	new: function(pathname){
		if( pathname in this.cache ){
			return this.cache[pathname];
		}
		return this.cache[pathname] = Object.prototype.new.call(this, pathname);
	},

	Path: require('path'),
	fileSystem: require('fs'),
	pathname: null,
	
	dirname: 'node_modules',
	index: 'index.js',

	init: function(pathname){
		this.pathname = pathname;
	},

	loadFile: function(path, fn){
		this.fileSystem.stat(path, function(error, stat){
			if( error ){
				fn();
			}
			else if( !stat.isFile() ){
				fn();
			}
			else{
				fn(stat);
			}
		});
	},

	loadAsFile: function(path, fn){
		this.loadFile(function(stat){
			// on a trouvé le fichier
			if( stat ){
				fn(path);
			}
			// on a pas trouvé le fichier
			else if( this.Path.extname(path) == '.js' ){
				fn();
			}
			// cherche un fichier finissant par .js
			else{				
				this.loadFile(path + '.js', fn);
			}
		});
	},

	loadAsDirectory: function(path, fn){
		var jsonPackage = path + this.Path.sep + 'package.json';

		function loadIndex(){
			// on a trouvé le fichier à load
		}

		this.loadFile(jsonPackage, function(stat){
			if( stat ){
				this.fileSystem.readFile(jsonPackage, function(error, json){
					if( error ){
						return fn(error);
					}

					try{					
						json = JSON.parse(json);
					}
					catch(e){
						return fn(e);
					}

					loadIndex(this.Path.resolve(path, this.json.main));

				}.bind(this));
			}
			else{
				loadIndex(path + this.Path.sep + 'index.js');
			}
		});

	},

	loadNodeModules: function(path, start, fn){
		// TODO

		var dirs = this.nodeModulePaths(start);
		var i = 0;

		function nextdirectory(){			
			
			if( i < j ){
				dir = dirs[i];
				this.loadAsFile(dir + this.Path.sep + path, function(path){
					if( path ){
						fn(path);
					}
					else{
						this.loadAsDirectory(dir + this.Path.sep + path, function(path){
							if( path ){
								fn(path);
							}
							else{
								nextdirectory();
							}
						});
					}
				});
				
			}
			else{
				fn();
			}

			i++;
		}
	},

	nodeModulePaths: function(path){
		/*
		let PARTS = path split(START)
		2. let ROOT = index of first instance of "node_modules" in PARTS, or 0
		3. let I = count of PARTS - 1
		4. let DIRS = []
		5. while I > ROOT,
		   a. if PARTS[I] = "node_modules" CONTINUE
		   c. DIR = path join(PARTS[0 .. I] + "node_modules")
		   b. DIRS = DIRS + DIR
		   c. let I = I - 1
		6. return DIRS
		*/

		var parts = path.split('/');

		

	},

	_resolve: function(callback, bind){
		bind = bind || this;
		
		var filename = this.pathname;
		var fileSystem = this.fileSystem;
		var Path = this.Path;
		var self = this;
		var sharedNodeModulesDirectory = global.APP_PATH;
		var clientNodeModulesDirectory = global.CLIENT_PATH;
		var extension = Path.extname(filename);
		var checkDirectory = extension === '';
		var checkNodeModules = startsWith(filename, '/', './', '../', sharedNodeModulesDirectory) === false;

		if( !checkDirectory ) filename = Path.dirname(filename) + Path.sep + Path.basename(filename, extension);

		var clientModule = clientNodeModulesDirectory + Path.sep + this.dirname + Path.sep + filename;
		var sharedModule = sharedNodeModulesDirectory + Path.sep + this.dirname + Path.sep + filename;
		
		function searchFile(filePath, fn){
			fileSystem.stat(filePath, function(error){
				if( error ){
					fn();
				}
				else{
					fn(filePath);
				}
			});
		}

		function startsWith(str){
			var i = 1, j = arguments.length;
			for(;i<j;i++){
				if( str.startsWith(arguments[i]) ) return true;
			}
			return false;
		}

		function searchModule(modulePath, fail){
			searchFile(modulePath + '.js', function(validPath){
				if( validPath ){
					return callback.call(bind, validPath);
				}

				if( checkDirectory ){
					return searchFile(modulePath + Path.sep + 'index.js', function(validPath){
						if( validPath ){
							return callback.call(bind, validPath);
						}
						else{
							fail();
						}				
					});
				}

				fail();
			});
		}

		searchModule(clientModule, function(){
			if( checkNodeModules ){
				searchModule(sharedModule, function(){
					callback.call(bind);
				});
			}
			else{
				callback.call(bind);
			}			
		});
	},

	resolve: function(callback, bind){
		var self = this;

		if( this.path ){
			process.nextTick(function(){
				callback.call(bind, self.path);
			});
		}
		else{
			this.resolve(function(path){
				self.path = path;
				callback.call(bind, path);
			});
		}
	}
};

var ModuleDemand = {
	// ceci doit être synchroniser avec un fichier
	// chaque fichier déclaré est vérifié lorsque le fichier est lu si un fichier est supprimé on met à jour le fichier
	dependencies: [],
	router: null,

	init: function(router){
		this.router = router;
		this.resolver = ModulePathResolver.new(router.request.url.pathname);
	},

	sendFile: function(path){
		this.response.sendFile(path.replace(/\\/g, '/'));
	},

	addDependency: function(child, parent){
		var index = this.dependencies.indexOf(child);

		if( index == -1 ){
			this.dependencies.push(parent, child);
		}
		else{
			this.dependencies.splice(index - 1, 0, parent);
		}
	},

	removeDependency: function(child){
		this.dependencies.remove(child);
	},

	send: function(){
		this.resolver.resolve(function(modulePath){
			if( modulePath ){
				this.addDependency(this.response.getHeader('x-required-by'), this.name);
				this.sendFile(modulePath);
			}
			else{
				this.removeDepency(this.name);
				this.response.send(404);
			}
		}, this);
	}	
};

module.exports = {
	handle: function(){
		if( this.request.is('get') && this.request.hasHeader('x-module') ){
			ModuleDemand.new(this).send();
		}
		else{
			this.next();
		}
	}
};