/*

http://nodejs.org/api/modules.html#modules_all_together

*/

var ModulePathResolver = {
	cache: {},
	new: function(requiredPath, modulePath){
		var id = requiredPath + modulePath;

		if( id in this.cache ){
			return this.cache[id];
		}
		return this.cache[id] = Object.prototype.new.call(this, requiredPath, modulePath);
	},

	Path: require('path'),
	fileSystem: require('fs'),

	dirname: 'node_modules',
	index: 'index.js',
	
	requiredPath: null, // path required by a module
	modulePath: null, // module path
	filename: null, // resolved filename

	init: function(requiredPath, modulePath){
		this.requiredPath = requiredPath;
		this.modulePath = modulePath;
	},

	loadFile: function(path, fn){
		this.fileSystem.stat(path, function(error, stat){
			if( error ){
				fn();
			}
			else if( !stat.isFile() ){
				fn();
			}
			else{
				fn(stat);
			}
		});
	},

	loadAsFile: function(path, fn){
		this.loadFile(function(stat){
			// on a trouvé le fichier
			if( stat ){
				fn(path);
			}
			// on a pas trouvé le fichier
			else if( this.Path.extname(path) == '.js' ){
				fn();
			}
			// cherche un fichier finissant par .js
			else{				
				this.loadFile(path + '.js', fn);
			}
		});
	},

	loadAsDirectory: function(path, fn){
		var jsonPackage = path + this.Path.sep + 'package.json';

		this.loadFile(jsonPackage, function(stat){
			if( stat ){
				this.fileSystem.readFile(jsonPackage, function(error, json){
					if( error ){
						return fn(error);
					}

					try{					
						json = JSON.parse(json);
					}
					catch(e){
						return fn(e);
					}

					this.loadFile(this.Path.resolve(path, json.main), fn);

				}.bind(this));
			}
			else{
				this.loadFile(path + this.Path.sep + this.index, fn);
			}
		});
	},

	loadNodeModules: function(path, start, fn){
		/*
		LOAD_NODE_MODULES(X, START)
		1. let DIRS=NODE_MODULES_PATHS(START)
		2. for each DIR in DIRS:
			a. LOAD_AS_FILE(DIR/X)
			b. LOAD_AS_DIRECTORY(DIR/X)
		*/

		var dirs = this.nodeModulePaths(start), i = 0, j = dirs.length, dir;

		function nextdirectory(){			
			
			if( i < j ){
				dir = dirs[i];
				this.loadAsFile(dir + this.Path.sep + path, function(path){
					if( path ){
						fn(path);
					}
					else{
						this.loadAsDirectory(dir + this.Path.sep + path, function(path){
							if( path ){
								fn(path);
							}
							else{
								nextdirectory();
							}
						});
					}
				});
				
			}
			else{
				fn();
			}

			i++;
		}

		nextdirectory();
	},

	// http://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders
	nodeModulePaths: function(start){
		/*
		1. let PARTS = path split(START)
		2. let ROOT = index of first instance of "node_modules" in PARTS, or 0
		3. let I = count of PARTS - 1
		4. let DIRS = []
		5. while I > ROOT,
			a. if PARTS[I] = "node_modules" CONTINUE
			c. DIR = path join(PARTS[0 .. I] + "node_modules")
			b. DIRS = DIRS + DIR
			c. let I = I - 1
		6. return DIRS
		*/

		var parts = start.split('/'), dirs, dir, i, root, part;

		root = parts.indexOf('node_modules');
		if( root == -1 ) root = 0;

		i = parts.length - 1;
		dirs = [];
		while( i > root ){
			part = parts.pop();
			if( part == 'node_modules' ) continue;
			dir = this.Path.join.apply(this.Path, [].concat(parts, 'node_modules'));
			dirs.push(dir);

			// ne dois pas monter plus haut que app/node_modules
			if( dir == global.APP_PATH + this.Path.sep + 'node_modules' ) break;

			i--;
		}

		return dirs;
	},

	_resolve: function(callback, bind){
		/*
		require(X) from module at path Y
		1. If X is a core module,
			a. return the core module
			b. STOP
		2. If X begins with './' or '/' or '../'
			a. LOAD_AS_FILE(Y + X)
			b. LOAD_AS_DIRECTORY(Y + X)
		3. LOAD_NODE_MODULES(X, dirname(Y))
		4. THROW "not found"
		*/

		var X = this.requiredPath;
		var Y = this.modulePath;

		function load_node_modules(){
			this.loadNodeModules(X, this.Path.dirname(Y), function(path){
				if( path ) return callback(path);
				callback(new Error('not found'));
			});
		}	

		if( X[0] == '/' || X.slice(0,2) == './' || X.slice(0,3) == '../' ){
			this.loadAsFile(Y + X, function(path){
				if( path ) return callback(path);
				
				this.loadAsDirectory(Y + X, function(path){
					if( path ) return callback(path);
					load_node_modules.call(this);
				});
			});
		}
		else{
			load_node_modules();
		}
	},

	resolve: function(callback, bind){
		var self = this;

		if( this.filename ){
			process.nextTick(function(){
				callback.call(bind, self.filename);
			});
		}
		else{
			this._resolve(function(filename){
				self.filename = filename;
				callback.call(bind, filename);
			});
		}
	}
};

/*

chaque fois qu'on demande la résolution d'un module on met à jour le tableau dependencies

dependencyTree = {
	filename: '',
	resolvedPaths: {
		'patha': 'resolvedpatha',
		'pathb': 'resolvedpathb'
	},
	children: [
		{
			filename: '',
			resolvedPaths: {},
			children: []
		}	
	]
}

*/

var ModuleDemand = {
	dependencyTree: {
		filename: '/',
		resolvedPaths: {},
		children: []
	},

	router: null,

	init: function(router){
		this.router = router;
		var request = router.request;

		// faut que j'essaye de trouve ce module sinon je le crée comme module racine
		var module = request.getHeader('x-required-by');
		// ce module require ça, faudras le mettre dans les resolvedPaths une fois résolu
		var require = request.getHeader('x-require');

		this.resolver = ModulePathResolver.new(require, module);
	},

	sendFile: function(path){
		this.router.response.sendFile(path.replace(/\\/g, '/'));
	},

	addDependency: function(child, parent){
		var index = this.dependencies.indexOf(child);

		if( index == -1 ){
			this.dependencies.push(parent, child);
		}
		else{
			this.dependencies.splice(index - 1, 0, parent);
		}
	},

	removeDependency: function(child){
		this.dependencies.remove(child);
	},

	send: function(){
		this.resolver.resolve(function(modulePath){
			if( modulePath ){
				this.addDependency(this.response.getHeader('x-required-by'), this.name);
				this.sendFile(modulePath);
			}
			else{
				this.removeDepency(this.name);
				this.response.send(404);
			}
		}, this);
	}	
};

module.exports = {
	handle: function(){
		if( this.request.is('get') && this.request.hasHeader('x-module') ){
			ModuleDemand.new(this).send();
		}
		else{
			this.next();
		}
	}
};