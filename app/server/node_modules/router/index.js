/*

Request / Response logic

*/

function escapeHTML(html){
	return String(html).replace(/&(?!\w+;)/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

require('object/define');
var proto = require('proto');
var debug = require('debug');
require('promise/route');
require('promise/from');
require('promise/timeout');
require('promise/reduce');

var Emitter = require('Emitter');

var RequestHandler = proto.extend(Emitter, {
	Response: require('./response'),
	router: null,
	request: null,
	fileSystem: require('fs'), // we could wrap all methods to measure request fileSystem calls
	//database: require('db'),
	timeout: -1,//1 * 1000,

	constructor: function(router, request){
		Emitter.call(this);
		this.router = router;
		this.request = request;
		this.tasks = [];

		this.routePromise = this.createPromise();
		this.timeoutPromise = this.createTimeoutPromise();
		this.responsePromise = this.routePromise.then(function(properties){
			debug('creating response from route result');
			return this.createResponse(properties);
		}.bind(this)).then(function(response){
			// we can do stuff on the response generated from the request
			return Promise.reduce(this.tasks, this, response);
		}.bind(this));

		if( this.timeout > 0 ){
			this.promise = Promise.race([
				this.responsePromise,
				this.timeoutPromise
			]);
		}
		else{
			this.promise = this.responsePromise;
		}

		return this.promise;
	},

	addTask: function(task){
		this.tasks.push(task);
	},

	clearTimeout: function(){
		this.timeoutPromise.clearTimeout();
	},

	createTimeoutPromise: function(){
		return Promise.timeout(this.timeout).then(function(){
			return this.createResponse(408); // request timeout
		}.bind(this));
	},

	isErrorTraceAllowed: function(){
		return this.allowErrorTrace || (this.user && this.user.level == 1);
	},

	formatError: function(error){
		var object = {
			name: error.name,
			message: error.message
		};

		if( this.isErrorTraceAllowed(error) ){
			object.stack = error.stack;
		}

		for(var prop in error) object[prop] = error[prop];

		return object;
	},

	// default error handler, here we try to use as much as possible native methods
	createErrorPromise: function(error){
		var accept = this.request.getHeader('accept'), status = 500;

		if( error.status ) status = error.status;

		debug('creating error response with status', status);

		// html
		if( ~accept.indexOf('html') ){
			var fs = require('fs'), self = this;

			return Promise.all([
				Promise.from(function(complete){
					fs.readFile(__dirname + '/error.css', 'utf8', complete);
				}),
				Promise.from(function(complete){
					fs.readFile(__dirname + '/error.html', 'utf8', complete);
				})
			]).then(function(values){
				var style = values[0], html = values[1], stack = error.stack || '';

				stack = stack.split('\n').slice(1);
				stack = stack.map(function(value){ return '<li>' + value + '</li>'; }).join('');

				html = html.replace('{style}', style);
				html = html.replace('{stack}', stack);
				html = html.replace('{title}', 'Error');
				html = html.replace('{status}', status);
				html = html.replace(/\{error\}/g, escapeHTML(error.toString()).replace(/\n/g, '<br/>'));

				return {
					status: status,
					headers: {
						'content-type': 'text/html;charset=utf-8',
						'content-length': Buffer.byteLength(html)
					},
					body: html
				};
			});
		}

		// json
		if( ~accept.indexOf('json') ){
			var object = this.formatError(error);
			var json = JSON.stringify({error: object});

			return {
				status: status,
				headers: {
					'content-type': 'application/json',
					'content-length': Buffer.byteLength(json)
				},
				body: json
			};
		}

		// plain text
		var text = error.stack;
		return {
			status: status,
			headers: {
				'content-type': 'text/plain',
				'content-length': Buffer.byteLength(text)
			},
			body: text
		};
	},

	createPromise: function(){
		var middlewares = this.router.middlewares.map(function(middleware){
			if( typeof middleware == 'function' ){
				return middleware;
			}
			else if( typeof middleware == 'object' ){
				return middleware.handle.bind(middleware);
			}
		});
		var p = Promise.route(middlewares, null, this);

		p = p.then(function(value){
			if( value == null ){
				debug('no route found, sending 501');
				return 501; // not implemented
			}
			return value;
		}).catch(function(error){
			console.error('error while routing', error.stack);
			return this.createErrorPromise(error);
		}.bind(this));

		return p;
	},

	createResponse: function(properties){
		return this.Response.create(properties);
	}
});

function requireWithoutCache(path){
	path = require.resolve(path);
	delete require.cache[path];
	return require(path);
}

var Router = proto.create({
	middlewares: null,
	allowErrorTrace: false,
	Request: require('./request'),
	RequestHandler: null,

	constructor: function(options){
		this.middlewares = [];
		if( options ) Object.define(this, options);

		this.RequestHandler = RequestHandler;
		//this.RequestHandler = requireWithoutCache('./requestHandler');
	},

	get: function(name){
		var middleware;

		if( typeof name === 'string' ) middleware = require('./middleware/' + name);
		else if( typeof name == 'function' ) middleware = {handle: name};
		else if( typeof name === 'object' ) middleware = name;

		if( typeof middleware != 'object' ){
			throw new TypeError('a middleware must be a function or an object ' + middleware + ' given');
		}

		return middleware;
	},

	has: function(middleware){
		return this.middlewares.indexOf(this.get(middleware)) !== -1;
	},

	use: function(middleware){
		middleware = this.get(middleware);

		if( middleware.requires ){
			var dependencies = middleware.requires, i = 0, j, dependency;
			if( typeof dependencies == 'string' ) dependencies = [dependencies];
			j = dependencies.length;

			for(;i<j;i++){
				dependency = dependencies[i];
				if( !this.has(dependency) ){
					throw new Error('this middleware require the ' + dependency + ' middleware');
				}
			}
		}

		if( middleware.request ){
			proto.define(this.Request, middleware.request);
		}
		if( middleware.response ){
			proto.define(this.RequestHandler.prototype.Response, middleware.response);
		}
		if( middleware.extend ){
			proto.define(this.RequestHandler.prototype, middleware.extend);
		}

		if( middleware.use ){
			middleware.use.apply(middleware, [this].concat(Array.prototype.slice.call(arguments, 1)));
		}

		this.middlewares.push(middleware);

		return this;
	},

	createRequest: function(properties){
		return this.Request.create(properties);
	},

	createResponsePromise: function(request){
		return this.RequestHandler.create(this, request);
	},

	route: function(clientRequest, serverResponse){
		var request = this.createRequest({
			httpVersion: clientRequest.httpVersion,
			method: clientRequest.method,
			headers: clientRequest.headers,
			url: clientRequest.url,
     		stream: clientRequest,
     		body: null
		});

		this.createResponsePromise(request).then(function(response){
			debug('populate serverResponse with response');

			serverResponse.statusCode = response.status;
			serverResponse.statusMessage = response.statusMessage;

			for(var name in response.headers){
				serverResponse.setHeader(name, response.headers[name]);
			}

			if( !request.is('head') && response.hasBody() ){
				response.stream.pipe(serverResponse);
			}
			else{
				serverResponse.end();
			}

		}).catch(function(error){
			console.error('internal error', error.stack);

			serverResponse.statusCode = 500;
			serverResponse.end();
		});
	}
});

module.exports = Router;