/*

Request / Response logic

*/

function escapeHTML(html){
	return String(html).replace(/&(?!\w+;)/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

require('object/define');
var proto = require('proto');
var debug = require('debug');
require('promise/route');
require('promise/from');
require('promise/timeout');
require('promise/reduce');

var Cookie = require('Cookie');

var RequestHandler = proto.extend({
	Request: require('./request'),
	Response: require('./response'),
	fileSystem: require('fs'), // we could wrap all methods to measure request fileSystem calls
	//database: require('db'),

	timeout: -1,//1 * 1000,

	router: null,
	request: null,
	response: null,

	constructor: function(router, requestProperties){
		this.router = router;
		this.request = this.createRequest();
		this.response = this.createResponse();

		this.request.resolve(requestProperties);

		this.responsePropertiesPromise = this.request.ready().then(function(){
			debug('request is ready');
			return this.createResponsePropertiesPromise();
		}.bind(this));
		this.responsePromise = this.responsePropertiesPromise.then(function(responseProperties){
			debug('populate response from middleware result');
			return this.response.resolve(responseProperties);
		}.bind(this));

		if( this.timeout > 0 ){
			this.timeoutPromise = this.createTimeoutPromise();
			this.promise = Promise.race([
				this.responsePromise,
				this.timeoutPromise
			]);
		}
		else{
			this.promise = this.responsePromise;
		}
	},

	ready: function(){
		return this.promise;
	},

	createRequest: function(properties){
		return this.Request.create(properties);
	},

	createResponse: function(properties){
		return this.Response.create(properties);
	},

	isErrorTraceAllowed: function(){
		return this.allowErrorTrace || (this.user && this.user.level == 1);
	},

	formatError: function(error){
		var object = {
			name: error.name,
			message: error.message
		};

		if( this.isErrorTraceAllowed(error) ){
			object.stack = error.stack;
		}

		for(var prop in error) object[prop] = error[prop];

		return object;
	},

	createResponseErrorPropertiesPromise: function(error){
		var accept = this.request.getHeader('accept'), status = 500;

		if( error.status ) status = error.status;

		debug('creating error response with status', status);

		// html
		if( ~accept.indexOf('html') ){
			var fs = require('fs'), self = this;

			return Promise.all([
				Promise.from(function(complete){
					fs.readFile(__dirname + '/error.css', 'utf8', complete);
				}),
				Promise.from(function(complete){
					fs.readFile(__dirname + '/error.html', 'utf8', complete);
				})
			]).then(function(values){
				var style = values[0], html = values[1], stack = error.stack || '';

				stack = stack.split('\n').slice(1);
				stack = stack.map(function(value){ return '<li>' + value + '</li>'; }).join('');

				html = html.replace('{style}', style);
				html = html.replace('{stack}', stack);
				html = html.replace('{title}', 'Error');
				html = html.replace('{status}', status);
				html = html.replace(/\{error\}/g, escapeHTML(error.toString()).replace(/\n/g, '<br/>'));

				return {
					status: status,
					headers: {
						'content-type': 'text/html;charset=utf-8',
						'content-length': Buffer.byteLength(html)
					},
					body: html
				};
			});
		}

		// json
		if( ~accept.indexOf('json') ){
			var object = this.formatError(error);
			var json = JSON.stringify({error: object});

			return {
				status: status,
				headers: {
					'content-type': 'application/json',
					'content-length': Buffer.byteLength(json)
				},
				body: json
			};
		}

		// plain text
		var text = error.stack;
		return {
			status: status,
			headers: {
				'content-type': 'text/plain',
				'content-length': Buffer.byteLength(text)
			},
			body: text
		};
	},

	createResponsePropertiesPromise: function(){
		var middlewares = this.router.middlewares.map(function(middleware){
			if( typeof middleware == 'function' ){
				return middleware;
			}
			else if( typeof middleware == 'object' ){
				return middleware.task.bind(middleware);
			}
		});

		var p = Promise.route(middlewares, null, this);

		p = p.then(function(value){
			if( value == null ){
				debug('no properties prvided, sending 501');
				return 501; // not implemented
			}
			debug('found properties');
			return value;
		}).catch(function(error){
			console.error('error while routing', error ? error.stack : null);
			return this.createResponseErrorPropertiesPromise(error);
		}.bind(this));

		return p;
	},

	createTimeoutPromise: function(){
		return Promise.timeout(this.timeout).then(function(){
			this.response = this.createResponse(); // don't send the current response, send an empty one
			this.response.status = 408; // request timeout
			return this.response;
		}.bind(this));
	},

	clearTimeout: function(){
		this.timeoutPromise.clearTimeout();
	}
});

function requireWithoutCache(path){
	path = require.resolve(path);
	delete require.cache[path];
	return require(path);
}

var Router = proto.extend({
	middlewares: null,
	allowErrorTrace: false,
	RequestHandler: RequestHandler,
	RequestPlugins: [
		'request-length',
		'request-md5',
		'request-negotiation',
		'request-body',
		'request-params',
		'request-json',
		'request-method-override'
	],

	constructor: function(options){
		this.middlewares = [];
		if( options ) Object.define(this, options);

		this.RequestHandler = RequestHandler;
		this.RequestHandler.Request = this.RequestHandler.Request.extend(
			this.RequestPlugins.map(function(name){
				return require('./request/' + name);
			})
		);
	},

	get: function(name){
		var middleware;

		if( typeof name === 'string' ) middleware = require('./middleware/' + name);
		else if( typeof name == 'function' ) middleware = {task: name};
		else if( typeof name === 'object' ){
			if( typeof middleware.task != 'function' ) throw new Error('middleware must a task method');
			middleware = name;
		}

		if( typeof middleware != 'object' ){
			throw new TypeError('a middleware must be a function or an object ' + middleware + ' given');
		}

		return middleware;
	},

	has: function(middleware){
		return this.middlewares.indexOf(this.get(middleware)) !== -1;
	},

	use: function(middleware){
		middleware = this.get(middleware);

		if( middleware.properties ){
			proto.define(this.RequestHandler, middleware.properties);
		}

		if( middleware.use ){
			middleware.use.apply(middleware, [this].concat(Array.prototype.slice.call(arguments, 1)));
		}

		this.middlewares.push(middleware);

		return this;
	},

	createRequestHandler: function(requestProperties){
		return this.RequestHandler.create(this, requestProperties);
	},

	getClientRequestProperties: function(clientRequest){
		var properties = {
			httpVersion: clientRequest.httpVersion,
			method: clientRequest.method,
			headers: clientRequest.headers,
			cookies: 'cookies' in clientRequest.headers ? Cookie.parseAll(clientRequest.headers.cookies) : null,
			url: clientRequest.url
		};

		// set request body only under some circumstances
		if( clientRequest.method === 'POST' || clientRequest.method === 'PUT' ){
			if( 'transfer-encoding' in clientRequest.headers || clientRequest.headers['content-length'] != '0' ){
				properties.body = clientRequest;
			}
		}

		return properties;
	},

	createClientRequestHandler: function(clientRequest){
		return this.createRequestHandler(this.getClientRequestProperties(clientRequest));
	},

	route: function(clientRequest, serverResponse){
		this.createClientRequestHandler(clientRequest).ready().then(function(response){
			debug('populate serverResponse with response');

			serverResponse.statusCode = response.status;
			serverResponse.statusMessage = response.statusMessage;

			for(var name in response.headers){
				serverResponse.setHeader(name, response.headers[name]);
			}

			if( clientRequest.method !== 'HEAD' && response.hasBody() ){
				response.stream.pipe(serverResponse);
			}
			else{
				serverResponse.end();
			}

		}).catch(function(error){
			console.error('internal error', error.stack);

			serverResponse.statusCode = 500;
			serverResponse.end();
		});
	}
});

module.exports = Router;