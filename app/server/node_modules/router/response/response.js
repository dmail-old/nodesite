/*

wrapper for the native Response Nodejs object

inspired from
https://github.com/mcavage/node-restify/blob/master/lib/response.js

NOTE

- auto content-language:
les fichiers non binaire (hormis fichier langue) sont tous en anglais
-> comment le navigateur gère si on précise que c'est des fichiers anglais
pour les réponses genre pages/json etc le language semble approprié par contre mais aucune idée de comment le gérer
pour le moment
-> on désactive le content-language jusqu'à ce qu'on ai à s'en occuper

- auto content-encoding:
pouvoir configurer quand et comment j'encode ce que je réponds

FIX

*/

var Stream = require('stream');
global.isStream = function(a){
	return a instanceof Stream.Readable || a instanceof Stream.Writable || a instanceof Stream.Duplex;
};

global.isReadableStream = function(a){
	return a instanceof Stream.Readable;
};

global.streamToBuffer = function(stream, fn, bind){
	var buffers = [];

	stream.on('data', function(data){
		buffers.push(data);
	});
	stream.on('end', function(){
		fn.call(bind, null, Buffer.concat(buffers));
	});
	stream.on('error', function(error){
		fn.call(bind, error);
	});
};

var http = require('http');
var ServerResponse = http.ServerResponse;
var sprintf = require('util').format;

var Response = {
	HEADERS: {
		CONTENT_TYPE: 'content-type',
		CONTENT_LENGTH: 'content-length',
		CONTENT_ENCODING: 'content-encoding',
		CONTENT_LANGUAGE: 'content-language',
		SET_COOKIE: 'set-cookie',
		STATUS_CODE: 'x-status-code',
		RESPONSE_TIME: 'x-response-time'
	},
	statusMessages: http.STATUS_CODES,

	router: null,
	request: null,
	statusCode: 200,
	headers: null,
	body: undefined,
	bodyPrepared: false,
	waitCount: 0,

	new: function(response, router){
		return Object.prototype.new.call(Object.supplement(response, this), router);
	},

	create: function(router){
		this.router = router;
		this.headers = {};
	},

	error: function(error){
		this.router.next(error);
	},

	next: function(error){
		this.router.next(error);
	},

	hasHeader: function(name){
		return name in this.headers;
	},

	getHeader: function(name){
		return this.headers[name];
	},

	removeHeader: function(name){
		delete this.headers[name];
		return this;
	},

	prepareBody: function(done){
		done();
	},

	write: function(chunk, encoding){
		this.emit('write', chunk, encoding);
		return ServerResponse.write.call(this, chunk, encoding);
	},

	writeBody: function(body){
		if( global.isStream(body) ){
			// dont call end on response, end is automatically called
			body.pipe(this, {end: false});
		}
		else{
			this.write(body);
		}
	},

	wait: function(fn, bind){
		bind = bind || this;

		this.waitCount++;
		fn.call(bind, function(){
			// ce qu'on devait faire est terminé on peut appelé end
			this.waitCount--;
			if( this.waitCount === 0 ){
				this.end();
			}
		}.bind(this));
	},

	end: function(){
		if( this.headersSent ){
			return this.request.socket.destroy();
		}
		
		if( this.bodyPrepared === false && this.hasOwnProperty('body') ){
			// when body is an error, error are supposed to be handled with response.error(error)
			// but it's possible to write response.send(error) or response.body = error; too
			if( this.body instanceof Error ){
				return this.error(this.body);
			}

			this.bodyPrepared = true;
			return this.wait(this.prepareBody);
		}

		var name, headers;

		// AJAX request need a 200 statusCode to read the response, error status are put in a specific header
		if( this.statusCode < 200 && this.statusCode >= 400 && this.request.isAjax() ){
			this.setHeader(this.HEADERS.STATUS_CODE, this.statusCode);
			this.statusCode = 200;
		}

		// there is a body without content-length header, tell that to the browser
		if( this.bodyPrepared === true && !this.hasHeader('content-length') ){
			this.setHeader('transfer-encoding', 'chunked');
			this.setHeader('accept-ranges', 'bytes');
		}

		this.emit('header');
		headers = this.headers;
		for(name in headers ){
			ServerResponse.setHeader.call(this, name, headers[name]);
		}

		if( !this.request.is('head') && this.bodyPrepared === true ){
			// handle response error (response is a writable stream able to emit errors)
			// ok mais qu'est ce qu'on fait dans ce cas là puisque les headers seront envoyés?
			// this.on('error', this.error);
			this.writeBody(this.body);
		}

		this.emit('end');
		return ServerResponse.end.call(this);
	},

	getStatusDescription: function(status){
		return status in this.statusMessages ? this.statusMessages[status] : null;
	},

	toString: function(){
		var headers = this.headers;
		var headerString = '';
		var str;

		Object.keys(headers).forEach(function(k){
			headerString += k + ': ' + headers[k] + '\n';
		});

		str = sprintf('HTTP/1.1 %s %s\n%s', this.statusCode, this.getStatusDescription(this.statusCode), headerString);

		return str;
	}
};

module.exports = Response;