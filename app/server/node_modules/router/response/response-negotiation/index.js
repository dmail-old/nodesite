/*
- auto content-language:
les fichiers non binaire (hormis fichier langue) sont tous en anglais
-> comment le navigateur gère si on précise que c'est des fichiers anglais
pour les réponses genre pages/json etc le language semble approprié par contre mais aucune idée de comment le gérer
pour le moment
-> on désactive le content-language jusqu'à ce qu'on ai à s'en occuper

- auto content-encoding:
pouvoir configurer quand et comment j'encode ce que je réponds

*/

var proto = require('proto');
var stream = require('stream');
var contentType = require('content-type');

module.exports = {
	name: 'response-negotiation',

	properties: {
		encoders: require('./encoders'),
		converters: require('./converters'),
		//defaultMediaType: 'text/plain',
		defaultMediaType: 'application/octet-stream', // RFC2616 section 7.2.1
		defaultCharset: 'utf8', // by default data are considered using utf8 charset
		defaultEncoding: 'identity',  // by default data are considered not encoded
		defaultLanguage: 'en',
		negotiateMediaType: false, // voir comment on peut faire
		negotiateCharset: true, // mais tfaçon j'en supporte aucun autre que utf8
		negotiateEncoding: false,
		negotiateLanguage: true,

		bodyCharset: 'utf8',
		bodyEncoding: 'identity',

		get encoding(){
			return this.getHeader('content-encoding') || this.defaultEncoding;
		},

		set encoding(encoding){
			this.setHeader('content-encoding', encoding);
		},

		get mediaType(){
			if( this.hasHeader('content-type') ){
				return contentType.parse(this.getHeader('content-type'))[0];
			}
			return this.defaultMediaType;
		},

		set mediaType(mediaType){
			this.setHeader('content-type', mediaType + ';charset=' + this.charset);
		},

		get charset(){
			if( this.hasHeader('content-type') ){
				return contentType.parse(this.getHeader('content-type'))[1];
			}
			return this.defaultCharset;
		},

		set charset(charset){
			this.setHeader('content-type', this.mediaType + ';charset=' + charset);
		},

		autoContentHeaders: function(){
			var vary = [];

			if( false === this.hasHeader('content-type') && this.negotiateMediaType ){
				//this.mediaType = ;
				vary.push('accept');
			}

			if( false === this.hasHeader('content-type') && this.negotiateCharset ){
				//this.charset = ;
				vary.push('accept-charset');
			}

			if( this.charset && false === this.hasHeader('content-language') && this.negotiateLanguage ){
				//this.language = ;
				vary.push('accept-language');
			}

			if( false === this.hasHeader('content-encoding') && this.negotiateEncoding ){
				//this.encoding = ;
				vary.push('accept-encoding');
			}

			if( vary.length ){
				this.setHeader('vary', vary.join(', '));
			}
		},

		canConvert: function(charset){
			return charset === 'utf8' || charset in this.converters;
		},

		canEncode: function(encoding){
			return encoding === 'identity' || encoding in this.encoders;
		},

		createUnsupportedError: function(){
			var error = new Error('unsupported header');

			// this is an internal error : something has set an header value to somthing unsupported
			error.status = 500;

			return error;
		},

		validContentHeaders: function(){
			var charset = this.charset;
			if( charset ){
				if( false === this.canConvert(charset) ){
					throw this.createUnsupportedError('charset', charset);
				}
				else if( charset != 'utf8' ){
					this.removeHeader('content-length'); // must be recomputed

					var converter = this.encoders[charset].call(this);
					this.transform(converter);
				}
			}

			var encoding = this.encoding;
			if( encoding ){
				if( false === this.canEncode(encoding) ){
					throw this.createUnsupportedError('encoding', encoding);
				}
				else if( encoding != 'identity' ){
					this.removeHeader('content-length'); // must be recomputed

					var encoder = this.encoders[encoding].call(this);
					this.transform(encoder);
				}
			}
		}
	},

	task: function(){
		if( this.hasBody() ){
			this.autoContentHeaders();
			this.validContentHeaders();
		}
	}
};