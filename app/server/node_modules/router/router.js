/*

Route the request, response couple to a response

*/

function escapeHTML(html){
	return String(html).replace(/&(?!\w+;)/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

var Router = {
	Request: require('./request'),
	Response: require('./response'),
	originalRequest: null,
	originalResponse: null,
	request: null,
	response: null,

	index: 0,
	handler: null,
	handlers: [],
	error: null,
	allowErrorTrace: false,
	
	new: function(request, response){
		this.originalRequest = request;
		this.originalResponse = response;
		this.request = this.Request.new(request, this);
		this.response = this.Response.new(response, this);
		
		this.request.response = this.response;
		this.response.request = this.request;

		if( this.request.is('head') ){
			this.response.write = function(){
				console.warn('HEAD request expect empty body, write call ignored');
				return true;
			};
		}
	},

	addHandler: function(handler){
		if( typeof handler != 'function' ){
			var error = new TypeError('RequestHanlder Error: handler must be a function, '+ handler + ' given');
			console.error(error.stack);
		}
		else{
			this.handlers.push(handler);
		}
	},

	use: function(middleware){
		if( typeof middleware == 'string' ){
			middleware = require('./middleware/' + middleware);
		}

		if( typeof middleware == 'function' ){
			this.addHandler(middleware);
		}
		else if( typeof middleware == 'object' ){
			if( middleware.request ){
				this.Request.supplement(middleware.request);
			}
			if( middleware.response ){
				this.Response.supplement(middleware.response);
			}
			if( middleware.handle ){
				this.addHandler(middleware.handle);
			}

			if( middleware.use ){
				middleware.use(this, Array.slice(arguments, 1));
			}
		}

		return this;
	},

	isErrorTraceAllowed: function(){
		return this.allowErrorTrace || (this.request.user && this.request.user.level == 1);
	},

	formatError: function(error){
		var type = 'error';

		//if( error.status ) this.status = error.status;

		if( error.type ){
			type = error.type;
		}
		else if( error instanceof SyntaxError ){
			type = 'syntax';
		}
		else if( error instanceof ReferenceError ){
			type = 'reference';
		}
		else if( error instanceof TypeError ){
			type = 'type';
		}

		var data = {};
		data.type = type;
		if( this.isErrorTraceAllowed(error) ){
			data.stack = error.stack;
		}
		data.message = error.message;

		return data;
	},

	// default error handler, here we try to use as much as possible native methods
	handleError: function(error){
		var request = this.originalRequest, response = this.originalResponse, status = 500;

		if( error.status ) status = error.status;
		console.error(error);

		var accept = request.headers['accept'] || '';

		// html
		if( ~accept.indexOf('html') ){
			var fs = require('fs'), self = this;
			fs.readFile(__dirname + '/error.css', 'utf8', function(e, style){
				fs.readFile(__dirname + '/error.html', 'utf8', function(e, html){
					var stack = error.stack || '';

					stack = stack.split('\n').slice(1);
					stack = stack.map(function(value){ return '<li>' + value + '</li>'; }).join('');

					html = html.replace('{style}', style);
					html = html.replace('{stack}', stack);
					html = html.replace('{title}', 'YO');
					html = html.replace('{statusCode}', status);
					html = html.replace(/\{error\}/g, escapeHTML(error.toString()).replace(/\n/g, '<br/>'));

					response.statusCode = status;
					response.setHeader('content-type', 'text/html;charset=utf-8');
					response.setHeader('content-length', Buffer.byteLength(html));
					response.write(html);
					response.end();
				});
			});
		}
		// json
		else if( ~accept.indexOf('json') ){
			var object = {message: error.message, stack: error.stack};
			for( var prop in error ) object[prop] = error[prop];
			var json = JSON.stringify({error: error});

			response.statusCode = status;
			response.setHeader('content-type', 'application/json');
			response.setHeader('content-length', Buffer.byteLength(json));
			response.write(json);
			response.end();
		}
		// plain text
		else{
			var text = error.stack;

			response.statusCode = status;
			response.setHeader('content-type', 'text/plain');
			response.setHeader('content-length', Buffer.byteLength(text));
			response.write(text);
			response.end();
		}
	},

	// default handler
	handle: function(){
		this.response.populate(501);
	},

	next: function(error){
		if( this.error ){
			console.log('router.next called while an error is handled, something async must be calling router.next');
			return;
		}

		this.error = error || null;

		// no matching handler, call defaultHandler
		if( this.index >= this.handlers.length ){
			// catch defaultHandler error
			try{
				if( this.error ){				
					this.handleError(this.error);
				}
				else{
					this.handle();
				}
			}
			catch(e){
				// nothing could handle the error without creating an error
				// just send 500: Server Internal error
				console.error('default handler error', e);
				this.response.writeHead(500, 'Server Internal error');
				this.response.end();
			}
			return;
		}

		this.handler = this.handlers[this.index];
		this.index++;

		if( this.error ){
			if( this.handler.length === 2 ){
				// catch error handler error
				try{
					this.handler(this.error);
				}
				catch(e){
					// in this situation what error do we handle?
					// the first error or the last one?
					// i would say the first error could create the last one
					// but without the last one no clue of how the first created the last one
					this.error = null;
					this.next(e);
				}
			}
			else{
				this.next(this.error);
			}
		}
		else{
			// catch handler error
			try{
				this.handler(this);
			}			
			catch(e){
				this.next(e);
			}
		}
	},

	start: function(){
		this.next();
	}
};

module.exports = Router;