/*

name: Request

description: Helper for node request

making response & request streamable
https://github.com/mjijackson/mach/blob/master/modules/request.js

inspiration:
restify: https://github.com/mcavage/node-restify

*/

var proto = require('proto');
var Cookie = require('cookie');
var stream = require('stream');
var PassThrough = stream.PassThrough;
var debug = require('debug');
require('promise/fromStream');

var Request = proto.create({
	URL: require('url'),
	QueryString: require('querystring'),

	url: null,
	method: 'get',
	trailers: {},
	headers: {},
	stream: null,
	httpVersion: '1.1',

	urlParams: {},
	cookies: {},

	constructor: function(properties){
		this.stream = new PassThrough();

		Object.defineProperty(this, 'stream', {
			enumerable: false,
			configurable: true,
			value: this.stream
		});

		if( properties ){
			if( 'url' in properties ){
				this.url = properties.url;
				this.url = this.URL.parse(this.url);
				this.url.toString = function(){ return this.href; };
				this.url.pathname = this.QueryString.unescape(this.url.pathname);
				this.urlParams = this.QueryString.parse(this.url.query);
			}
			if( 'method' in properties ){
				this.method = properties.method.toLowerCase();
			}
			if( 'headers' in properties && properties.headers != null ){
				this.headers = properties.headers;
			}
			if( 'httpVersion' in properties ){
				this.httpVersion = properties.httpVersion;
			}
			if( 'stream' in properties ){
				properties.stream.pipe(this.stream);
			}
			else if( 'body' in properties ){
				this.stream.write(properties.body);
			}
		}

		if( this.hasHeader('cookie') ){
			this.cookies = Cookie.parseAll(this.getHeader('cookie'));
		}
	},

	createBodyPromise: function(){
		debug('creating body promise', this.hasBody());

		if( !this.hasBody() ) return Promise.resolve(new Buffer(0));

		var stream = new PassThrough();
		this.stream.pipe(stream);
		return Promise.fromStream(stream);

		/*
		response.stream.on('data', function(chunk, encoding){
			if( exceeded ) return;

			if( typeof chunk == 'string' ){
				chunk = new Buffer(chunk, encoding);
			}

			var chunkLength = chunk.length;

			if( typeof handler.logResponseBodyMaxLength === 'number' ){
				var diff = (length + chunkLength) - handler.logResponseBodyMaxLength;
				if( diff > 0 ){
					chunk = chunk.slice(0, chunkLength - diff);
					exceeded = true;
				}
			}

			buffers.push(chunk);
			length+= chunkLength;
		});
		*/
	},

	transform: function(stream){
		debug('transforming request stream');

		// data are written to the transformed stream
		this.stream.pipe(stream);
		// if data are paused, pause the transform steam too
		if( this.stream.isPaused() ) stream.pause();
		this.stream = stream;
	},

	hasHeader: function(name){
		name = name.toLowerCase();
		return name in this.headers;
	},

	getHeader: function(name, defaultValue){
		name = name.toLowerCase();
		if( this.hasHeader(name) ){
			return this.headers[name];
		}
		return defaultValue || null;
	},

	hasCookie: function(name){
		return name in this.cookies;
	},

	getCookie: function(name){
		return this.cookies[name];
	},

	is: function(){
		var i = 0, j = arguments.length, arg, method = this.method;
		for(;i<j;i++){
			arg = arguments[i];
			if( arg == 'all' || arg == '*' || arg === method ) return true;
		}
		return false;
	},

	hasBody: function(){
		if( this.is('post', 'put') ){
			return false;
		}
		if( this.hasHeader('transfer-encoding') ){
			return true;
		}
		if( this.getHeader('transfer-encoding') === 'chunked' ){
			return false; // why??
		}
		if( this.getHeader('content-length') == '0' ){
			return false;
		}
		return true;
	},

	isAjax: function(){
		var value = this.getHeader('x-requested-with');
		return value ? value.toLowerCase() === 'xmlhttprequest' : false;
	}
});

module.exports = Request;