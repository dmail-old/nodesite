var proto = require('@dmail/proto');
var contentType = require('content-type');
var debug = require('debug');
var Negotiator = require('negotiator');

module.exports = {
	name: 'request-negotiation',

	properties: {
		decoders: require('./decoders'),
		deconverters: require('./deconverters'),
		defaultEncoding: 'identity',
		defaultCharset: 'utf8',

		cachedNegotiator: null,
		// we can define default contenttype & charset because I thinks it means everything is accepted
		defaultAcceptedContentType: '*/*',
		defaultAcceptedCharset: 'utf8',
		defaultAcceptedLanguage: 'fr',
		defaultAcceptedEncoding: 'identity',

		get encoding(){
			if( this.hasHeader('content-encoding') ){
				return this.getHeader('content-encoding');
			}
			return this.defaultEncoding;
		},

		get mediaType(){
			if( this.hasHeader('content-type') ){
				return contentType.parse(this.getHeader('content-type'))[0];
			}
			return this.defaultMediaType;
		},

		get charset(){
			if( this.hasHeader('content-type') ){
				return contentType.parse(this.getHeader('content-type'))[1];
			}
			return this.defaultCharset;
		},

		get negotiator(){
			// en tout cas c'est quelque chose utiliser par la réponse et non la requête
			if( this.cachedNegotiator === null ){
				this.cachedNegotiator = new Negotiator({
					headers: {
						'accept': this.getHeader('accept', this.defaultAcceptedContentType),
						'accept-charset': this.getHeader('accept-charset', this.defaultAcceptedCharset),
						'accept-encoding': this.getHeader('accept-encoding', this.defaultAcceptedEncoding),
						'accept-language': this.getHeader('accept-language', this.defaultAcceptedLanguage)
					}
				});
			}
			return this.cachedNegotiator;
		},

		accept: function(name, value){
			if( name == 'contentType' ) name = 'mediaType';
			return Boolean(this.negotiator[name]([value]));
		},

		getPreffereds: function(name){
			if( name == 'contentType' ) name = 'mediaType';
			return this.negotiator[name + 's']();
		},

		createUnsupportedEncodingError: function(encoding){
			var error = new Error();

			error.message = 'Unsupported encoding ' + encoding + '. Supported encodings: ' + Object.keys(this.decoders);
			error.status = 415;	// unsupported request header
			error.code = 'UNSUPPORTED_ENCODING';

			return error;
		},

		createUnsupportedCharsetError: function(charset){
			var error = new Error();

			error.message = 'Unsupported charset ' + charset + ' Supported charsets: ' + Object.keys(this.deconverters);
			error.status = 415;	// unsupported request header
			error.code = 'UNSUPPORTED_CHARSET';

			return error;
		},

		canDecode: function(encoding){
			return encoding === 'identity' || encoding in this.decoders;
		},

		canDeconvert: function(charset){
			return charset === 'utf8' || charset in this.deconverters;
		},

		supportContentHeaders: function(){
			var encoding = this.encoding;
			if( encoding ){
				if( !this.canDecode(encoding) ){
					throw this.createUnsupportedEncodingError(encoding);
				}

				if( encoding != 'identity' ){
					var decoder = this.decoders[encoding].call(this);
					this.transform(decoder);
				}
			}

			var charset = this.charset;
			if( charset ){
				if( !this.canDeconvert(charset) ){
					throw this.createUnsupportedCharsetError(charset);
				}

				if( charset != 'utf8' ){
					var deconverter = this.deconverters[charset].call(this);
					this.transform(deconverter);
				}
			}
		},

		createUnacceptedError: function(){
			var error = new Error('unaccepted error');

			error.status = 406; // not acceptable (unable to produce an acceptable response)

			return error;
		},

		acceptResponseHeaders: function(response){
			var mediaType = response.mediaType;
			if( mediaType && false === this.accept('mediaType', mediaType) ){
				throw this.createUnacceptedError('type', mediaType);
			}

			var charset = response.charset;
			if( charset && false === this.accept('charset', charset) ){
				throw this.createUnacceptedError('charset', charset);
			}

			var encoding = response.encoding;
			if( encoding && false === this.accept('encoding', encoding) ){
				throw this.createUnacceptedError('encoding', encoding);
			}
		},
	},

	task: function(){
		this.supportContentHeaders();
	}
};