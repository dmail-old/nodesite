/*

name: Request

description: Helper for node request

making response & request streamable
https://github.com/mjijackson/mach/blob/master/modules/request.js

inspiration:
restify: https://github.com/mcavage/node-restify

*/

var proto = require('proto');
var stream = require('stream');
var PassThrough = stream.PassThrough;
var debug = require('debug');
require('promise/fromStream');
require('promise/reduce');
require('object/assign');
require('object/define');
require('array/prototype/findIndex');
require('array/prototype/every');

// proto.extend(HttpObject)
var Request = proto.extend({
	URL: require('url'),
	QueryString: require('querystring'),

	tasks: [],
	hooks: {
		url: function(){
			this.url = this.URL.parse(this.url);
			this.url.toString = function(){ return this.href; };
			this.url.pathname = this.QueryString.unescape(this.url.pathname);
			this.urlParams = this.QueryString.parse(this.url.query);
		},

		method: function(method){
			this.method = method.toLowerCase();
		},

		headers: function(headers){
			if( headers == null ) this.headers = this.constructor.headers;
		},

		cookies: function(cookies){
			if( cookies == null ) this.cookies = this.constructor.cookies;
		},

		body: function(body){
			if( body == null ){
				this.stream.end();
			}
			else if( body instanceof stream.Readable ){
				body.pipe(this.stream);
			}
			else{
				this.stream.write(body);
				this.stream.end();
			}
		}
	},

	httpVersion: '1.1',
	method: 'get',
	url: '',
	headers: {},
	body: null,
	trailers: {},
	stream: null,

	urlParams: {},
	cookies: {},

	constructor: function(){
		this.promise = new Promise(function(resolve, reject){
			this._resolve = resolve;
		}.bind(this));

		this.stream = new PassThrough();
	},

	populate: function(properties){
		Object.assign(this, properties);
		for(var name in this.hooks){
			this.hooks[name].call(this, this[name]);
		}
	},

	// resolve the request object, can be called once
	resolve: function(properties){
		this.populate(properties);
		this._resolve(Promise.reduce(this.tasks, this).then(function(){
			return this;
		}.bind(this)));
	},

	// return a promise fullfilled when the request is ready to be used
	ready: function(){
		return this.promise;
	},

	// return a body promise, consuming the stream
	consume: function(){
		if( !this.bodyPromise ){
			this.bodyPromise = this.ready().then(function(){
				return this.hasBody() ? Promise.fromStream(this.stream) : Promise.resolve(new Buffer(0));
			}.bind(this));
		}
		return this.bodyPromise;
	},

	// returns a stream filled with data of this stream (avoid to consume this stream to get data)
	read: function(){
		if( this.hasBody() ){
			return this.stream.pipe(new PassThrough());
		}
		else{
			return new PassThrough().end();
		}
	},

	transform: function(stream){
		debug('transforming request stream');

		// data are written to the transformed stream
		this.stream.pipe(stream);
		// if data are paused, pause the transform steam too
		if( this.stream.isPaused() ) stream.pause();
		this.stream = stream;
	},

	hasHeader: function(name){
		name = name.toLowerCase();
		return name in this.headers;
	},

	getHeader: function(name, defaultValue){
		name = name.toLowerCase();
		if( this.hasHeader(name) ){
			return this.headers[name];
		}
		return defaultValue || null;
	},

	setHeader: function(name, value){
		name = name.toLowerCase();
		this.headers[name] = value;
	},

	hasCookie: function(name){
		return name in this.cookies;
	},

	getCookie: function(name){
		return this.cookies[name];
	},

	is: function(){
		var i = 0, j = arguments.length, arg, method = this.method;
		for(;i<j;i++){
			arg = arguments[i];
			if( arg == 'all' || arg == '*' || arg === method ) return true;
		}
		return false;
	},

	hasBody: function(){
		return this.hasOwnProperty('body');
	},

	isAjax: function(){
		var value = this.getHeader('x-requested-with');
		return value ? value.toLowerCase() === 'xmlhttprequest' : false;
	}
});

Object.defineProperty(Request, 'stream', {
	enumerable: false,
	configurable: true,
	value: null
});

var PluginManager = require('plugin-manager');
var RequestPluginManager = PluginManager.extend({
	effects: {
		properties: function(request, properties){
			Object.define(request, properties);
		},

		task: function(request, task){
			request.tasks.push(task);
		}
	}
});

Request.createProto = function(){
	var pluginManager = RequestPluginManager.create(arguments);
	var requestProto = pluginManager.createObject(this);

	requestProto.tasks = [];

	pluginManager.extendObject(requestProto);

	return requestProto;
};

module.exports = Request;