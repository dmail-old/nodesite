/*

name: Request

description: Helper for node request

making response & request streamable
https://github.com/mjijackson/mach/blob/master/modules/request.js

inspiration:
restify: https://github.com/mcavage/node-restify

*/

var proto = require('proto');
var stream = require('stream');
var PassThrough = stream.PassThrough;
var debug = require('debug');
require('promise/fromStream');
require('promise/reduce');
require('object/assign');
require('object/define');
require('array/prototype/findIndex');
require('array/prototype/every');

// proto.extend(HttpObject)
var Request = proto.extend({
	URL: require('url'),
	QueryString: require('querystring'),

	plugins: [],
	tasks: [],
	hooks: {
		url: function(){
			this.url = this.URL.parse(this.url);
			this.url.toString = function(){ return this.href; };
			this.url.pathname = this.QueryString.unescape(this.url.pathname);
			this.urlParams = this.QueryString.parse(this.url.query);
		},

		method: function(method){
			this.method = method.toLowerCase();
		},

		headers: function(headers){
			if( headers == null ) this.headers = this.constructor.headers;
		},

		cookies: function(cookies){
			if( cookies == null ) this.cookies = this.constructor.cookies;
		},

		body: function(body){
			if( body == null ){
				this.stream.end();
			}
			else if( body instanceof stream.Readable ){
				body.pipe(this.stream);
			}
			else{
				this.stream.write(body);
				this.stream.end();
			}
		}
	},

	httpVersion: '1.1',
	method: 'get',
	url: '',
	headers: {},
	body: null,
	trailers: {},
	stream: null,

	urlParams: {},
	cookies: {},

	constructor: function(){
		this.promise = new Promise(function(resolve, reject){
			this._resolve = resolve;
		}.bind(this));

		this.stream = new PassThrough();
	},

	populate: function(properties){
		Object.assign(this, properties);
		for(var name in this.hooks){
			this.hooks[name].call(this, this[name]);
		}
	},

	// resolve the request object, can be called once
	resolve: function(properties){
		this.populate(properties);
		this._resolve(Promise.reduce(this.tasks, this).then(function(){
			return this;
		}.bind(this)));
	},

	// return a promise fullfilled when the request is ready to be used
	ready: function(){
		return this.promise;
	},

	// return a body promise, consuming the stream
	consume: function(){
		if( !this.bodyPromise ){
			this.bodyPromise = this.ready().then(function(){
				return this.hasBody() ? Promise.fromStream(this.stream) : Promise.resolve(new Buffer(0));
			}.bind(this));
		}
		return this.bodyPromise;
	},

	// returns a stream filled with data of this stream (avoid to consume this stream to get data)
	read: function(){
		if( this.hasBody() ){
			return this.stream.pipe(new PassThrough());
		}
		else{
			return new PassThrough().end();
		}
	},

	transform: function(stream){
		debug('transforming request stream');

		// data are written to the transformed stream
		this.stream.pipe(stream);
		// if data are paused, pause the transform steam too
		if( this.stream.isPaused() ) stream.pause();
		this.stream = stream;
	},

	hasHeader: function(name){
		name = name.toLowerCase();
		return name in this.headers;
	},

	getHeader: function(name, defaultValue){
		name = name.toLowerCase();
		if( this.hasHeader(name) ){
			return this.headers[name];
		}
		return defaultValue || null;
	},

	setHeader: function(name, value){
		name = name.toLowerCase();
		this.headers[name] = value;
	},

	hasCookie: function(name){
		return name in this.cookies;
	},

	getCookie: function(name){
		return this.cookies[name];
	},

	is: function(){
		var i = 0, j = arguments.length, arg, method = this.method;
		for(;i<j;i++){
			arg = arguments[i];
			if( arg == 'all' || arg == '*' || arg === method ) return true;
		}
		return false;
	},

	hasBody: function(){
		return this.hasOwnProperty('body');
	},

	isAjax: function(){
		var value = this.getHeader('x-requested-with');
		return value ? value.toLowerCase() === 'xmlhttprequest' : false;
	}
});

Object.assign(Request, {
	plugins: [],

	create: function(plugins){
		var customRequest = proto.extend(this, {
			plugins: [],
			tasks: []
		});

		if( plugins && !Array.isArray(plugins) ){
			plugins = [plugins];
		}

		plugins.forEach(function(plugin){
			customRequest.addPlugin(plugin);
		});

		return customRequest;
	}
});

var Factory = proto.create({
	plugins: null,

	constructor: function(object, plugins){
		this.object = object;
		this.plugins = plugins || [];
	},

	create: function(){
		var customObject = proto.extend(this.object, {
			t: customObject.super.create.call(this)
		});

		customObject.create = function(){
			this.plugins.forEach(function(plugin){
				if( plugin.hasOwnProperty('constructor') ){
					plugin.constructor.call(this);
				}
			}, this);

		};

		return customObject;
	},

	hasPlugin: function(name){
		this.pluginIndex = this.plugins.findIndex(function(plugin){ return plugin.name == name; });
		return this.pluginIndex !== -1;
	},

	getPlugin: function(name){
		return this.hasPlugin(name) ? this.plugins[this.pluginIndex] : null;
	},

	addPlugin: function(plugin){
		if( Object(plugin) != plugin ) throw new TypeError('plugin must be an object');
		if( this.hasPlugin(plugin.name) ) return;

		if( plugin.dependencies && !plugin.dependencies.every(this.hasPlugin, this) ){
			throw new Error('missing request plugin');
		}

		this.plugins.push(plugin);
		if( plugin.properties ) Object.define(this, plugin.properties);
		if( plugin.task ) this.tasks.push(plugin.task);
	},

	removePlugin: function(name){
		if( this.hasPlugin(name) ){
			var plugin = this.plugins[this.pluginIndex];
			this.plugins.splice(this.pluginIndex, 1);
			this.tasks.splice(this.pluginIndex);
			// it's complex to remove properties
		}
	},

	registerPlugin: function(name, plugin){
		if( !this.hasPlugin(name) ){
			plugin.name = name;
			this.plugins.push(plugin);
		}
	}
});

Object.defineProperty(Request, 'stream', {
	enumerable: false,
	configurable: true,
	value: null
});

module.exports = Request;