/*

Response is missing the connection keep alive and transfer encoding chunked headers
because of this
https://github.com/joyent/node/blob/master/lib/_http_outgoing.js#L261


*/

var StringTemplate = require('StringTemplate');
var ConsoleTemplate = require('LogStream/Log/ConsoleTemplate');
var TableTemplate = require('TableTemplate');
var debug = require('debug');

module.exports = {
	name: 'logger',

	request: {
		logBody: true,
		bodyLogMaxLength: 1000,
		stringTemplate: '{method} {url} HTTP/{httpVersion}\n{headers}{body}',

		get stringScope(){
			/*
			I have to log body as well here
			*/

			/*
			var headerTemplate = ConsoleTemplate.new('{key}: {value}');
			var headerString = headerTemplate.repeat(this.headers, '\n', function(headerValue, headerName){
				return {
					key: headerName,
					value: headerValue
				};
			});*/

			var table = new TableTemplate();

			table.addRows(Object.keys(this.headers || {}).map(function(name){
				return [name, this.headers[name]];
			}, this));
			table.className = 'headless';
			table.defineClass('headerName', ['bold', 'grey']);
			table.column(0).setWidth(20).setClass('headerName');

			var headerString = table.toString();

			//args: request.args ? ' ' + request.args : '',
			// request.method
			// user: request.user ? request.user.name : 'Anonymous',

			var body = this.logBody ? Buffer.concat(this.buffers) : 'body hidden';
			if( this.bodyLogLengthExceeded ) body+= '...';

			return {
				method: this.method,
				url: String(this.url),
				httpVersion: this.httpVersion,
				headers: headerString,
				body: body.length ? '\n' + body : ''
			};
		},

		toString: function(){
			return ConsoleTemplate.new(this.stringTemplate).render(this.stringScope);
		}
	},

	response: {
		logBody: true,
		bodyLogMaxLength: 1000,
		stringTemplate: '{statusCode} {statusMessage} {url} HTTP/1.1\n{headers}{body}',

		get stringScope(){
			var headerString = '';

			/*
			faudrais récup les vrais headers depuis cette chaine
			if( this.serverResponse._headerSent ){
				headerString = this.serverResponse._header;
				// remove first line statusCode + statusMessage + HTTP/1.1
				headerString = headerString.slice(headerString.indexOf('\n')+1);
				headerString = headerString.slice(0, -4); // header ends with \n\n I remove them
			}
			*/


			/*
			var headerTemplate = ConsoleTemplate.new('{key}: {value}');
			headerString = headerTemplate.repeat(this.headers, '\n', function(headerValue, headerName){
				return {
					key: headerName,
					value: headerValue
				};
			});
			*/

			var table = new TableTemplate();

			table.addRows(Object.keys(this.headers || {}).map(function(name){
				return [name, this.headers[name]];
			}, this));

			table.className = 'human';
			table.defineClass('headerName', ['bold', 'grey']);
			table.column(0).setWidth(20).setClass('headerName');
			table.sortRows(0, 1);

			headerString = table.toString();

			//'{user} {status} {url} {time}ms {body}''

			var body = this.logBody ? Buffer.concat(this.buffers) : 'body hidden';

			if( this.bodyLogLengthExceeded ) body+= '...';

			return {
				statusCode: this.statusCode,
				statusMessage: require('http').STATUS_CODES[this.statusCode] || 'unknown',
				url: this.request.url.pathname,
				headers: headerString,
				body: body.length ? '\n' + body : ''
			};
		},

		getStatusStyle: function(){
			var status = this.statusCode;

			if( status >= 500 ){
				return 'red';
			}
			if( status >= 400 ){
				return 'yellow';
			}
			if( status >= 300 ){
				return 'cyan';
			}
			if( status >= 200 ){
				return 'green';
			}
			return 'inherit';
		}
	},

	handle: function(handler){
		var request = handler.request, response = handler.response;
		var logger = handler.router.logger;

		var requestLength = 0;
		request.buffers = [];
		request.stream.on('data', function(chunk, encoding){
			if( request.logBody && !request.bodyLogLengthExceeded ){
				if( typeof chunk == 'string' ){
					chunk = new Buffer(chunk, encoding);
				}

				var chunkLength = chunk.length;

				if( typeof request.bodyLogMaxLength === 'number' ){
					var diff = (requestLength + chunkLength) - request.bodyLogMaxLength;
					if( diff > 0 ){
						chunk = chunk.slice(0, chunkLength - diff);
						request.bodyLogLengthExceeded = true;
					}
				}

				request.buffers.push(chunk);
				requestLength+= chunkLength;
			}
		});

		logger.log(request.stringTemplate, request.stringScope, {
			method : 'magenta'
		});

		var responseLength = 0;
		response.buffers = [];
		response.stream.on('data', function(chunk, encoding){
			if( response.logBody && !response.bodyLogLengthExceeded ){
				if( typeof chunk == 'string' ){
					chunk = new Buffer(chunk, encoding);
				}

				var chunkLength = chunk.length;

				if( typeof response.bodyLogMaxLength === 'number' ){
					var diff = (responseLength + chunkLength) - response.bodyLogMaxLength;
					if( diff > 0 ){
						chunk = chunk.slice(0, chunkLength - diff);
						response.bodyLogLengthExceeded = true;
					}
				}

				response.buffers.push(chunk);
				responseLength+= chunkLength;
			}
		});

		// lorsque la requête est terminée, on la log
		// 'finish' c'est lorsque tout à été écrit (sinon x-response-time serait faussement court)
		response.serverResponse.on('finish', function(){
			logger.log(response.stringTemplate, response.stringScope, {
				statusCode: response.getStatusStyle(),
				time: 'grey',
				body: 'grey'
			});
		});
	},

	use: function(router, logger){
		if( logger ) router.logger = logger;
	}
};