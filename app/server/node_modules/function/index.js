var randomString = require('String.random');
var extra = require('fs.extra');
var crypto = require('crypto');
var property = require('property');

module.exports = {
	loadLanguageDirectory: function(dirname){
		var lang = {};
		var files = extra.readdirSyncRecursive(dirname);

		files.forEach(function(fileName){
			Object.define(lang, require(fileName));
		});

		return lang;
	},

	applyScript: function(path, bind, args, callback){
		if( typeof callback != 'function' ){
			throw new Error('callback expected');
		}

		var module, count;

		try{
			module = require(path);
		}
		catch(e){
			return callback(e);
		}

		if( typeof module != 'function' ){
			return callback(new Error('script at ' + path + ' is not callable'));
		}

		args = args || [];
		count = module.length - 1;

		if( count > 0 && count != args.length ){
			// if( Function.argumentNames(module)[count + 1] == 'callback' ){
			return callback(new Error(path + ' expect exactly ' + count + ' arguments ' + args.length + ' given'));
			// }
		}

		args = [].concat(args);
		args.push(callback);

		try{
			module.apply(bind, args);
		}
		catch(e){
			return callback(e);
		}
	},

	callScript: function(path, bind){
		var args = Array.slice(arguments, 2), callback = args.pop();
		return this.applyScript(path, bind, args, callback);
	},

	md5: function(string){
		var hash = crypto.createHash('md5');
		return hash.update(string).digest('hex');
	},

	// retourne une chaine unique
	generateUID: function(){
		// gènère la chaîne à laquelle on ajoute process.hrtime()[1] (current timestamp in ms) pour la rendre unique
		return this.md5(randomString.generate(16) + process.hrtime()[1] + randomString.generate(16));
	}
};
