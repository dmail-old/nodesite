/*
https://github.com/mcavage/node-restify/blob/master/lib/plugins/fielded_text_body_parser.js
http://stackoverflow.com/a/12785546/1685418


la première partie peut être des headers, faut donc un splitter spécial pour ces parties

le stringifier: https://github.com/wdavidw/node-csv/blob/master/lib/stringifier.js

*/

var Part = require('../FileTemplate/Part');
var SeparedPart = Part.extend({
	values: [],

	parse: function(string){
		// pareil ici on feras JSON.parse sur la chaine, on doit recevoir un tableau en retour
		// du coup on apelleras ce format plutot JSONValues

		var splitter = CSVSplitter.new(string);
		return splitter.split()[0].values;
	},

	replacer: function(value, index){
		return value;
	},

	stringify: function(object, replacer){
		/*
		on va juste faire un JSON.stringify sur le tableau, ce qui s'occuperas des ',' et quotes etc
		JSON.stringify()
		*/

		var string;

		if( replacer ) this.replacer = replacer;

		if( typeof object == 'object' ){
			var values = object, i, j, value, containsQuote, keys;

			if( !(values instanceof Array) ){
				keys = Object.getOwnPropertyNames(object);
				values = [];
				i = 0;
				j = keys.length;
				for(;i<j;i++){
					values.push(object[keys[i]]);
				}
			}

			/*
			inspired from: https://github.com/wdavidw/node-csv/blob/master/lib/stringifier.js
			*/
			i = 0;
			j = values.length;
			string = '';
			for(;i<j;i++){
				value = values[i];
				value = String(value);
				containsQuote = value.indexOf(this.quote) >= 0;
				
				if( containsQuote ){
					value = value.replace(new RegExp(this.quote, 'g'), this.escape + this.quote);
				}
				if( containsQuote || value.indexOf(this.delimiter) >= 0 || value.indexOf(this.separator) >= 0 ){
					value = this.quote + this.replacer(value, i) + this.quote;
				}

				string+= value;
			}
		}
		else if( typeof object == 'string' ){
			string = object;
		}

		return string;
	},

	get item(){
		if( this.headers ){
			var values = this.object, i = 0, j = this.values.length, object = {};

			for(;i<j;i++){
				object[this.headers[i]] = values[i];
			}

			return object;
		}
		else{
			return this.object;
		}
	}
});

var DelimitedPart = {
	index: null,
	source: '',

	set value(value){
		this.source = value;
		this.replace(value);
	},

	get value(){
		return this.source;
	}
};

var Splitter = require('Splitter');
var CSVSplitter = Splitter.extend({
	separator: '\n',
	delimiter: ',',
	escape: '"',
	quote: '"',
	headers: null,

	reviver: function(value, index){
		if( value == 'true' ) return true;
		if( value == 'false' ) return false;

		if( value.contains(this.quote) ){
			value = value.replace(new RegExp(this.quote, 'g'), '');
		}

		// chuis pas sur de moi alors ça on le feras ptet que si le schéma précise que c'est un nombre
		// if( !isNaN(value) ) return parseInt(value, 10);
		// date et regexp on pourrait aussi

		return value;
	},

	createValue: function(){
		return PartValue.new();
	},

	// https://github.com/wdavidw/node-csv/blob/master/lib/parser.js
	nextPart: function(){
		var index, source, length, start, charCodeAt, charCode, quoting, values, valueIndex, value, part;

		index = this.index;
		source = this.source;
		length = source.length;
		start = index;
		quoting = false;
		values = [];

		while( index <= length ){
			charCode = this.charCodeAt(source, index);

			if( charCode === this.escape ){
				// skip next char if escape is not a quote
				if( this.quote !== this.escape ){
					index++;
				}
			}
			else if( charCode == this.quote ){
				// start quoting from here
				if( quoting === false ){
					quoting = index;
				}
				// end previous quote, now separator & delimiter can be catched
				else{
					// if nextchar is not a separator or a delimiter it's an error, but we won't catch this
					quoting = false;
				}
			}
			// we are in a quote, everything is ignored except quote and escape
			else if( quoting !== false ){

			}
			else if( charCode === this.delimiter || charCode === this.separator || index === length ){
				
				value = this.createValue();
				value.source = this.reviver(source.slice(valueIndex, index), values.length - 1);
				value.index = valueIndex;
				values.push(value);

				if( charCode === this.delimiter ){
					valueIndex = this.index + 1; // this.delimiter.length;
					quoting = false;
				}
				else{
					if( typeof quoting == 'number' ){
						throw new Error('unterminated quote at' + quoting);
					}

					part = this.createPart();
					part.index = this.index;
					part.source = source.slice(this.index, index);
					part.values = values;

					return part;
				}
			}

			index++;
		}
	}
});

module.exports = SeparatedValuePart;