/*

ComputedStream c'est cool mais en fait je m'en sers comme cela:

requestStream = readablestream où je veux modifier ce que je lit
responseStream = writableStream où je veux modifier ce que j'écrit

// lorsqu'on veut lire le body de request on lit depuis rawstream
request.pipe = function(writableStream){
	var rawStream = new RawStream();
	rawStream.encoding = request.encoding;
	rawStream.charset = request.charset;
	this.serverRequest.pipe(rawStream);
	rawStream.pipe(writableStream);
}

*/

var ComputedStream = require('ComputedStream');
var proto = require('proto');

var ProcessedStream = proto.extend(ComputedStream, {
	encoders: require('./encoders'),
	converters: require('./converters'),

	sourceEncoding: 'identity',
	sourceCharset: 'utf8',
	encoding: 'identity',
	charset: 'utf8',

	constructor: function(){
		return ComputedStream.call(this, {
			writableObjectMode: true
		});
	},

	supportEncoding: function(encoding){
		return encoding in this.encoders;
	},

	supportCharset: function(charset){
		return charset in this.converters;
	},

	encode: function(encoding){
		if( encoding != this.encoding ){
			if( this.canEncode(encoding) ){
				this.chain(this.encoders[encoding].call(this));
			}
			else{
				this.emit('error', new Error('cannot encode ' + encoding));
			}
		}
	},

	convert: function(charset){
		if( charset != this.charset ){
			if( this.canConvert(charset) ){
				this.chain(this.converters[charset].call(this));
			}
			else{
				this.emit('error', new Error('cannot convert  ' + charset));
			}
		}
	},

	_transform: function(chunk, encoding, done){
		if( typeof chunk != 'string' && !Buffer.isBuffer(chunk) ){
			chunk = Object.toSource(chunk);
		}
		done();
	},

	_resolve: function(){
		this.encode(this.encoding);
		this.convert(this.charset);
		return ComputedStream._resolve.call(this);
	}
});

module.exports = ProcessedStream;