/*

ComputedStream c'est cool mais en fait je m'en sers comme cela:

requestStream = readablestream où je veux modifier ce que je lit
responseStream = writableStream où je veux modifier ce que j'écrit

// lorsqu'on veut lire le body de request on lit depuis rawstream
request.pipe = function(writableStream){
	var rawStream = new RawStream();
	rawStream.encoding = request.encoding;
	rawStream.charset = request.charset;
	this.serverRequest.pipe(rawStream);
	rawStream.pipe(writableStream);
}

*/

var ComputedStream = require('ComputedStream');
var proto = require('proto');

var ProcessedStream = proto.extend(ComputedStream, {
	encoders: require('./encoders'),
	converters: require('./converters'),

	encoding: 'identity',
	charset: 'utf8',
	outputEncoding: 'identity',
	outputCharset: 'utf8',

	constructor: function(){
		return ComputedStream.call(this, {
			//writableObjectMode: true
		});
	},

	supportEncoding: function(encoding){
		return encoding === 'identity' || encoding in this.encoders;
	},

	supportCharset: function(charset){
		return charset === 'utf8' || charset in this.converters;
	},

	encode: function(encoding){
		if( encoding != 'identity' && encoding != this.encoding ){
			if( this.supportEncoding(encoding) ){
				this.chain(this.encoders[encoding].call(this));
			}
			else{
				this.emit('error', new Error('cannot encode ' + encoding));
			}
		}
	},

	convert: function(charset){
		if( charset != 'utf8' && charset != this.charset ){
			if( this.supportCharset(charset) ){
				this.chain(this.converters[charset].call(this));
			}
			else{
				this.emit('error', new Error('cannot convert  ' + charset));
			}
		}
	},

	_resolve: function(){
		this.encode(this.outputEncoding);
		this.convert(this.outputCharset);
		return ComputedStream.prototype._resolve.call(this);
	}
});

module.exports = ProcessedStream;