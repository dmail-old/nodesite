/*

description: hold the couple request/response to handle a client request

*/
var Emitter = require('emitter');
var Demand = {
	AJAX_HEADER_NAME: 'x-requested-with',
	AJAX_HEADER_VALUE: 'xmlhttprequest',

	METHODS: {
		OPTIONS: 'OPTIONS',
		HEAD: 'HEAD',
		GET: 'GET',
		POST: 'POST',
		PUT: 'PUT',
		DELETE: 'DELETE'
	},

	acceptParser: require('./accept.js'),
	formats: require('./format.js'),

	request: null,
	response: null,
	method: null,
	status: null,
	headers: null,
	data: null,
	handlers: [],

	create: function(request, response){
		this.request = request;
		this.response = response;
		this.headers = {};
		this.method = this.request.method;
		this.emitter = Emitter.new(this);

		/*		
		var self = this;
		this.request.on('response', function(response){
			console.log('response');
			response.read();
			// response is an http_incomingmessage
			// see http://nodejs.org/api/http.html#http_http_incomingmessage
			self.emitter.emit('response', response);
		});
*/
	},

	addService: function(name){
		var service = require('./service/' + name + '.js');
		if( service ){
			this.supplement(service);
		}
	},

	addHandler: function(handler){
		if( typeof handler != 'function' ){
			var error = new TypeError('route.use expect a function handler '+ handler + ' given');
			console.error(error.stack);
		}
		else{
			this.handlers.push(handler);
		}
	},

	use: function(serviceName, handler){
		this.addService(serviceName);
		this.addHandler(handler);
	},

	isMethod: function(method){
		if( method == 'all' || method == '*' ) return true;
		return this.method.toLowerCase() === method;
	},

	isFromAjax: function(){
		return this.request.headers[this.AJAX_HEADER_NAME] == this.AJAX_HEADER_VALUE;
	},

	setHeader: function(name, value){
		this.headers[name] = value;
	},

	hasHeader: function(name){
		return name in this.headers;
	},

	getHeader: function(name){
		return this.headers[name];
	},

	removeHeader: function(name){
		delete this.headers[name];
	},

	setContentType: function(contentType, charset){
		if( contentType.startsWith('text') ){
			// this kind of header must be set for all textfile containing utf8 character?
			charset = charset || config.encoding;
			if( charset ) contentType+= ';charset=' + charset;
		}

		this.setHeader('content-type', contentType);
	},

	parseContentType: function(contentType){
		if( contentType ){
			var index = contentType.indexOf(';');
			if( index !== -1 ){
				contentType = contentType.slice(0, index);
			}
		}

		return contentType;
	},

	getContentType: function(){
		return this.parseContentType(this.getHeader('content-type'));
	},

	accept: function(contentType){
		return this.acceptParser.parse(this.request.headers.accept, [contentType]).length > 0;
	},

	prefferedContentType: function(){
		var accepts = this.acceptParser.parse(this.request.headers.accept);
		var i = 0, j = accepts.length, accept;

		for(;i<j;i++){
			accept = accepts[i];
			if( accept in this.formats ){
				return accept;
			}
		}

		return 'text/plain';
	},

	writeHead: function(status, headers){
		if( status ) this.status = status;
		if( headers ) this.headers = headers;

		this.emitter.emit('header');
		this.emitter.emit('response');

		var codes = require('http').STATUS_CODES;
		if( !(this.status in codes) ) this.status = 500;
		var desc = codes[this.status];

		this.response.writeHead(this.status, desc, this.headers);
	},

	write: function(data, encoding){
		this.response.write(data, encoding);
	},

	end: function(data, encoding){
		this.response.end(data, encoding);
	},

	format: function(data, encoding){
		var contentType;

		if( 'content-type' in this.headers ){
			contentType = this.getContentType();
		}
		else{
			contentType = this.prefferedContentType();
			this.setContentType(contentType);
		}

		// pas pour les fichiers
		if( data != null && !this.file ){
			if( contentType in this.formats ){
				data = this.formats[contentType].call(this, data, encoding);
			}
			else{
				this.status = 415; // unsupported content-type
			}
		}

		return data;

	},

	send: function(status, data, encoding){
		this.status = status;
		this.data = this.format(data, encoding);

		this.writeHead();

		if( this.data != null ){
			this.write(this.data, encoding);
		}

		this.end();
	},

	isErrorTraceAllowed: function(){
		return config.debug || (this.user && this.user.level == 1);
	},

	error: function(error){
		this.send(500, error);
	},

	parseJSON: function (json){
		if( typeof json == 'string' ){
			// decode URI component on json URI encoded string
			json = require('querystring').unescape(json);

			try{
				json = JSON.parse(json);
			}
			catch(e){
				json = null;
			}
		}

		return json;
	},

	start: function(){
		var self = this;
		var handlers = this.handlers, i = 0, j = handlers.length, handler, result;

		function nextHandler(error){
			// handler à retournée une erreur
			if( error ){
				return self.error(error);
			}

			// aucun handler n'a match
			if( i >= j ){
				// not found
				return self.send(404);
			}

			handler = handlers[i];
			i++;

			try{
				result = handler.call(self, nextHandler);
			}
			catch(e){
				console.error('handler internal error', e.stack);
				return self.error(e);
			}
		}

		nextHandler();
	}
};

module.exports = Demand;