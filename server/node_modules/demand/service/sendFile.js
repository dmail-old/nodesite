var FileResponse = {
	file: null,
	useStream: true,
	gzip: false,

	getModifiedSinceHeader: function(){
		var modified = this.request.headers['if-modified-since'];

		if( typeof modified == 'string' ){
			try{
				modified = new Date(modified);
			}
			catch(e){
				return null;
			}
		}

		return modified;
	},

	isModified: function(mtime){
		var modified = this.getModifiedSinceHeader();

		if( modified ){
			return mtime > modified;
		}

		return true;
	},

	streamFile: function(){
		this.writeHead(200);

		function ondata(data){
			var flushed = this.write(data);
			// Stoppe la lecture du flux lorsque la réponse est saturé
			if( !flushed ) this.streaming.pause();
		}

		function ondrain(){
			this.streaming.resume();
		}

		function end(){
			this.end();
		}

		this.streaming = this.file.readStream();
		this.streaming.on('data', ondata.bind(this));
		this.streaming.on('end', end.bind(this));
		// redémarre le streaming quand la réponse est de nouveau prète
		this.response.on('drain', ondrain.bind(this));
	},

	sendFileContent: function(data){
		this.send(200, data);
	},

	setFileHeaders: function(stat){
		this.setHeader('last-modified', stat.mtime);
		this.setHeader('content-length', stat.size);
		// évite que chrome mette en cache et réutilise sans redemander au serveur les fichier HTML qu'on lui envoit
		this.setHeader('cache-control', 'no-cache');
	},

	onread: function(error, data){
		if( error ) return this.error(error);
		this.sendFileContent(data);
	},

	readFile: function(){
		this.file.read(this.onread.bind(this));
	},

	fileStat: function(error, stat){
		// erreur pendant la récupération de infos du fichier
		if( error ) return this.error(error);
		// seul les fichiers sont autorisé
		if( !stat.isFile() ) return this.send(403);
		// dit au navigateur que le fichier n'a pas changé
		if( !this.isModified(stat.mtime) ) return this.send(304);
		
		this.setFileHeaders(stat);
		// only send headers
		if( this.method == this.METHODS.HEAD ) return this.send(200);

		if( this.useStream ){
			this.streamFile();
		}
		else{
			this.readFile();
		}
	},

	acceptEncoding: function(){
		var acceptEncoding = this.request.headers['accept-encoding'];

		/* Note: this is not a conformant accept-encoding parser.
		See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3
		*/
		return acceptEncoding && acceptEncoding.match(/\bgzip\b/);
	},

	fileExists: function(result){
		if( this.gzip ){
			if( result ){
				this.setHeader('content-encoding', 'gzip');
			}
			// si la version gz existe pas, tente de délivrer la version normale
			else{
				this.gzip = false;
				this.file.setPathPart('extension', '');
				this.file.exists(this.fileExists.bind(this));
				return;
			}
		}

		if( result === false ){
			this.send(404);
		}
		else{
			this.file.stat(this.fileStat.bind(this));
		}
	},

	sendFile: function(path, useStream){
		if( typeof useStream == 'boolean' ){
			this.useStream = useStream;
		}

		var file = NS.File.new(path), extension = file.getExtension();

		if( extension.charAt(0) == '.' ) extension = extension.substr(1);

		this.setContentType(config.getMimetype(file.path));

		if( (extension == 'js' || extension == 'css') && this.acceptEncoding() ){
			// essaye de délivrer le fichier en version compréssé
			file.setPath(file.path + '.gz');
			this.gzip = true;
		}

		this.file = file;
		this.file.exists(this.fileExists.bind(this));
	}
};

module.exports = FileResponse;