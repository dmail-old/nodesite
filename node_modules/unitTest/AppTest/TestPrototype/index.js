/*

maybe add a skip(reason) method a skip the test under some conditions (reason is optionnal)
and a method skipIf(condition, reason)

*/

var proto = require('proto');

var TestModel = proto.create({
	type: 'testPrototype',
	name: 'Anonymous test',
	state: 'created', // created, stopped, started, ended
	startTime: null,
	endTime: null,
	timeout: null,
	failed: false,
	lastError: null,
	handler: null,
	test: null,
	bind: null,

	init: function(name, test, bind){
		if( typeof name == 'string' ) this.name = name;
		if( arguments.length < 1 ) throw new TypeError('test expected');
		if( typeof test != 'function' ) throw new TypeError('test must be a function');

		this.test = test;
		if( arguments.length > 2 ) this.bind = bind;
	},

	handleEvent: function(e){
		if( this.hasOwnProperty('handler') ){
			this.handler.handleEvent(e);
		}
	},

	emit: function(type){
		// en attendant mieux on throw l'erreur
		// ceci se produit lorsqu'un module contient des erreur par exemple
		if( type == 'error' && !this.hasOwnProperty('handler') ){
			throw this.lastError;
		}

		var event = {
			type: this.type + '-' + type,
			target: this,
			args: arguments,
		};

		this.handleEvent(event);
	},

	// called before calling the test
	setup: function(){
		// noop
	},

	// called when the test has been called
	teardown: function(){
		// noop
	},

	// called to clean stuff when we want to rerun the tests while it was running
	clean: function(){
		// noop
	},

	run: function(){
		if( typeof this.bind != 'undefined' ) this.test.call(this.bind, this);
		else this.test(this);
	},

	ontimeout: function(){
		this.timer = null;
		var error = new Error('test takes too long');
		error.code = 'TEST_TIMEOUT';
		this.error(error);
	},

	start: function(){
		if( this.state == 'started' ){
			this.stop();
		}

		this.lastError = null;
		this.state = 'started';
		this.startTime = new Date().getTime();

		try{
			this.setup();
		}
		catch(e){
			return this.error(e);
		}

		this.emit('start');		

		try{
			this.run();
		}
		catch(e){
			return this.error(e);
		}

		if( this.state == 'started' && typeof this.timeout == 'number' ){
			this.timer = setTimeout(this.ontimeout.bind(this), this.timeout);
		}

		try{
			this.teardown();
		}
		catch(e){
			return this.error(e);
		}
	},

	restart: function(){
		this.emit('restart');
		
		if( this.state == 'started' ){
			this.stop();
		}
		else{
			this.clean();
		}

		this.start();
	},

	clearTimer: function(){
		if( this.timer != null ){
			clearTimeout(this.timer);
			this.timer = null;
		}
	},

	// test results are ignored
	stop: function(){
		if( this.state == 'started' ){
			this.state = 'stopped';
			this.emit('stop');
			this.clearTimer();
			this.clean();
		}
	},

	onend: function(){
		this.clean();

		if( this.state == 'ended' ){
			
			if( this.failed ){
				if( this.lastError ){
					this.emit('error');
				}
				this.emit('fail');
			}
			else{				
				this.emit('pass');
			}

			this.emit('end');
		}
	},

	end: function(failed){
		if( this.state == 'started' ){
			if( failed ){
				this.failed = true;
				if( failed instanceof Error ){
					this.lastError = failed;
				}
			}
			else{
				this.failed = true;
			}

			this.state = 'ended';
			this.endTime = new Date().getTime();
			this.clearTimer();
			//if( now ) this.onend();
			//else
			process.nextTick(this.onend.bind(this));
		}
	},

	fail: function(){
		this.end(true);
	},

	pass: function(){
		this.end(false);
	},

	error: function(error){
		this.end(error);
	},

	get duration(){
		return this.endTime - this.startTime;
	}
});

module.exports = TestModel;