/*

*/

process.on('uncaughtException', function(e){
	console.log('\n', e.stack, '\n');
	require('fs').appendFileSync('./error.log', e.stack + '\n');
});

setTimeout(function(){}, 1000 * 60 * 10);

var LogStream = require('LogStream');
var logger = LogStream.new();
var AppTest = require('./AppTest');
var path = require('path');
var appPath = path.normalize(process.argv[2]);
appPath = path.resolve(process.cwd(), appPath);

var appTest = AppTest.new(appPath);

logger.styles.source = {color: 'white', background: 'yellow'};
logger.styles.path = {color: 'magenta'};

// test loads should be separated from test runs

appTest.listener = {
	'appTest-start': function(e){
		// starting to tests all module found
		logger.info('Testing {count} module ...', this.tests.length);

		if( false && this.badSignaturePaths ){
			logger.styles.paths = {color: 'grey'};
			logger.warn('Folders have a module signature but are not modules : \n{paths}',
				this.badSignaturePaths.join('\n'));
		}
	},

	'testSerie-change': function(e){
		// a test file has been modified
		logger.info('{path} modified, tests will restart', e.target.path);
	},

	'moduleTest-change': function(e){
		// a module file has been modified
		logger.info('{path} modified, tests will restart', e.target.path);
	},

	'test-pass': function(e){
		logger.info('{name}', e.target.name);
	},

	'test-fail': function(e){
		var test = e.target, serie = test.testSerie, module = serie.moduleTest;
		var error = test.lastError;

		if( error.name == 'AssertionError' ){
			var lines = require('fs').readFileSync(error.file, 'utf8').split(/\n|\r\n\r/);
			var line = error.line;
			var contextDepth = 7;
			var minLine = Math.max(line - contextDepth, 0);
			var maxLine = Math.min(line + contextDepth, lines.length - 1);
			var content = lines.slice(minLine, maxLine);

			function toLines(lines, from, to){
				var output = '';
				var current = false;
				if( typeof to == 'undefined' ){
					to = from+1;
					current = true;
				}
			
				while(from != to){
					output+= require('ansi').stylize(from + 1, 'color', current ? 'white' : 'grey');
					output+= '  ' + lines[from];
					if( from != to ) output+= '\n';
					from++;
				}

				return output;
			}

			if( error.type == 'equal' ){
				error.message = error.args[0] + ' not equal to ' + error.args[1];
			}

			logger.error('{message} in {path}\n{above}{source}{under}', {
				message: error.message,
				path: error.file,
				above: toLines(lines, minLine, line),
				source: toLines(lines, line),
				under: toLines(lines, line + 1, maxLine)
			});
		}
		else{
			logger.error('{stack}', test.lastError.stack);	
		}				

		if( serie.isWatching ){
			logger.info('waiting for test or module changes to restart the tests');
		}		
	},

	'appTest-end': function(e){
		if( this.failedCount === 0 ){
			var appTest = e.target;
			logger.info('All tests passed in {duration} ms', appTest);
		}
	}
};

appTest.start();