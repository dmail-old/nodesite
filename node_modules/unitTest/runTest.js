/*

*/

process.on('uncaughtException', function(e){
	console.log('\n', e.stack, '\n');
	require('fs').appendFileSync('./error.log', e.stack + '\n');
});

setTimeout(function(){}, 1000 * 60 * 10);

var LogStream = require('LogStream');
var logger = LogStream.new();
var AppTest = require('./AppTest');
var path = require('path');
var appPath = path.normalize(process.argv[2]);
appPath = path.resolve(process.cwd(), appPath);
var appTest = AppTest.new(appPath);

appTest.listener = {
	'appTest-badSignature': function(e){
		logger.warn('Folders have a module signature but are not modules : \n {folders} \n', [e.target.badSignaturePaths]);
	},

	'appTest-start': function(e){
		// starting to tests all module found
		logger.info('Testing {count} module ...', this.tests.length);
	},

	'testSerie-change': function(e){
		// a test file has been modified
		logger.info('{path} modified, tests will restart', e.target.path);
	},

	'moduleTest-fail': function(e){
		throw new Error('here');
		logger.error(e.target.lastError);
	},

	'moduleTest-change': function(e){
		// a module file has been modified
		logger.info('{path} modified, tests will restart', e.target.path);
	},

	'moduleTest-start': function(e){
		// selon l'option ceci est mis dans un stream ou un buffer
		// si on fail on affiche tout, sinon on affiche rien
		logger.info(e.target.name);
	},

	'test-pass': function(e){
		// dans un buffer aussi
		logger.info('    ✔ {name}', e.target.name);
	},

	'test-fail': function(e){
		var test = e.target, serie = test.testSerie, module = serie.moduleTest;
		var message = '', i = 0, j = tests.length;

		logger.error('    ✖ {name} \n {error}', e.target.name, e.target.lastError);	

		if( testSerie.isWatching ){
			logger.info('waiting for test or module changes to restart the tests');
		}		
	},

	'appTest-end': function(e){
		if( this.failedCount == 0 ){
			var appTest = e.target;
			logger.info('All tests passed ({duration} ms)', appTest);
		}
	}
};

appTest.start();