/*

*/

process.on('uncaughtException', function(e){
	console.log('\n', e.stack, '\n');
	require('fs').appendFileSync('./error.log', e.stack + '\n');
});

setTimeout(function(){}, 1000 * 60 * 10);

var LogStream = require('LogStream');
var logger = LogStream.new();
var AppTest = require('./AppTest');
var path = require('path');
var appPath = path.normalize(process.argv[2]);
appPath = path.resolve(process.cwd(), appPath);

var appTest = AppTest.new(appPath);

logger.Log.registerStyles({
	path: 'magenta'
});

var LineLogTemplate = '{lineNumber} : {lineSource}';
var LineLogStyles = {
	lineNumber: 'grey',
	currentLineNumber: 'white',
	currentLineSource: 'white',
	currentLine: 'bg-yellow'
};
var LineLogSeparator = '\n';

var Log = LogStream.Log;
require('StringTemplate/TemplateRepeater');
var LineLog = Log.new(LineLogTemplate).registerStyles(LineLogStyles);

// test loads should be separated from test runs

appTest.listener = {
	'appTest-start': function(e){
		// starting to tests all module found
		logger.info('Testing {count} module ...', this.tests.length);

		if( false && this.badSignaturePaths ){
			logger.styles.paths = {color: 'grey'};
			logger.warn('Folders have a module signature but are not modules : \n{paths}',
				this.badSignaturePaths.join('\n'));
		}
	},

	'testSerie-change': function(e){
		// a test file has been modified
		logger.info('{path} modified, tests will restart', e.target.path);
	},

	'moduleTest-change': function(e){
		// a module file has been modified
		logger.info('{path} modified, tests will restart', e.target.path);
	},

	'test-pass': function(e){
		logger.info('{name}', e.target.name);
	},

	'test-fail': function(e){
		var test = e.target, serie = test.testSerie, module = serie.moduleTest;
		var error = test.lastError;

		if( error.name == 'AssertionError' ){
			var lines = require('fs').readFileSync(error.file, 'utf8').split(/\n|\r\n\r/);
			var contextDepth = 7;
			var line = error.line;
			var minLine = Math.max(line - contextDepth, 0);
			var maxLine = Math.min(line + contextDepth, lines.length - 1);
			
			lines = lines.slice(minLine, maxLine);

			var source = LineLog.repeat(lines, LineLogSeparator, function(log, index){
				log.exec({
					lineNumber: index,
					lineSource: log.scope
				});

				if( index == error.line ){
					log.globalStyle = 'currentLine';
					log.registerStyle('lineNumber', 'currentLineNumber');
				}

				return log;
			});

			if( error.type == 'equal' ){
				error.message = error.args[0] + ' not equal to ' + error.args[1];
			}

			logger.error('{message} in {path}\n{source}', {
				message: error.message,
				path: error.file,
				source: source
			});
		}
		else{
			logger.error('{stack}', test.lastError.stack);	
		}				

		if( serie.isWatching ){
			logger.info('waiting for test or module changes to restart the tests');
		}		
	},

	'appTest-end': function(e){
		if( this.failedCount === 0 ){
			var appTest = e.target;
			logger.info('All tests passed in {duration} ms', appTest);
		}
	}
};

appTest.start();