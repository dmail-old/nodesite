/*

if( this.isWatching ) this.watch();
isWatching: true, // watch for test change and rerun the test when file is changed
Watcher: require('watcher'),
watch: function(){
	this.Watcher.watch(this.path, this.change.bind(this), this.watchFilter.bind(this));
},
change: function(){
	// when the test is in created state, no need to restart anything
	if( this.state != 'created' ){
		this.emit('change');
		this.restart();
	}
},
watchFilter: function(){
	return true;
}
*/

var TestPrototype = require('../TestPrototype');

var TestSerie = TestPrototype.create({
	Test: require('../Test'),
	name: 'Anonymous testSerie',
	tests: null,

	init: function(tests){
		this.tests = tests;
	},

	load: function(path){
		
	},

	unload: function(path){
		
	},

	reload: function(){
		
	},

	onChange: function(){
		this.reload();
		// si en cours de traitement ou terminÃ©, restart
		if( this.state === 'started' || this.state === 'ended' ) this.restart(); 
	},

	createTest: function(){
		return this.Test.new.apply(this.Test, arguments);
	},

	add: function(){
		var test = this.createTest.apply(this, arguments);
		this.tests.push(test);
		return this;
	},

	setup: function(){
		this.index = 0;
		this.current = null;
	},

	teardown: function(){
		// something to do?
	},

	clean: function(){
		if( this.current ){
			this.current.stop();
		}
	},

	next: function(){
		if( this.index >= this.tests.length ){
			return null;
		}
		else{
			this.current = this.tests[this.index];
			this.index++;
			return this.current;
		}
	},

	nextTest: function(e){
		if( e ){
			/*
			var stackTrace = require('stackTrace');
			var call = stackTrace.findCallByFile(stackTrace.get(), this.testSerie.path);
			var line = call.getLineNumber();
			
						
			error.file = this.testSerie.path;
			error.line = line - 1;
			*/
			this.fail(e);
		}
		else if( this.next() ){
			this.current.start();
		}
		// all test passed with success or no test to run
		else{
			this.pass();
		}
	},

	_run: function(){
		this.nextTest();
	}
});

module.exports = TestSerie;