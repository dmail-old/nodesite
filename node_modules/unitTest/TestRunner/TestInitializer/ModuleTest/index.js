/*

sur un restart module pas besoin de recréer les series même si le module n'exporte plus la même chose
mais pour le moment on recrée tout m'en fous

*/

var TestSerie = require('../TestSerie');

var ModuleTest = TestSerie.create({
	clone: require('property/clone').cloneProperties,
	TestSerie: TestSerie,
	type: 'moduleTest',
	testPaths: null,
	isWatching: true, // watch for module change and auto runs all tests when it happens

	init: function(path, testPaths){
		this.name = path;
		this.path = path;
		this.testPaths = typeof testPaths == 'string' ? [testPaths] : testPaths;
		this.setupModule();
		this.watch();
	},

	clearCache: function(){
		for(var key in require.cache){
			delete require.cache[key];
		}
	},

	getDependencyLevel: function(){
		
		function dependencyLevel(module){
			var level = 0, children = module.children, i = 0, j = children.length, child, childLevel;

			if( j ){
				for(;i<j;i++){
					child = children[i];
					childLevel = dependencyLevel(child);
					level = Math.max(level, childLevel);
				}

				level++;
			}

			return level;
		}

		return dependencyLevel(this.module);		
	},

	createImports: function(){
		return this.clone(this.module.exports);
	},

	setupModule: function(){
		if( this.module === null ){
			/*
			il faut supprimer tous les modules qui ont été require par celui-ci
			ou alors il faudrais les recenser mais partons là dessus pour le moment
			il faut emptyCache parce que sinon les appels à require dans le modules
			sont ignorés, ils sont récup depuis le cache
			du coup on peut penser, à tort, qu'un module n'a pas de dépendence
			*/
			this.clearCache();
			require(this.path); // can throw errors
			this.module = require.cache[this.path];
			this.level = this.getDependencyLevel();
			this.imports = this.createImports();	
		}
	},

	teardownModule: function(){
		delete require.cache[this.path];
		this.module = null;
		this.imports = null;
	},

	// don't watch testFiles
	watchFilter: function(path){
		return this.testPaths.indexOf(path) === -1;
	},

	loadTests: function(){
		return [].concat(this.testPaths);
	},

	createTest: function(path){
		return this.TestSerie.new(path, this);
	},	

	toString: function(){
		return this.path.replace(global.APP_PATH, '').slice(1);
	}
});

module.exports = ModuleTest;