var proto = require('proto');

var Promise = proto.extend({
	state: 'pending',
	value: null,
	executor: null, // function(resolve, reject){},
	pendingList: null,
	Pending: null,

	constructor: function(executor){
		if( arguments.length === 0 ){
			throw new Error('missing executor function');
		}
		if( typeof executor != 'function' ){
			throw new TypeError('function expected as executor');
		}

		this.state = 'pending';
		this.executor = executor;
		this.resolver = this.resolve.bind(this);
		this.rejecter = this.reject.bind(this);

		try{
			executor(this.resolver, this.rejecter);
		}
		catch(e){
			this.reject(e);
		}
	},

	toString: function(){
		return '[object Promise]';
	},

	createPending: function(onresolve, onreject){
		return this.Pending.create(onresolve, onreject);
	},

	then: function(onresolve, onreject){
		if( onresolve && typeof onresolve != 'function' ){
			throw new TypeError('onResolve must be a function ' + onresolve + ' given');
		}
		if( onreject && typeof onreject != 'function' ){
			throw new TypeError('onReject must be a function ' + onreject + ' given');
		}

		var pending = this.createPending(onresolve, onreject);

		if( this.state === 'rejected' && !this.hasPending() ){
			clearImmediate(this.unhandled);
			this.unhandled = null;
		}

		this.addPending(pending);

		if( this.state !== 'pending' ){
			setImmediate(function(){
				this.startPending(pending);
			}.bind(this));
		}

		return pending;
	},

	catch: function(onreject){
		return this.then(null, onreject);
	},

	addPending: function(promise){
		this.pendingList = this.pendingList || [];
		this.pendingList.push(promise);
	},

	hasPending: function(){
		return this.pendingList != null && this.pendingList.length !== 0;
	},

	startPending: function(pending){
		pending.adoptState(this);
	},

	// called when the promise is settled
	clean: function(){
		if( this.pendingList ){
			this.pendingList.forEach(this.startPending, this);
		}
	},

	onFulFilled: function(value){
		this.clean();
	},

	onRejected: function(value){
		this.clean();

		// has no handler
		if( !this.hasPending() ){
			this.unhandled = setImmediate(function(){
				this.unhandled = null;
				if( !this.hasPending() ){
					if( process.listeners('unhandledRejection').length === 0 ){
						var mess = value instanceof Error ? value.stack : value;
						console.log('possibly unhandled rejection "' + mess + '" for promise', this);
					}
					process.emit('unhandledRejection', value, this);
				}
			}.bind(this));
		}
	},

	// returns true if thenable have been handled by resolve or reject
	checkThenable: function(thenable, resolve, reject){
		if( thenable === this ){
			reject(new TypeError('A promise cannot be resolved with itself'));
			return true;
		}

		if( thenable && (typeof thenable === 'object' || typeof thenable === 'function') ){
			var then;
			try{
				then = thenable.then;
			}
			catch(e){
				reject(e);
				return true;
			}

			if( typeof then === 'function' ){
				try{
					then.call(thenable, resolve, reject);
				}
				catch(e){
					reject(e);
				}
				return true;
			}
		}

		return false;
	},

	resolvedValueResolver: function(value){
		if( !this.checkThenable(value, this.resolver, this.rejecter) ){
			this.state = 'fulfilled';
			this.value = value;
			this.onFulFilled(value);
		}
	},

	resolve: function(value){
		if( this.state === 'pending' ){
			if( !this.resolving ){
				this.resolving = true;
				this.resolver = this.resolvedValueResolver.bind(this);
				this.resolver(value);
			}
		}
	},

	reject: function(value){
		if( this.state === 'pending' ){
			this.state = 'rejected';
			this.value = value;
			this.onRejected(value);
		}
	}
});

// PendingPromise, a promise waiting for an other promise to complete (created for each then() call)
var PendingPromise = proto.extend.call(Promise, {
	onresolve: null,
	onreject: null,

	constructor: function(onresolve, onreject){
		this.onresolve = onresolve;
		this.onreject = onreject;
		PendingPromise.super.constructor.call(this, this.executor);
	},

	executor: function(){
		// noop
	},

	adoptState: function(promise){
		var isResolved, fn, value, ret, error;

		value = promise.value;
		isResolved = promise.state === 'fulfilled';
		fn = isResolved ? this.onresolve : this.onreject;

		if( fn != null ){
			try{
				ret = fn(value);
			}
			catch(e){
				error = e;
			}

			if( error ){
				isResolved = false;
				value = error;
			}
			else{
				isResolved = true;
				value = ret;
			}
		}

		if( isResolved ){
			this.resolve(value);
		}
		else{
			this.reject(value);
		}
	}
});

Promise.Pending = PendingPromise;
Promise = Promise.constructor;

// que fait-on lorsque value est thenable?
Promise.resolve = function(value){
	return new this(function resolveExecutor(resolve){
		resolve(value);
	});
};

Promise.reject = function(value){
	return new this(function rejectExecutor(resolve, reject){
		reject(value);
	});
};

var forOf = require('for-of');
require('iterator/ArrayIterator');

Promise.all = function(iterable){
	return new this(function allExecutor(resolve, reject){
		function res(value, index){
			if( Promise.prototype.checkThenable(value, function(value){ res(value, index); }, reject) ){
				return;
			}
			values[index] = value;
			length--;
			if( length === 0 ) resolve(values);
		}

		var index = 0, length = 0, values = [];

		forOf(iterable, function(value){
			length++;
			res(value, index);
			index++;
		});

		if( length === 0 ) resolve(values);
	});
};

Promise.race = function(iterable){
	return new this(function(resolve, reject){
		forOf(iterable, function(thenable){
			thenable.then(resolve, reject);
		});
	});
};

Promise.unhandledHook = true;
Promise.polyfill = true;

module.exports = Promise;

// for now force promise polyfill because node 0.12 doesn't implement
// unhandled rejection hook -> shame on them
// dont force the polyfill more than once
var force;
if( 'Promise' in global && global.Promise.polyfill ){
	force = false;
}
else{
	force = true;
}

require('object/polyfill')('global', 'Promise', Promise, force);