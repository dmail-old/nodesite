exports['thenable called on resolve but not on reject'] = function(test){
	var resolvedPromise = Promise.resolve('ok');

	test.willResolve(Promise.resolve(resolvedPromise).then(function(value){
		test.equal(value, 'ok');
	}));
	test.willResolve(Promise.reject(resolvedPromise).catch(function(value){
		test.equal(value, resolvedPromise);
	}));
};

exports['unhandled rejection emitted'] = function(test, Promise){
	var promise = new Promise(function(resolve, reject){
		process.once('unhandledRejection', function(value, promise){
			resolve(value);
		});
	});

	var rejectValue = {};
	Promise.reject(rejectValue);

	test.willResolve(promise.then(function(value){
		test.equal(value, rejectValue);
	}));
};

exports['native Promise'] = function(test){
	if( global.Promise.polyfill !== true ) return;

	var Promise = global.Promise;

	test.willResolve(Promise.reject('rejected').then(function(){
		return 'resolved';
	}));
};

exports['promise must be polyfilled once'] = function(test){
	var oldPromise = global.Promise;

	delete require.cache[test.moduleTest.id];
	require(test.moduleTest.path);

	test.equal(oldPromise, global.Promise);
};