/*

logger y devrait de base être un stream qui output des données sous forme d'objet
donc mettre objectMode à true
ensuite je crée par exemple pour la console un transformstream qui transformeras les objet
passé au stream en chaine destinée à la console ou à un fichier

il faut donc créer ce stream spécifique qui va être pipe à celui ci
lorsque je pipe la console ou un fichier
la console facile à détecter (isTTY)
un fichier on peut considérer que c la manière par défaut de log

logger.rawStream.pipe // ça output du texte non coloré, dans le cas de admin.js serait vidé chaque jour
logger.coloredStream.pipe // ça output du coloré, dans le cas de admin.js rien à faire c'est dans la console
logger.machineStream.pipe // ça output du JSON représentant chaque ligne, dans le cas de admin.js serait sauvegardé
ailleurs pour être éventuellement analyser par la suite (on utiliserais pas ça a priori)

*/

// https://github.com/visionmedia/callsite/blob/master/lib/__stack.js
Object.defineProperty(global, '__stack', {
	get: function(){
		var orig = Error.prepareStackTrace;
		Error.prepareStackTrace = function(_, stack){ return stack; };
		var err = new Error();
		Error.captureStackTrace(err, arguments.callee);
		var stack = err.stack;
		Error.prepareStackTrace = orig;
		return stack;
	}
});

var Stream = require('stream');
var PassThrough = Stream.PassThrough;

var Logger = PassThrough.prototype.extend({
	ansi: require('ansi'),
	fileSystem: require('fs'),
	inspect: require('util').inspect,
	regexp: /{(.*?)}/g,
	styles: {},
	level: 'info',
	levels: ['info', 'debug', 'warn', 'error', 'fatal'],
	autoReturn: true,

	// options
	filePath: null,
	console: true,
	rawStream: null,
	
	colorize: true,
	depth: 2,
	showHidden: false,

	init: function(options){
		this.constructor.apply(this, arguments); // or Dupplex.apply(this, arguments)

		if( typeof options == 'string' ){
			options = {filePath: options};
		}

		for(var key in options){
			this[key] = options[key];
		}

		if( typeof this.filePath == 'string' ){
			this.pipe(this.createFileStream(this.filePath));
		}
		if( this.console === true ){
			this.pipe(process.stdout);
		}

		this.on('data', function(data){
			if( this.rawStream ){
				this.rawStream.write(this.ansi.removeStyles(data.toString()));
			}
		});
	},

	createFileStream: function(path){
		return this.fileSystem.createWriteStream(this.filePath, {flags: 'a', encoding: 'utf8', mode: 0666});
	},

	pipe: function(stream){
		// use ansi for console streams
		if( stream.isTTY || Logger.isPrototypeOf(stream) || stream === process.stdout ){
			PassThrough.prototype.pipe.call(this, stream);
		}
		// and raw data for other streams
		else{
			if( this.rawStream == null ) this.rawStream = new PassThrough();
			this.rawStream.pipe(stream);
		}		
		return stream;
	},

	stylize: function(str, styleName){
		if( styleName in this.styles ){
			str = this.ansi.stylizeAll(str, this.styles[styleName]);
		}
		return str;
	},

	_render: function(string, data, stylize){
		var self = this, i = 0;

		return string.replace(this.regexp, function(match, key){
			var value;

			if( data instanceof Array && i in data ){
				value = data[i];
				if( stylize ) value = self.stylize(value, key);
			}
			else if( typeof data == 'object' && key in data ){
				value = data[key];
				if( stylize ) value = self.stylize(value, key);
			}
			else{
				value = match;
			}

			i++;

			return value;
		});
	},

	render: function(level, message, data, stylize){
		if( typeof message != 'string' ){
			if( stylize ){
				stylize = !this.colorize;
				this.colorize = true;
			}

			message = this.stringify(message);

			if( stylize ) this.colorize = false;
		}

		message = this.createLevelMessage(level, message, stylize);

		if( data !== null ) message = this._render(message, data, stylize);

		if( this.autoReturn ) message+= '\n';

		return message;
	},

	createDebugMessage: function(message, stylize){
		var call, wrap, lineFile, lineNumber, fileContent, lineContent, levelPrefix;

		call = global.__stack[1];
		lineFile = call.getFileName();
		lineNumber = call.getFileNumber();
		fileContent = this.fileSystem.readFileSync(lineFile, 'utf8');
		lineContent = fileContent.split('\n')[lineNumber];
		lineContent = lineContent.replace(/\n|\r/, '');
		message = message.replace(/\n|\r/g, function(match){ return match + '{debug}: '; });

		wrap = '\
			{debug}: \n\
			{debug}: {lineContent} ({lineFile: {lineNumber}})\n\
			{debug}: {message}\n\
			{debug}: \
		';

		return this._render(wrap, {
			debug: 'debug',
			message: message,
			lineContent: lineContent,
			lineFile: lineFile,
			lineNumber: lineNumber
		}, stylize);
	},

	createLevelMessage: function(level, message, stylize){
		if( level === 'debug' ){
			return this.createDebugMessage(message, stylize);
		}
		if( stylize ){
			return this.stylize(level, level) + ': ' + message;
		}
		return level + ': ' + message;
	},

	stringify: function(item){
		return this.inspect(item, {
			showHidden: this.showHidden,
			depth: this.depth,
			colors: this.colorize,
			customInspect: true
		});
	},

	getLevelIndex: function(level){
		return this.levels.indexOf(level);
	},

	canLog: function(level){
		return this.getLevelIndex(level) >= this.getLevelIndex(this.level);
	},

	log: function(level, message, data){
		if( this.canLog(level) ){
			if( arguments.length > 3 || typeof data != 'object' ){
				data = Array.prototype.slice.call(arguments, 2);
			}

			this.write(this.render(level, message, data, true));
			//if( this.rawStream ) this.rawStream.write(this.render(level, message, data, false));

			return true;
		}
		return false;
	}
});

Logger.styles = {
	'info': {color: 'green'},
	'help': {color: 'cyan'},
	'warn': {color: 'yellow', font: 'bold'},
	'debug': {color: 'grey', font: 'bold'},
	'error': {color: 'red', font: 'bold'}
};

Logger.levels.forEach(function(level){
	Logger[level] = function(){
		return this.log.apply(this, [level].concat(Array.apply(Array, arguments)));
	};
});

module.exports = Logger;