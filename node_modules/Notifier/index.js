var proto = require('proto');

var Listener = proto.extend({
	fn: null,
	bind: null,
	exec: null,
	isOnce: false,
	active: true,

	constructor: function(fn, bind, once){
		if( typeof fn == 'object' ){
			this.exec = this.execObject;
		}
		else if( typeof fn == 'function' ){
			this.exec = this.execFn;
		}
		else{
			throw new TypeError('listener expect function or object, ' + fn + ' given');
		}

		this.fn = fn;
		this.bind = bind;
		this.isOnce = Boolean(once);
	},

	is: function(fn, bind){
		return this.fn === fn && this.bind == bind;
	},

	execObject: function(args){
		return this.fn[this.bind].apply(this.fn, args);
	},

	execFn: function(args){
		return this.fn.apply(this.bind, args);
	}
});

var Notifier = proto.extend({
	Listener: Listener,
	listeners: null,
	size: 0,
	lastIndex: null,
	stopped: false,
	index: 0,
	active: true,

	constructor: function(){
		this.listeners = [];
	},

	open: function(){

	},

	close: function(){

	},

	enable: function(){
		if( this.active === false ){
			this.active = true;
			return true;
		}
		return false;
	},

	disable: function(){
		if( this.active === true ){
			this.active = false;
			return true;
		}
		return false;
	},

	getListener: function(fn, bind){
		var index = this.listeners.length;

		while(index--){
			if( this.listeners[index].is(fn, bind) ){
				this.lastIndex = index;
				return this.listeners[index];
			}
		}

		return null;
	},

	has: function(fn, bind){
		return this.getListener(fn, bind) !== null;
	},

	add: function(fn, bind, once){
		var listener = this.getListener(fn, bind);

		if( listener ){
			if( listener.isOnce != once ){
				throw new Error('you cannot add() & addOnce() the same listener');
			}
			return false;
		}

		listener = this.Listener.create(fn, bind, once);
		this.listeners.push(listener);
		this.size++;
		if( this.size === 1 ) this.open();

		return listener;
	},

	addOnce: function(fn, bind){
		return this.add(fn, bind, true);
	},

	remove: function(fn, bind){
		if( this.has(fn, bind) ){
			this.listeners.splice(this.lastIndex, 1);
			this.index--;
			this.size--;
			if( this.size === 0 ) this.close();
			return true;
		}
		return false;
	},

	clear: function(){
		if( this.size === 0 ) return false;
		this.listeners.length = this.size = this.index = 0;
		return true;
	},

	forEach: function(fn, bind){
		this.index = 0;
		// we don't catch index and length in case remove() or clear() is called during the loop
		while(this.index < this.size ){
			if( fn.call(bind, this.listeners[this.index]) === false ) break;
			this.index++;
		}
	},

	execListener: function(listener, args){
		return listener.exec(args);
	},

	applyListener: function(listener, args){
		if( listener.active === true ){
			if( listener.isOnce === true ){
				this.remove(listener.fn, listener.bind);
			}
			return this.execListener(listener, args);
		}
	},

	notifyArgs: function(args){
		if( this.active === true ){
			this.stopped = false;
			return this.forEach(function(listener){
				return this.stopped ? false : this.applyListener(listener, args);
			}, this);
		}
		return false;
	},

	notify: function(){
		return this.notifyArgs(arguments);
	}
});

module.exports = Notifier;