require('../Symbol');
var toStr = Object.prototype.toString;

function isCallable(fn){
	return typeof fn === 'function' || toStr.call(fn) === '[object Function]';
}

function toInteger(value){
	var number = Number(value);
	if( isNaN(number) ) return 0;
	if( number === 0 || !isFinite(number) ) return number;
	return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
}

var maxSafeInteger = Math.pow(2, 53) - 1;
function toLength(value){
	var len = toInteger(value);
	return Math.min(Math.max(len, 0), maxSafeInteger);
}

// The length property of the from method is 1.
function from(arrayLike/*, mapFn, thisArg*/){
	var self = this, items = Object(arrayLike);

	if( arrayLike == null ){
		throw new TypeError("Array.from requires an array-like object - not null or undefined");
	}

	var mapFn = arguments.length > 1 ? arguments[1] : undefined, bind;
	if( typeof mapFn !== 'undefined' ){
		if( !isCallable(mapFn) ){
			throw new TypeError('Array.from: when provided, the second argument must be a function');
		}

		if (arguments.length > 2) {
			bind = arguments[2];
		}
	}

	var array, i = 0, value;
	// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-checkiterable
	if( typeof arrayLike[Symbol.iterator] != 'undefined' ){
		var next, iterator;

		iterator = arrayLike[Symbol.iterator]();
		array = isCallable(self) ? Object(new self()) : [];		
		next = iterator.next();

		while( next.done === false ){
			if( mapFn ) value = typeof bind === 'undefined' ? mapFn(value, i) : mapFn.call(bind, value, i);
			array[i] = value;
			next = iterator.next();
			i++;
		}
	}
	else{
		var length = toLength(items.length);

		array = isCallable(self) ? Object(new self(length)) : new Array(length);

		while( i < length ){
			value = items[i];
			if( mapFn ){
				value = typeof bind === 'undefined' ? mapFn(value, i) : mapFn.call(bind, value, i);
			}
			array[i] = value;
			i++;
		}
		array.length = length;
	}	

	return array;
}

if( !Array.from ){
	Array.from = from;
}

module.exports = from;
