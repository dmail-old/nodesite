/*

plus besoin de subclass

suffirais de faire

this.completed = Notifier.create('completed');
this.completed.memorize = true;
this.completed.args = [this];

sauf que pour pause / resume
faut que lorsqu'on pause on forget resume (sinon resumed pense qu'il est toujours mémorisé et va fire)
et que lorsqu'on resume on forget pause

var TaskNotifier = proto.extend.call(Notifier, {
	notified: false,

	toString: function(){
		return '[Object Notifier active:'+ this.active +' size:'+ this.size +']';
	},

	prevent: function(){
		this.stopped = true;
		return this;
	},

	constructor: function(task, name){
		this.task = task;
		TaskNotifier.super.constructor.call(this, name);
	},

	add: function(){
		var listener = TaskNotifier.super.add.apply(this, arguments);
		// immediatly call listener when already notified
		if( listener && this.notified ){
			this.applyListener(listener, [this.task]);
		}
		return listener;
	},

	notify: function(){
		this.notified = true;
		return TaskNotifier.super.notify.call(this, this.task);
	}
});
*/

var proto = require('proto');

var Watcher = proto.extend({
	fn: null,
	bind: null,
	exec: null,
	isOnce: false,
	active: true,

	constructor: function(listener, bind, once){
		if( typeof listener == 'object' ){
			this.exec = this.execObject;
		}
		else if( typeof listener == 'function' ){
			this.exec = this.execFn;
		}
		else{
			throw new TypeError('watcher expect function or object, ' + listener + ' given');
		}

		this.listener = listener;
		this.bind = bind;
		this.isOnce = Boolean(once);
	},

	is: function(listener, bind){
		return this.listener === listener && this.bind == bind;
	},

	execObject: function(args){
		return this.listener[this.bind].apply(this.fn, args);
	},

	execFn: function(args){
		return this.listener.apply(this.bind, args);
	}
});

var Notifier = proto.extend({
	Watcher: Watcher,
	watchers: null,
	size: 0,
	lastIndex: null,
	stopped: false,
	index: 0,
	active: true,
	memorize: false, // memorize aguments
	savedArgs: null, // memorized arguments
	args: null, // curried arguments

	constructor: function(name){
		this.name = name;
		this.watchers = [];
	},

	open: function(){

	},

	close: function(){

	},

	forget: function(){
		this.savedArgs = null;
	},

	enable: function(){
		if( this.active === false ){
			this.active = true;
			return true;
		}
		return false;
	},

	disable: function(){
		if( this.active === true ){
			this.active = false;
			return true;
		}
		return false;
	},

	getWatcher: function(fn, bind){
		var watchers = this.watchers, index = watchers.length, watcher;

		while(index--){
			watcher = watchers[index];
			if( watcher.is(fn, bind) ){
				this.lastIndex = index;
				return watcher;
			}
		}

		return null;
	},

	has: function(listener, bind){
		return this.getWatcher(listener, bind) !== null;
	},

	add: function(listener, bind, once){
		var watcher = this.getWatcher(listener, bind);

		if( watcher ){
			if( watcher.isOnce != once ){
				throw new Error('you cannot add() & addOnce() the same listener');
			}
			return false;
		}

		watcher = this.Watcher.create(listener, bind, once);
		this.watchers.push(watcher);
		this.size++;
		if( this.size === 1 ) this.open();

		if( this.memorize && this.savedArgs ){
			this.applyWatcher(watcher, this.savedArgs);
		}

		return watcher;
	},

	addOnce: function(listener, bind){
		return this.add(listener, bind, true);
	},

	remove: function(listener, bind){
		if( this.has(listener, bind) ){
			this.watchers.splice(this.lastIndex, 1);
			this.index--;
			this.size--;
			if( this.size === 0 ) this.close();
			return true;
		}
		return false;
	},

	clear: function(){
		this.savedArgs = null;
		if( this.size === 0 ) return false;
		this.watchers.length = this.size = this.index = 0;
		return true;
	},

	forEach: function(fn, bind){
		this.index = 0;
		// we don't catch index and length in case remove() or clear() is called during the loop
		while( this.index < this.size ){
			if( fn.call(bind, this.watchers[this.index]) === false ) break;
			this.index++;
		}
	},

	execWatcher: function(watcher, args){
		return watcher.exec(args);
	},

	applyWatcher: function(watcher, args){
		if( watcher.active === true ){
			if( this.memorize ){
				this.savedArgs = args;
			}

			if( watcher.isOnce === true ){
				this.remove(watcher.fn, watcher.bind);
			}
			return this.execWatcher(watcher, args);
		}
	},

	notifyArgs: function(args){
		if( this.active === true ){
			this.stopped = false;

			if( this.args && this.args.length ){
				if( args && args.length ){
					args = this.args.push.apply(this.args, args);
				}
				else{
					args = this.args;
				}
			}

			return this.forEach(function(watcher){
				return this.stopped ? false : this.applyWatcher(watcher, args);
			}, this);
		}
		return false;
	},

	notify: function(){
		return this.notifyArgs(arguments);
	}
});

Notifier.assignNotifiers = function(){
	var i = 0, j = arguments.length, name;

	for(;i<j;i++){
		name = arguments[i];
		this[name] = Notifier.create(name);
	}
};

module.exports = Notifier;
