/*

plus besoin de subclass

suffirais de faire

this.completed = Notifier.create('completed');
this.completed.memorize = true;
this.completed.args = [this];

sauf que pour pause / resume
faut que lorsqu'on pause on forget resume (sinon resumed pense qu'il est toujours mémorisé et va fire)
et que lorsqu'on resume on forget pause

var TaskNotifier = proto.extend.call(Notifier, {
	notified: false,

	toString: function(){
		return '[Object Notifier active:'+ this.active +' size:'+ this.size +']';
	},

	prevent: function(){
		this.stopped = true;
		return this;
	},

	constructor: function(task, name){
		this.task = task;
		TaskNotifier.super.constructor.call(this, name);
	},

	add: function(){
		var listener = TaskNotifier.super.add.apply(this, arguments);
		// immediatly call listener when already notified
		if( listener && this.notified ){
			this.applyListener(listener, [this.task]);
		}
		return listener;
	},

	notify: function(){
		this.notified = true;
		return TaskNotifier.super.notify.call(this, this.task);
	}
});
*/

var proto = require('proto');

var Listener = proto.extend({
	fn: null,
	bind: null,
	exec: null,
	isOnce: false,
	active: true,

	constructor: function(fn, bind, once){
		if( typeof fn == 'object' ){
			this.exec = this.execObject;
		}
		else if( typeof fn == 'function' ){
			this.exec = this.execFn;
		}
		else{
			throw new TypeError('listener expect function or object, ' + fn + ' given');
		}

		this.fn = fn;
		this.bind = bind;
		this.isOnce = Boolean(once);
	},

	is: function(fn, bind){
		return this.fn === fn && this.bind == bind;
	},

	execObject: function(args){
		return this.fn[this.bind].apply(this.fn, args);
	},

	execFn: function(args){
		return this.fn.apply(this.bind, args);
	}
});

var Notifier = proto.extend({
	Listener: Listener,
	listeners: null,
	size: 0,
	lastIndex: null,
	stopped: false,
	index: 0,
	active: true,
	memorize: false, // memorize aguments
	savedArgs: null, // memorized arguments
	args: null, // curried arguments

	constructor: function(name){
		this.name = name;
		this.listeners = [];
	},

	open: function(){

	},

	close: function(){

	},

	forget: function(){
		this.savedArgs = null;
	},

	enable: function(){
		if( this.active === false ){
			this.active = true;
			return true;
		}
		return false;
	},

	disable: function(){
		if( this.active === true ){
			this.active = false;
			return true;
		}
		return false;
	},

	getListener: function(fn, bind){
		var index = this.listeners.length;

		while(index--){
			if( this.listeners[index].is(fn, bind) ){
				this.lastIndex = index;
				return this.listeners[index];
			}
		}

		return null;
	},

	has: function(fn, bind){
		return this.getListener(fn, bind) !== null;
	},

	add: function(fn, bind, once){
		var listener = this.getListener(fn, bind);

		if( listener ){
			if( listener.isOnce != once ){
				throw new Error('you cannot add() & addOnce() the same listener');
			}
			return false;
		}

		listener = this.Listener.create(fn, bind, once);
		this.listeners.push(listener);
		this.size++;
		if( this.size === 1 ) this.open();

		if( this.memorize && this.savedArgs ){
			this.applyListener(listener, this.savedArgs);
		}

		return listener;
	},

	addOnce: function(fn, bind){
		return this.add(fn, bind, true);
	},

	remove: function(fn, bind){
		if( this.has(fn, bind) ){
			this.listeners.splice(this.lastIndex, 1);
			this.index--;
			this.size--;
			if( this.size === 0 ) this.close();
			return true;
		}
		return false;
	},

	clear: function(){
		this.savedArgs = null;
		if( this.size === 0 ) return false;
		this.listeners.length = this.size = this.index = 0;
		return true;
	},

	forEach: function(fn, bind){
		this.index = 0;
		// we don't catch index and length in case remove() or clear() is called during the loop
		while( this.index < this.size ){
			if( fn.call(bind, this.listeners[this.index]) === false ) break;
			this.index++;
		}
	},

	execListener: function(listener, args){
		return listener.exec(args);
	},

	applyListener: function(listener, args){
		if( listener.active === true ){
			if( this.memorize ){
				this.savedArgs = args;
			}

			if( listener.isOnce === true ){
				this.remove(listener.fn, listener.bind);
			}
			return this.execListener(listener, args);
		}
	},

	notifyArgs: function(args){
		if( this.active === true ){
			this.stopped = false;

			if( this.args && this.args.length ){
				if( args && args.length ){
					args = this.args.push.apply(this.args, args);
				}
				else{
					args = this.args;
				}
			}

			return this.forEach(function(listener){
				return this.stopped ? false : this.applyListener(listener, args);
			}, this);
		}
		return false;
	},

	notify: function(){
		return this.notifyArgs(arguments);
	}
});

Notifier.assignNotifiers = function(){
	var i = 0, j = arguments.length, name;

	for(;i<j;i++){
		name = arguments[i];
		this[name] = Notifier.create(name);
	}
};

module.exports = Notifier;