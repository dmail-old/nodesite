var proto = require('proto');
var Worker = proto.create({
	task: null,
	fn: null,
	bind: null,
	done: false,
	paused: false,
	completed: false,
	state: null,

	constructor: function(task, fn, bind){
		this.task = task;
		this.fn = fn;
		this.bind = bind;
	},

	start: function(){
		try{
			var ret = this.fn.call(this.bind, this);
			if( ret && typeof ret.then === 'function' ){ // support promise
				ret.then(this.resolve.bind(this), this.reject.bind(this));
			}
		}
		catch(e){
			this.reject(e);
		}
	},

	pause: function(){
		if( this.paused === false ){
			if( this.done === true ) throw new TypeError('cannot pause a done worker');
			this.paused = true;
		}
	},

	resume: function(){
		if( this.paused === true ){
			this.paused = false;
			if( this.done ){
				this.done = false;
				this.start();
			}
		}
	},

	complete: function(error, result){
		if( error ){
			this.reject(error);
		}
		else{
			this.resolve(result);
		}
	},

	resolve: function(value){
		if( !this.done ){
			this.done = true;
			if( !this.paused ){
				this.completed = true;
				this.state = true;
				this.task._resolve(value);
			}
		}
	},

	reject: function(value){
		if( !this.done ){
			this.done = true;
			if( !this.paused ){
				this.completed = true;
				this.state = false;
				this.task._reject(value);
			}
		}
	}
});

/*
unlike promise, task dont resolve until task.run() is called
*/
var Task = proto.create({
	value: null,
	fn: null,
	bind: null,
	paused: false,
	autorun: false,
	worker: null,

	constructor: function(fn, bind){
		if( arguments.length === 0 ){
			throw new Error('missing worker function for this task');
		}
		if( typeof fn != 'function' ) throw new TypeError('function expected');
		
		this.fn = fn;
		this.bind = bind;
		this.worker = this.createWorker(fn, bind);
		if( this.autorun ) this.worker.start();
	},

	isPending: function(){
		return this.worker.started === true && this.worker.completed === false;
	},

	isPassed: function(){
		return this.worker.state === true;
	},

	isFailed: function(){
		return this.worker.state === false;
	},

	isCompleted: function(){
		return this.worker.completed === true;
	},

	isPaused: function(){
		return this.worker.paused === true;
	},

	isRunning: function(){
		return this.isPending() && !this.isPaused();
	},

	onresolve: function(){
		// do some logic on resolve
	},

	onreject: function(){
		// do some logic on reject
	},

	// called when the task is completed
	clean: function(){

	},

	_resolve: function(value){
		try{
			if( value === this) throw new TypeError('A task cannot be resolved with itself.');
			if( value && (typeof value === 'object' || typeof value === 'function') ){
				var then = value.then;
				if( typeof then === 'function' ){
					this.worker = this.createWorker(then, value);
					this.start();
					return;
				}
			}
		}
		catch(e){
			this.reject(e);
		}

		this.state = true;
		this.value = value;
		this.clean();
		this.onresolve();
	},

	_reject: function(value){
		this.state = false;
		this.value = value;
		this.clean();
		this.onreject();
	},

	createWorker: function(fn, bind){
		return new Worker(this, fn, bind);
	},

	reject: function(value){
		this.worker.reject(value);
	},

	resolve: function(value){
		this.worker.resolve(value);
	},

	start: function(){
		this.worker.start();
	},

	pause: function(){
		this.worker.pause();
	},

	resume: function(){
		this.worker.resume();
	},

	restart: function(){
		this.pause();// ignore the current worker result
		this.worker = this.createWorker(this.fn, this.bind); // create a new worker
		this.start(); // and start this worker
	},

	// faut pouvoir en mettre plusieurs, je vais utiliser Notifier je pense
	then: function(onresolve, onreject){
		this.onresolve = onresolve;
		this.onreject = onreject;
		if( this.isCompleted() ){
			if( this.isPassed() ) this.onresolve();
			else this.onreject();
		}
	}
});

// return a task completed once all values in iterable are resolved (one after an other) or a value is rejected
var TaskSerie = proto.extend(Task, {
	iterable: null,
	iterator: null,
	index: null,
	length: null,
	current: null,

	constructor: function(iterable){
		this.iterator = iterable['@@iterator']();
		Task.call(this, this.start, this);
	},

	start: function(){
		this.index = 0;
		this.length = 0;
		this.current = null;
		this.values = [];
		this.next();
	},

	progress: function(value){
		this.values[this.index] = value;
		this.index++;
		this.length++;
		this.next();
	},

	next: function(){
		if( this.paused ) return;

		var next = this.iterator.next(), value;

		if( next.done === true ){
			this.resolve(this.values);
		}
		else{
			value = next.value;
			this.current = value;

			if( value && (typeof value === 'object' || typeof value === 'function') ){
				var then = value.then;
				if( typeof value.then === 'function' ){
					value.then(this.progress.bind(this), this.reject.bind(this));
					// autorun the task
					if( value instanceof Task && !value.isPending() ) value.start();
				}
				else{
					this.progress(value);
				}
			}
			else{
				this.progress(value);
			}
		}
	},

	pause: function(){
		this.paused = true;

		if( this.current && typeof this.current === 'object' ){
			var pause = this.current.pause;
			if( typeof pause === 'function' ) pause.call(this.current);
		}
	},

	resume: function(){
		this.paused = false;

		if( this.current && typeof this.current === 'object' ){
			var resume = this.current.resume;
			if( typeof resume === 'function' ) resume.call(this.current);
			else this.next();
		}
		else{
			this.next();
		}
	}
});

Task.serie = function(iterable){
	return new TaskSerie(iterable);
};