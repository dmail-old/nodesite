var proto = require('proto');

/*
En fait j'ai pas vraiment besoin de pendingValue, enfin ce que je veux dire
c'est que dans les fait lorsque je veux redémarrer une tâche je vais faire new Task()
mais bon pour le moment on garde comme ça
new PendingValue() c'est presque comme new Promise()
*/

var PendingValue = proto.create({
	task: null,
	fn: null,
	bind: null,
	running: null, // the executor is running
	done: false, // reject or resolve has been called once
	pending: null, // the executor is running or the value is being processed
	paused: null, // if the value is found while being paused, it will be ignored
	resolved: null, // the value is considered resolved
	rejected: null, // the value is considered rejected
	value: null,

	constructor: function(task, fn, bind){
		if( arguments.length === 1 ){
			throw new Error('missing generator function');
		}
		if( typeof fn != 'function' ){
			throw new TypeError('function expected as generator');
		}

		this.task = task;
		this.fn = fn;
		this.bind = bind;
		this.resetState();
	},

	resetState: function(){
		this.running = false;
		this.pending = false;
		this.done = false;
		this.paused = false;
		this.resolved = false;
		this.rejected = false;	
		this.value = null;
	},

	start: function(){
		if( this.running === false && this.done === false ){
			this.running = true;
			this.pending = true;
			
			try{
				// we could call this.checkThenable on the return value of fn
				// to support a returned promise
				// but the right way to do is pendindValue.resolve(promise)
				this.fn.call(this.bind, this.resolve.bind(this), this.reject.bind(this));
			}
			catch(e){
				this.reject(e);
			}
		}
	},
 
	checkThenable: function(thenable, resolve, reject){
		if( thenable === this.task ) reject(new TypeError('A task cannot be resolved with itself.'));

		if( thenable && (typeof thenable === 'object' || typeof thenable === 'function') ){
			var then;
			try{
				then = thenable.then;
			}
			catch(e){
				reject(e);
				return;
			}

			if( typeof then === 'function' ){
				//if( thenable instanceof Task ) thenable.start();

				resolve = resolve || this.resolve.bind(this);
				reject = reject || this.reject.bind(this);
				
				try{
					then.call(thenable, resolve, reject);
				}
				catch(e){
					reject(e);
				}

				return true;
			}
		}

		return false;
	},

	pause: function(){
		if( this.running ){
			this.paused = true;
		}
	},

	resume: function(){
		this.paused = false;
		if( this.done === true ){
			this.done = false;
			this.start();
		}
	},

	resolve: function(value){
		this.running = false;

		if( this.done === false ){
			if( this.checkThenable(value) ) return;
			this.done = true;
			if( this.paused === false ){
				this.resolved = true;
				this.pending = false;
				this.value = value;
				this.task.onFulFilled(value);
			}
		}
	},

	reject: function(value){
		this.running = false;

		if( this.done === false ){
			this.done = true;
			if( this.paused === false ){
				this.rejected = true;
				this.pending = false;
				this.value = value;
				this.task.onRejected(value);
			}
		}
	},

	complete: function(error, result){
		if( error ){
			this.reject(error);
		}
		else{
			this.resolve(result);
		}
	}
});

/*

*/
var Task = proto.create({
	bind: null,
	pendingValue: null,
	delay: 0,
	timeout: null,
	children: null,
	startDate: null,
	endDate: null,

	constructor: function(exec, bind){
		if( arguments.length > 0 ){
			this.exec = exec;
			this.bind = bind;
		}
		else{
			this.bind = this;
		}
		this.pendingValue = this.createPendingValue();
		this.complete = this.complete.bind(this);

		if( this.delay === 0 ){
			this.start();
		}
		else if( this.delay > 0 ){
			this.setDelay(this.delay);
		}
	},

	exec: function(resolve, reject){
		//reject(new Error('Task rejected by default executor'));
	},

	isPending: function(){
		return this.pendingValue.pending === true;
	},

	isResolved: function(){
		return this.pendingValue.resolved === true;
	},

	isRejected: function(){
		return this.pendingValue.rejected === true;
	},

	isCompleted: function(){
		return this.pendingValue.pending === false;
	},

	createPendingValue: function(){
		return new PendingValue(this, this.exec, this.bind);
	},

	reject: function(value){
		this.pendingValue.reject(value);
	},

	resolve: function(value){
		this.pendingValue.resolve(value);
	},

	complete: function(reason, value){
		this.pendingValue.complete(reason, value);
	},

	createTimeOutError: function(){
		var error = new Error(this + ' task is too slow');
		error.code = 'TASK_TIMEOUT';
		return error;
	},

	get duration(){
		return this.endDate - this.startDate;
	},

	time: function(){
		this.startDate = new Date();		
		return this;
	},

	setTimeout: function(ms){
		this.timer = setTimeout(function(){
			this.timer = null;
			this.reject(this.createTimeOutError());
		}.bind(this), ms);
		return this;
	},

	setDelay: function(ms){
		setTimeout(this.start.bind(this), ms);
	},

	start: function(){
		if( typeof this.timeout === 'number' ){
			this.setTimeout(this.timeout);
		}
		this.pendingValue.start();
	},

	addChild: function(task){
		this.children = this.children || [];
		this.children.push(task);
	},

	handleChild: function(child){
		child.handle();
	},

	// called when the task is completed
	clean: function(){
		if( this.startDate ){
			this.endDate = new Date();
		}	
		if( this.timer != null ){
			clearTimeout(this.timer);
			this.timer = null;
		}

		var i, j, children = this.children;

		if( children ){
			i = 0;
			j = children.length;
			for(;i<j;i++){
				this.handleChild(children[i]);
			}
		}
	},

	onFulFilled: function(value){
		this.clean();
	},

	onRejected: function(value){
		this.clean();
	},

	then: function(onresolve, onreject){
		var task = new ChildTask(this, onresolve, onreject);

		this.addChild(task);
		if( this.isCompleted() ){
			//setTimeout(function(){
				this.handleChild(task);
			//}.bind(this), 1);
		}

		return task;
	},

	pause: function(){
		this.pendingValue.pause();
	},

	resume: function(){
		this.pendingValue.resume();
	},

	// called when the task is cancelled
	abort: function(){

	},

	cancel: function(){
		this.pause();
		this.abort();
		this.pendingValue = this.createPendingValue(); // create a new pendingValue
	},

	// called when the task is stopped
	reset: function(){
		
	},

	stop: function(){
		// cancel the current pendingValue completion
		if( this.isPending() ){
			this.cancel();
		}
		else if( this.isCompleted() ){
			// reset all descendant
			if( this.children ){
				this.children.forEach(function(child){
					child.stop();
				});
			}

			// call any reset custom behaviour
			this.reset();
			// resetState of the task
			this.pendingValue.resetState();
		}
	},

	restart: function(){
		this.stop();
		this.start(); // start the pendingValue completion
	}
});

// TaskReaction, the reaction waiting for a Task to complete
// could be called a Deffered
var ChildTask = proto.extend(Task, {
	parent: null,
	onresolve: null,
	onreject: null,

	constructor: function(parent, onresolve, onreject){
		this.parent = parent;
		this.onresolve = onresolve;
		this.onreject = onreject;
		this.super.call(this);
	},

	handle: function(){
		var parent, isResolved, fn, value, ret, error;

		parent = this.parent;
		isResolved = parent.isResolved();
		value = parent.pendingValue.value;
		fn = isResolved ? this.onresolve : this.onreject;

		if( fn != null ){
			try{
				ret = fn(value);
			}
			catch(e){
				error = e;
			}

			if( error ){
				isResolved = false;
				value = error;
			}
			else{
				isResolved = true;
				value = ret;
			}
		}	

		if( isResolved ){
			this.resolve(value);
		}
		else{
			this.reject(value);
		}
	}
});

Task.ChildTask = ChildTask;
Task.PendingValue = PendingValue;

Task.resolve = function(value){
	return new Task(function resolveExecutor(resolve){
		resolve(value);
	});
};

Task.reject = function(value){
	return new Task(function rejectExecutor(resolve, reject){
		reject(value);
	});
};

var es6 = require('es6');
var forOf = es6.forOf;

// helper to implement reduce, every & map
Task.iterate = function(iterable, thenMap, thenMapBind, collectFn, collectBind, initialValue){
	var task, index = 0;

	task = Task.resolve(initialValue);

	forOf(iterable, function(value){
		index++;
		if( thenMap ){
			//value = thenMap.call(thenMapBind, value, index, iterable);
			var temp = thenMap.call(thenMapBind, value, index, iterable);
			temp.original = value;
			value = temp;

			value = function(v){
				global.currentTask = temp.original;
				return temp.call(this, v);
			};
		}		
		// retourne le résultat de thenFn sur iterable (peut être thenable)
		task = task.then(value);
		// récupère le résultat si on en a besoin
		if( collectFn ){
			// task.then(collectFn.bind(collectBind));
			var result = collectFn.bind(collectBind);
			result.original = collectFn;
			task.then(result);			
		}
	});

	return task;
};

function reducer(value){
	return value.bind(this);
}

// each iterable value is considered as a then() call
Task.reduce = function(iterable, bind, initialValue){
	return Task.iterate(iterable, reducer, bind, null, null, initialValue);
};

function collector(value){
	this.push(value);
	return value;
}

// same as reduce but collect the resolved values and return them
Task.serie = function(iterable, bind, initialValue){
	var values = [];
	return Task.iterate(iterable, reducer, bind, collector, values, initialValue).then(function(){
		return values;
	});
};

// each iterable value is mapped and considered as a then() call and return an array of resolved values
Task.map = function(iterable, map, bind){
	var values = [];
	return Task.iterate(iterable, function(value, index, iterable){
		return map.bind(bind, value, index, iterable);
	}, null, null, collector, values).then(function(){
		return values;
	});
};

// same as map but values are not collected
Task.mapReduce = function(iterable, map, bind){
	return Task.iterate(iterable, function(value, index, iterable){
		return map.bind(bind, value, index, iterable);
	});
};

module.exports = Task;