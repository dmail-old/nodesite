var proto = require('proto');

var PendingValue = proto.create({
	task: null,
	fn: null,
	bind: null,
	running: null,
	pending: null,
	aborted: null,
	resolved: null,
	rejected: null,
	value: null,

	constructor: function(task, fn, bind){
		if( arguments.length === 1 ){
			throw new Error('missing generator function');
		}
		if( typeof fn != 'function' ){
			throw new TypeError('function expected as generator');
		}

		this.task = task;
		this.fn = fn;
		this.bind = bind;
		this.resetState();
	},

	resetState: function(){
		this.running = false;
		this.pending = false;
		this.aborted = false;
		this.resolved = false;
		this.rejected = false;	
		this.value = null;
	},

	start: function(){
		if( this.aborted === true ){			
			this.aborted = false;
		}		

		if( this.running === false ){
			this.running = true;
			this.pending = true;
			
			try{
				// call checkThenable on fn return to support promise generator
				this.checkThenable(this.fn.call(this.bind, this));
			}
			catch(e){
				this.reject(e);
			}
		}
	},

	// complete this collector 
	checkThenable: function(thenable, resolve, reject){
		if( thenable && typeof thenable === 'object' || typeof thenable === 'function' ){
			var then = thenable.then;
			if( typeof then === 'function' ){
				if( thenable instanceof Task ){
					thenable.start();
				}
				then.call(thenable, resolve || this.resolve.bind(this), reject || this.reject.bind(this));
				return true;
			}
		}

		return false;
	},

	abort: function(){
		this.aborted = true;
	},

	resolve: function(value){
		if( this.completed === false ){
			try{
				if( this.checkThenable(value) ) return;
			}
			catch(e){
				this.reject(e);
				return;
			}
			
			this.running = false;
			this.resolved = true;
			if( this.aborted === false ){
				this.pending = false;
				this.value = value;
				this.task.onFulFilled(value);
			}
		}
	},

	reject: function(value){
		if( this.completed === false ){
			this.running = false;
			this.rejected = true;
			if( this.aborted === false ){
				this.pending = false;
				this.value = value;
				this.task.onRejected(value);
			}
		}
	},

	complete: function(error, result){
		if( error ){
			this.reject(error);
		}
		else{
			this.resolve(result);
		}
	}
});

/*
unlike promise, task dont resolve until task.run() is called
*/
var Task = proto.create({
	fn: null,
	bind: null,
	pendingValue: null,
	autostart: null,
	parent: null,

	constructor: function(fn, bind){		
		this.fn = fn;
		this.bind = bind;
		this.pendingValue = this.createPendingValue();
		if( this.autorun ) this.pendingValue.start();
	},

	isPending: function(){
		return this.pendingValue.pending === true;
	},

	isRunning: function(){
		return this.pendingValue.running === true;
	},	

	isPassed: function(){
		return this.pendingValue.resolved === true;
	},

	isFailed: function(){
		return this.pendingValue.rejected === true;
	},

	isCompleted: function(){
		return this.pendingValue.resolved === true || this.pendingValue.rejected === true;
	},

	onresolve: function(){
		// do some logic on resolve
	},

	onreject: function(){
		// do some logic on reject
	},

	// called when the task is completed
	clean: function(){

	},

	// called when the task is about to restart
	reset: function(){

	},

	onFulFilled: function(value){
		this.clean();
		this.onresolve(value);
	},

	onRejected: function(value){
		this.clean();
		this.onreject(value);
	},

	createPendingValue: function(){
		return new PendingValue(this, this.fn, this.bind);
	},

	reject: function(value){
		this.pendingValue.reject(value);
	},

	resolve: function(value){
		this.pendingValue.resolve(value);
	},

	start: function(){
		this.pendingValue.start();
	},

	abort: function(){
		this.pendingValue.abort();
	},

	restart: function(){
		this.abort(); // abort the current pendingValue completion
		this.pendingValue = this.createPendingValue(); // create a new pendingValue

		// if this taks is failed completed, all parent task have failed
		// because this taks was responsible for it and can now resolve normally
		// we call repare() an all parent to let parent tasks a chance to resolve
		if( this.isFailed() && this.parent && this.parent.repare ) this.parent.repare();

		this.reset();
		this.start(); // and start this worker
	},

	// faut pouvoir en mettre plusieurs, je vais utiliser Notifier je pense
	then: function(onresolve, onreject){
		this.onresolve = onresolve;
		this.onreject = onreject;
		if( this.isPassed() ) this.onresolve();
		else if( this.isFailed() ) this.onreject();
	}
});

// return a task completed once all values in iterable are resolved (one after an other) or a value is rejected
var TaskSerie = proto.extend(Task, {
	iterable: null,
	iterator: null,
	index: null,
	length: null,
	current: null,

	constructor: function(iterable){
		this.iterable = iterable;
		this.reset();
		Task.call(this, this.start, this);
	},

	reset: function(){
		this.iterator = this.iterable['@@iterator']();
		this.index = 0;
		this.length = 0;
		this.current = null;
		this.values = [];
	},

	repare: function(){
		if( this.parent && this.parent.repare ) this.parent.repare();
		this.pendingValue.rejected = false;
		this.pendingValue.running = false;
		this.pendingValue.pending = false;
		this.pendingValue.value = null;
	},

	start: function(){
		if( this.pendingValue.aborted === false ){
			var next = this.iterator.next(), value;

			if( next.done === true ){
				this.resolve(this.values);
			}
			else{
				value = next.value;
				this.current = value;

				if( this.pendingValue.checkThenable(value, this.progress.bind(this), this.reject.bind(this)) ){
					if( value instanceof Task ){
						value.parent = this.task;
					}
				}
				else{
					this.progress(value);
				}
			}
		}
		// restart current task when this task was aborted
		else if( this.current && this.current.aborted ){
			this.current.restart();
		}
	},

	progress: function(value){
		this.values[this.index] = value;
		this.index++;
		this.length++;
		this.start();
	},

	// abort current task when this task is aborted
	abort: function(){
		if( this.current && typeof this.current === 'object' ){
			var abort = this.current.abort;
			if( typeof abort === 'function' ) abort.call(this.current);
		}
		Task.prototype.abort.call(this);
	}
});

Task.serie = function(iterable){
	return new TaskSerie(iterable);
};

/*
new Task(module.load, module).then(function(){
	return new Task(module.run, module);
});

j'ai donc une tâche lié à une autre
si je restart module.load et que module.run était en cours je dois cancel module.run
et lorsque module.load se termine je dois relancé la tâche module.run
mais en fait je dois même recréer la tâche normalement

dans mon cas voici ce que je veux:

var loadTasks; // an array of load task to perform
var runTasks; // an array of runTasks to perform
var tasks; // an array containing the loadTasks and runTasks to perform

loadTasks.then(null, function(error){
	// durant le loading, une tâche à échouée
	loadTasks.current; // c'est celle-ci

	// action correctrice qui fait que loadTasks.current ne devrais plus échouer
	// je veux maintenant reprendre loadTasks où j'en était
	// comme loadTasks fait partie d'un sous groupe de tâche de tasks
	// loadTasks à donc fait échouer tasks

	loadTasks.pendingValue.rejected = false;
	loadTasks.pendingValue.running = true;
	loadTasks.pendingValue.pending = true;
	tasks.pendingValue.rejected = false;
	tasks.running = false;
	tasks.pending = true;

	loadTasks.current.restart();
	// si ça échoue on retombe ici
	// si ça réussit ça va apeller loadTasks.progress() puis.next(), reprenant le cours normal du process

	// il faut donc connaitre la tâche ayant échoué
	// si cette tâche à des parents, pour chaque parent on fait comme si ça avait pas échoué
	// et on reprend
});
*/