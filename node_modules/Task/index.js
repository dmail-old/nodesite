var proto = require('proto');

var PendingValue = proto.create({
	task: null,
	fn: null,
	bind: null,
	running: null,
	pending: null,
	aborted: null,
	resolved: null,
	rejected: null,
	value: null,

	constructor: function(task, fn, bind){
		if( arguments.length === 1 ){
			throw new Error('missing generator function');
		}
		if( typeof fn != 'function' ){
			throw new TypeError('function expected as generator');
		}

		this.task = task;
		this.fn = fn;
		this.bind = bind;
		this.resetState();
	},

	resetState: function(){
		this.running = false;
		this.pending = false;
		this.aborted = false;
		this.resolved = false;
		this.rejected = false;	
		this.value = null;
	},

	start: function(){
		if( this.aborted === true ){			
			this.aborted = false;
		}		

		if( this.running === false ){
			this.running = true;
			this.pending = true;
			
			try{
				// call checkThenable on fn return to support a returned promise
				this.checkThenable(this.fn.call(this.bind, this));
			}
			catch(e){
				this.reject(e);
			}
		}
	},

	// complete this collector 
	checkThenable: function(thenable, resolve, reject){
		if( thenable && typeof thenable === 'object' || typeof thenable === 'function' ){
			var then = thenable.then;
			if( typeof then === 'function' ){
				if( thenable instanceof Task ){
					thenable.start();
				}
				then.call(thenable, resolve || this.resolve.bind(this), reject || this.reject.bind(this));
				return true;
			}
		}

		return false;
	},

	abort: function(){
		this.aborted = true;
	},

	resolve: function(value){
		if( this.pending === true ){
			try{
				if( this.checkThenable(value) ) return;
			}
			catch(e){
				this.reject(e);
				return;
			}
			
			this.running = false;			
			if( this.aborted === false ){
				this.resolved = true;
				this.pending = false;
				this.value = value;
				this.task.onFulFilled(value);
			}
		}
	},

	reject: function(value){
		if( this.pending === true ){
			this.running = false;
			if( this.aborted === false ){
				this.rejected = true;
				this.pending = false;
				this.value = value;
				this.task.onRejected(value);
			}
		}
	},

	complete: function(error, result){
		if( error ){
			this.reject(error);
		}
		else{
			this.resolve(result);
		}
	}
});

/*
unlike promise, task dont resolve until task.run() is called
*/
var Task = proto.create({
	fn: null,
	bind: null,
	pendingValue: null,
	autostart: null,

	constructor: function(fn, bind){		
		this.fn = fn;
		this.bind = bind;
		this.pendingValue = this.createPendingValue();
		if( this.autorun ) this.pendingValue.start();
	},

	isPending: function(){
		return this.pendingValue.pending === true;
	},

	isRunning: function(){
		return this.pendingValue.running === true;
	},	

	isPassed: function(){
		return this.pendingValue.resolved === true;
	},

	isFailed: function(){
		return this.pendingValue.rejected === true;
	},

	isCompleted: function(){
		return this.pendingValue.pending === false;
	},

	onresolve: function(){
		// do some logic on resolve
	},

	onreject: function(){
		// do some logic on reject
	},

	// called when the task is completed
	clean: function(){

	},

	// called when the task is about to restart
	reset: function(){

	},

	onFulFilled: function(value){
		this.clean();
		this.onresolve(value);
	},

	onRejected: function(value){
		this.clean();
		this.onreject(value);
	},

	createPendingValue: function(){
		return new PendingValue(this, this.fn, this.bind);
	},

	reject: function(value){
		this.pendingValue.reject(value);
	},

	resolve: function(value){
		this.pendingValue.resolve(value);
	},

	start: function(){
		this.pendingValue.start();
	},

	abort: function(){
		this.pendingValue.abort();
	},

	// si avait échoué, faut qu'on redémarre
	restart: function(){
		if( this.isPending() ) this.abort(); // abort the current pendingValue completion
		this.pendingValue = this.createPendingValue(); // create a new pendingValue
		this.reset();
		this.start(); // and start this worker
	},

	// faut pouvoir en mettre plusieurs, je vais utiliser Notifier je pense
	then: function(onresolve, onreject){
		this.onresolve = onresolve;
		this.onreject = onreject;
		if( this.isPassed() ) this.onresolve();
		else if( this.isFailed() ) this.onreject();
	}
});

require('es6');
// return a task completed once all values in iterable are resolved (one after an other) or a value is rejected
var TaskSerie = proto.extend(Task, {
	iterable: null,
	iterator: null,
	index: null,
	length: null,
	current: null,

	constructor: function(iterable){
		this.iterable = iterable;
		this.reset();
		Task.call(this, this.next, this);
	},

	reset: function(){
		this.iterator = this.iterable[Symbol.iterator]();
		this.index = 0;
		this.length = 0;
		this.current = null;
		this.values = [];
	},

	next: function(){
		if( this.pendingValue.aborted === false ){
			// restart current task when this task was aborted
			if( this.current && this.current.pendingValue.aborted === true ){
				this.current.restart();
			}
			else{
				var next = this.iterator.next(), value;

				if( next.done === true ){
					this.resolve(this.values);
				}
				else{
					value = next.value;
					this.current = value;

					if( this.pendingValue.checkThenable(value, this.progress.bind(this), this.reject.bind(this)) ){
						
					}
					else{
						this.progress(value);
					}
				}
			}
		}
	},

	progress: function(value){
		this.values[this.index] = value;
		this.index++;
		this.length++;
		this.next();
	},

	// abort current task when this task is aborted
	abort: function(){
		if( this.current && typeof this.current === 'object' ){
			var abort = this.current.abort;
			if( typeof abort === 'function' ) abort.call(this.current);
		}
		Task.prototype.abort.call(this);
	},

	restart: function(){
		if( this.isFailed() && this.current ){
			// if it's a task it will be restarted to let this taskserie a chance to resolve
			// if it's an other taskSerie it will propagate restart()
			
			// do as if this task didn't fail
			this.pendingValue.rejected = false;
			this.pendingValue.running = true;
			this.pendingValue.pending = true;
			this.pendingValue.value = null;

			this.current.restart();
		}
		else{
			Task.prototype.restart.call(this);
		}
	},
});

Task.serie = function(iterable){
	return new TaskSerie(iterable);
};

/*
new Task(module.load, module).then(function(){
	return new Task(module.run, module);
});
*/