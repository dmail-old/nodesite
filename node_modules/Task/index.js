var proto = require('proto');

var PendingValue = proto.create({
	task: null,
	fn: null,
	bind: null,
	running: null, // the executor is running
	done: false, // reject or resolve has been called once
	pending: null, // the executor is running or the value is being processed
	paused: null, // if the value is found while being paused, it will be ignored
	resolved: null, // the value is considered resolved
	rejected: null, // the value is considered rejected
	value: null,

	constructor: function(task, fn, bind){
		if( arguments.length === 1 ){
			throw new Error('missing generator function');
		}
		if( typeof fn != 'function' ){
			throw new TypeError('function expected as generator');
		}

		this.task = task;
		this.fn = fn;
		this.bind = bind;
		this.resetState();
	},

	resetState: function(){
		this.running = false;
		this.pending = false;
		this.done = false;
		this.paused = false;
		this.resolved = false;
		this.rejected = false;	
		this.value = null;
	},

	start: function(){
		if( this.running === false && this.done === false ){
			this.running = true;
			this.pending = true;
			
			try{
				// we could call this.checkThenable on the return value of fn
				// to support a returned promise
				// but the right way to do is pendindValue.resolve(promise)
				this.fn.call(this.bind, this.resolve.bind(this), this.reject.bind(this));
			}
			catch(e){
				this.reject(e);
			}
		}
	},
 
	checkThenable: function(thenable, resolve, reject){
		if( thenable && (typeof thenable === 'object' || typeof thenable === 'function') ){
			var then = thenable.then;
			if( typeof then === 'function' ){
				if( thenable instanceof Task ){
					thenable.start();
				}

				resolve = resolve || this.resolve.bind(this);
				reject = reject || this.reject.bind(this);
				
				try{
					then.call(thenable, resolve, reject);
				}
				catch(e){
					reject(e);
				}

				return true;
			}
		}

		return false;
	},

	pause: function(){
		if( this.running ){
			this.paused = true;
		}
	},

	resume: function(){
		this.paused = false;
		if( this.done === true ){
			this.done = false;
			this.start();
		}
	},

	resolve: function(value){
		this.running = false;

		if( this.done === false ){
			if( this.checkThenable(value) ) return;
			this.done = true;
			if( this.paused === false ){
				this.resolved = true;
				this.pending = false;
				this.value = value;
				this.task.onFulFilled(value);
			}
		}
	},

	reject: function(value){
		this.running = false;

		if( this.done === false ){
			this.done = true;
			if( this.paused === false ){
				this.rejected = true;
				this.pending = false;
				this.value = value;
				this.task.onRejected(value);
			}
		}
	},

	complete: function(error, result){
		if( error ){
			this.reject(error);
		}
		else{
			this.resolve(result);
		}
	}
});

/*

*/
var Task = proto.create({
	bind: null,
	pendingValue: null,
	delay: 0,
	timeout: null,
	children: null,
	startDate: null,
	endDate: null,
	useTime: false,

	constructor: function(exec, bind){
		if( arguments.length > 0 ){
			this.exec = exec;
			this.bind = bind;
		}
		else{
			this.bind = this;
		}
		this.pendingValue = this.createPendingValue();

		if( this.delay === 0 ){
			this.start();
		}
		else if( this.delay > 0 ){
			this.setDelay(this.delay);
		}
	},

	exec: function(resolve, reject){
		//reject(new Error('Task rejected by default executor'));
	},

	isPending: function(){
		return this.pendingValue.pending === true;
	},

	isPassed: function(){
		return this.pendingValue.resolved === true;
	},

	isFailed: function(){
		return this.pendingValue.rejected === true;
	},

	isCompleted: function(){
		return this.pendingValue.pending === false;
	},

	createPendingValue: function(){
		return new PendingValue(this, this.exec, this.bind);
	},

	reject: function(value){
		this.pendingValue.reject(value);
	},

	resolve: function(value){
		this.pendingValue.resolve(value);
	},

	complete: function(reason, value){
		this.pendingValue.complete(reason, value);
	},

	createTimeOutError: function(){
		var error = new Error(this + ' task is too slow');
		error.code = 'TASK_TIMEOUT';
		return error;
	},

	get duration(){
		return this.endDate - this.startDate;
	},

	time: function(){
		this.useTime = true;
		if( this.isCompleted() ) this.startDate = this.endDate;
		return this;
	},

	setTimeout: function(ms){
		this.timer = setTimeout(function(){
			this.timer = null;
			this.reject(this.createTimeOutError());
		}.bind(this), ms);
	},

	setDelay: function(ms){
		setTimeout(this.start.bind(this), ms);
	},

	start: function(){
		if( typeof this.timeout === 'number' ){
			this.setTimeout(this.timeout);
		}
		if( this.useTime ){
			this.startDate = new Date();
		}

		this.pendingValue.start();
	},

	pause: function(){
		this.pendingValue.pause();
	},

	resume: function(){
		this.pendingValue.resume();
	},

	cancel: function(){
		this.pause();
		this.pendingValue = this.createPendingValue(); // create a new pendingValue
	},

	addChild: function(task){
		this.children = this.children || [];
		this.children.push(task);
	},

	handleChild: function(child){
		child.start();
	},

	// called when the task is completed
	clean: function(){
		if( this.useTime ){
			this.endDate = new Date();
			if( this.timer != null ){
				clearTimeout(this.timer);
				this.timer = null;
			}
		}	

		var i, j, children = this.children;

		if( children ){
			i = 0;
			j = children.length;
			for(;i<j;i++){
				this.handleChild(children[i]);
			}
		}
	},

	onFulFilled: function(value){
		this.clean();
	},

	onRejected: function(value){
		this.clean();
	},

	then: function(onresolve, onreject){
		var task = new ChildTask(this, onresolve, onreject);

		this.addChild(task);
		if( this.isCompleted() ){
			this.handleChild(task);
		}

		return task;
	},

	// called when the task is about to restart
	reset: function(){
		
	},

	stop: function(){
		// abort the current pendingValue completion
		if( this.isPending() ){
			this.cancel();
		}
		else if( this.isCompleted() ){
			// reset all descendant
			if( this.children ){
				this.children.forEach(function(child){
					child.stop();
				});
			}

			// call any reset custom behaviour
			this.reset();
			// resetState of the task
			this.pendingValue.resetState();
		}
	},

	restart: function(){
		this.stop();
		this.start(); // start the pendingValue completion
	}
});

// TaskReaction, the reaction waiting for a Task to complete
// could be called a Deffered
var ChildTask = proto.extend(Task, {
	parent: null,
	onresolve: null,
	onreject: null,
	delay: -1,

	constructor: function(parent, onresolve, onreject){
		this.parent = parent;
		this.onresolve = onresolve;
		this.onreject = onreject;
		this.super.call(this);
	},

	exec: function(resolve, reject){
		var parent, isFulFilled, fn, value, ret;

		parent = this.parent;
		isFulFilled = parent.isFulFilled();
		value = parent.pendingValue.value;
		fn = isFulFilled ? this.onresolve : this.onreject;

		if( fn === null ){
			if( isFulFilled ){
				resolve(value);
			}
			else{
				reject(value);
			}
		}
		else{
			try{
				ret = fn(value);
			}
			catch(e){
				reject(e);
				return;
			}
			resolve(ret);
		}
	}
});

Task.ChildTask = ChildTask;
Task.PendingValue = PendingValue;

Task.resolve = function(value){
	return new Task().resolve(value);
};

Task.reject = function(value){
	return new Task().reject(value);
};

var es6 = require('es6');
var forOf = es6.forOf;

// helper to implement reduce, every & map
Task.iterate = function(iterable, thenFn, thenBind, collectFn, collectBind, initialValue){
	var task, index = 0;

	task = Task.resolve(initialValue);

	forOf(iterable, function(value){
		index++;
		if( thenFn ){
			value = thenFn.call(thenBind, value, index, iterable);
		}		
		// retourne le résultat de thenFn sur iterable (peut être thenable)
		task = task.then(value);
		// récupère le résultat si on en a besoin
		if( collectFn ){
			task = task.then(collectFn.bind(collectBind));
		}
	});

	return task;
};

// each iterable value is considered as a then() call
Task.reduce = function(iterable, bind, initialValue){
	return Task.iterate(iterable, function(value){
		return value.bind(bind);
	}, null, null, null, initialValue);
};

// each iterable value is mapped and considered as a then() call
// The returned task resolve to the iterable for chaining
Task.every = function(iterable, map, bind){
	return Task.iterate(iterable, function(value, index, iterable){
		return map.bind(bind, value, index, iterable);
	}).then(function(){
		return iterable;
	});
};

// each iterable value is mapped and considered as a then() call
// The returned task resolve to an array of the resolved values
Task.map = function(iterable, map, bind){
	var values = [];
	function onresolve(value){
		this.push(value);
		return this;
	}

	return Task.iterate(iterable, function(value, index, iterable){
		return map.bind(bind, value, index, iterable);
	}, null, onresolve, values, values);
};