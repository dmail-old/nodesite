/*

name: Object.cloning
https://gist.github.com/NV/1396086

*/

require('object-implement-property');

var References = function(){
	this.objects = [];
	this.values = [];
	this.index = 0;
};

References.prototype = {
	constructor: References,

	has: function(object){
		this.index = this.objects.indexOf(object);
		return this.index != -1;
	},

	add: function(object, value){
		this.objects.push(object);
		this.values.push(value);
	}
};

var exports = {
	enumerator: Object.keys,

	// clone the value only if it's not a reference to a previously cloned object
	cloneValue: function(value, references){
		if( references && references.has(value) ){
			value = references.values[references.index];
		}
		else{
			value = this.cloneProperties(value, references);
		}
		return value;
	},

	assignPropertyClone: function(name, object, references){
		this[name] = exports.cloneValue(object[name], references);
	},

	cloneOf: function(object, references){
		var target;

		if( Object.prototype.toString.call(object) === '[object Array]' ){
			// new Array(object) would work too, a copied array would be returned
			// but elements inside still have to be cloned
			target = new Array(object.length);
		}
		else{
			target = Object.create(Object.getPrototypeOf(object));
		}

		references = references || new References();
		references.add(object, target);

		var names = this.enumerator(object), i = names.length;
		while(i--){
			this.definePropertyClone.call(target, names[i], object, references);
		}

		return target;
	},

	cloneProperties: function(object, references){
		var target;

		if( typeof object === 'object' && object !== null ){
			if( typeof object.clone === 'function' ){
				target = object.clone();
			}
			else{
				target = this.cloneOf(object);
			}
		}
		else{
			target = object;
		}

		return target;
	},

	clonePrimitive: function(){
		return this;
	},

	cloneNative: function(){
		return new this.constructor(this.valueOf());
	}
};

// es5
if( 'getOwnPropertyDescriptor' in Object ){
	exports.enumerator = Object.getOwnPropertyNames;

	exports.definePropertyClone = function(name, object, references){
		var descriptor = Object.getOwnPropertyDescriptor(object, name);

		if( 'value' in descriptor ){
			descriptor.value = exports.cloneValue(descriptor.value, references);
		}

		Object.defineProperty(this, name, descriptor);
	};

	var cloneOf = exports.cloneOf;
	exports.cloneOf = function(object, references){
		var target = cloneOf.call(this, object, references);
		// only if es5
		if( !Object.isExtensible(object) ) Object.preventExtensions(target);
		if( Object.isSealed(object) ) Object.seal(target);
		if( Object.isFrozen(object) ) Object.freeze(target);
		return target;
	};
}
else{
	exports.definePropertyClone = exports.assignPropertyClone;
}

[String, Number, Boolean].forEach(function(constructor){
	Object.implementProperty(constructor.prototype, 'clone', exports.clonePrimitive);
});

[RegExp, Date].forEach(function(constructor){
	Object.implementProperty(constructor.prototype, 'clone', exports.cloneNative);
});

exports.cloneProperties = exports.cloneProperties.bind(exports);
Object.clone = exports.cloneProperties;
module.exports = exports;
