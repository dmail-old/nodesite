/*

ModuleLoader.load(path) -> returns an array of module found at path

a file is considered a module when he is contained into a node_modules folder

il manque de considérer tout les fichier autre que index aussi

hasModuleSignature pas besoin d'être appelé plus d'une fois, à réfléchir

*/

require('Promise');
var proto = require('proto');

var ModuleCollector = proto.create({
	fileSystem: require('fs'),
	PATH: require('path'),
	moduleFolderName: 'node_modules',

	path: null,
	badSignaturePaths: null,
	modulePaths: null,

	constructor: function(path){
		this.path = path;
	},

	filterFolder: function(path){
		var name = this.PATH.basename(path);
		return name != '.git' && name != 'vrac';
	},

	filterFile: function(path){
		return path.slice(-3) === '.js' && path != '.gitignore' && path != '.gitattributes';
	},

	hasModuleSignature: function(path){
		// contained in a directory named 'node_modules'
		var directories = path.split(this.PATH.sep);
		var index = directories.indexOf(this.moduleFolderName);

		return index > -1; //&& index < directories.length - 1;
	},

	stat: function(path){
		return Promise.from(function(complete){
			return this.fileSystem.stat(path, complete);
		}, this);
	},

	readdir: function(path){
		return Promise.from(function(complete){
			return this.fileSystem.readdir(path, complete);
		}, this);
	},

	scan: function(stat){
		var path = this.currentPath;

		if( stat.isDirectory() ){
			if( this.filterFolder(path) ){
				return this.readdir(path).then(function(names){
					var paths = names.map(function(name){
						return path + this.PATH.sep + name;
					}, this);

					paths = paths.filter(this.filterFolder, this);

					return Promise.mapReduce(paths, function(path){
						return this.collect(path);
					}, this);
				}.bind(this));
			}
		}
		else if( stat.isFile() ){
			if( this.hasModuleSignature(path) && this.filterFile(path) ){
				this.modulePaths.push(path);
			}
		}
	},

	collect: function(path){
		this.currentPath = path;

		return Promise.reduce([
			this.stat,
			this.scan
		], this, path);
	},

	resolve: function(fn, bind){
		this.modulePaths = [];
		this.badSignaturePaths = [];

		return this.collect(this.path).then(
			function(){
				fn.call(bind, null, this.modulePaths, this.badSignaturePaths);
			}.bind(this),
			function(error){
				fn.call(bind, error);
			}
		);
	}
});

module.exports = ModuleCollector;