/*

ModuleLoader.load(path) -> returns an array of module found at path

a file is considered a module when he is contained into a node_modules folder

il manque de considÃ©rer tout les fichier autre que index aussi

*/

var Task = require('Task');
var proto = require('proto');

var ModuleCollector = proto.create({
	fileSystem: require('fs'),
	PATH: require('path'),
	moduleFolderName: 'node_modules',

	path: null,
	badSignaturePaths: null,
	modulePaths: null,

	constructor: function(path){
		this.path = path;
	},

	filterFile: function(fileName){
		return fileName.slice(-3) === '.js' && fileName != '.git' &&
		fileName != '.gitignore' && fileName != '.gitattributes';
	},

	hasModuleSignature: function(path){
		// one of his parent is node_modules but the fileName != 'node_modules'
		var directories = path.split(this.PATH.sep);
		var index = directories.indexOf(this.moduleFolderName);

		return index > -1 && index < directories.length - 1;
	},

	stat: function(path){
		return Task.from(function(complete){
			return this.fileSystem.stat(path, complete);
		}, this);
	},

	readdir: function(path){
		return Task.from(function(complete){
			return this.fileSystem.readdir(path, complete);
		}, this);
	},

	scan: function(stat){
		var path = this.currentPath;

		if( stat.isDirectory() ){
			if( this.hasModuleSignature(path) ){
				var modulePath;

				try{
					// locate module path for this folder
					modulePath = require.resolve(path);
				}
				catch(e){
					this.badSignaturePaths.push(path);
				}

				if( modulePath ) this.modulePaths.push(modulePath);
			}

			return this.readdir(path).then(function(names){
				var paths = names.map(function(name){
					return path + this.PATH.sep + name;
				}, this);

				//paths = paths.filter(this.filterFile, this);

				return Task.mapReduce(paths, function(path){
					return this.collect(path);
				}, this);
			}.bind(this));
		}
		else if( stat.isFile() ){
			if( this.hasModuleSignature(path) && this.filterFile(path) ){
				//this.modulePaths.push(path);
			}
		}
	},

	collect: function(path){
		this.currentPath = path;

		return Task.reduce([
			this.stat,
			this.scan
		], this, path);
	},

	resolve: function(fn, bind){
		this.modulePaths = [];
		this.badSignaturePaths = [];

		return this.collect(this.path).then(
			function(){
				fn.call(bind, null, this.modulePaths, this.badSignaturePaths);
			}.bind(this),
			function(error){
				fn.call(bind, error);
			}
		);
	}
});

module.exports = ModuleCollector;