var exports = {
	requireWithoutCache: function(path){
		path = require.resolve(path);
		delete require.cache[path];
		return require(path);
	},

	/*
	The module dependencyLevel is the recursive sum of a module children count
	A module children array is the right one only when require.cache is empty because module are cached
	To compute the right dependencyLevel we have to delete all require.cache before require()
	But we keep a cached module object once the dependency level is known
	*/
	cache: {},
	
	clear: function(){
		// clear cache to compute the right dependencylevel
		// but module for which we already got the right level can remain in cache
		for(var id in require.cache){
			if( !(id in this.cache) ) delete require.cache[id];
		}
	},

	getDependencyTree: function(module){
		function map(child){
			return {path: child.filename, children: child.children.map(map)};
		}

		return {
			path: module.filename,
			children: module.children.map(map)
		};
	},

	getDependencyLevel: function(module){
		if( typeof module.dependencylevel === 'number' ) return module.dependencylevel;

		var level = 0, children = module.children, i = 0, j = children.length, child, childLevel;

		if( j ){
			for(;i<j;i++){
				child = children[i];
				childLevel = this.getDependencyLevel(child);
				level = Math.max(level, childLevel);
			}

			level++;
		}

		return level;
	},

	requireModule: function(path){
		path = require.resolve(path);

		if( path in this.cache ){
			return this.cache[path];
		}
		this.clear();

		require(path);

		var module = require.cache[path];
		this.cache[path] = module;
		module.dependencylevel = this.getDependencyLevel(module);
		module.dependencyTree = this.getDependencyTree(module);
		return module;
	},

	requireModuleWithoutCache: function(path){
		var fileName = require.resolve(path);
		delete require.cache[fileName];
		require(fileName);
		return require.cache[fileName];
	},	

	Collector: require('./Collector'),

	collectModulePaths: function(path, fn, bind){
		path = require('path').resolve(process.cwd(), path);
		fn = fn || console.log;
		bind = bind || console;
		return new this.Collector(path).resolve(fn, bind);
	},

	loadModules: function(paths){
		return paths.map(function(path){
			return this.requireModule(path);
		}, this);
	},

	comparer: function(moduleA, moduleB){
		return moduleA.dependencyLevel - moduleB.dependencyLevel;
	},

	sortModules: function(modules){
		return modules.sort(this.comparer);
	},

	readModuleRecursive: function(path, fn, bind){
		this.collectModulePaths(path, function(error, modulePaths, badSignaturePaths){
			var modules = null;

			if( !error ){				
				try{
					modules = this.loadModules(modulePaths);
				}
				catch(e){
					error = e;
				}
				if( !error ) modules = this.sortModules(modules);
			}

			fn.call(bind, error, modules, badSignaturePaths);
		}, this);
	}
};

exports.uncache = function(moduleName){
	// Run over the cache looking for the files
	// loaded by the specified module name
	this.searchCache(moduleName, function(mod){
		delete require.cache[mod.id];
	});

	// Remove cached paths to the module.
	// Thanks to @bentael for pointing this out.
	Object.keys(module.constructor._pathCache).forEach(function(cacheKey){
		if( cacheKey.indexOf(moduleName) > 0 ){
			delete module.constructor._pathCache[cacheKey];
		}
	});
};

exports.searchCache = function(moduleName, fn){
	// Resolve the module identified by the specified name
	var mod = require.resolve(moduleName);

	// Check if the module has been resolved and found within
	// the cache
	if( mod && ((mod = require.cache[mod]) !== undefined) ){
		// Recursively go over the results
		(function run(mod) {
			// Go over each of the module's children and
			// run over it
			mod.children.forEach(function(child){
				run(child);
			});

			// Call the specified callback providing the
			// found module
			fn(mod);
		})(mod);
	}
};

module.exports = exports;