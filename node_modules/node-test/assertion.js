var proto = require('proto');
var debug = require('debug');

require('promise');
require('promise/timeout');

var Assertion = proto.extend({
	id: null,
	timeout: 0,
	type: null,
	args: null,
	file: null,
	line: null,
	duration: 0,

	constructor: function(){
		this.args = arguments;
		this.state = 'created';
		this.duration = 0;
	},

	createPromise: function(){
		return Promise.resolve();
	},

	setTimeout: function(ms){
		this.timeout = ms;
		// test is pending change the promise timeout
		if( this.timeoutPromise ) this.timeoutPromise.setTimeout(ms);
	},

	setErrorProperties: function(error){
		var type = this.type, args = this.args;

		error.name = 'AssertionError';
		error.type = type;
		error.args = args;

		if( this.id ) error.id = this.id;

		error.file = this.file;
		error.line = this.line;
	},

	createError: function(){
		var error = new Error('failed assertion');
		this.setErrorProperties(error);
		return error;
	},

	createTimeoutError: function(){
		var error = this.createError();
		error.message = 'assertion is too slow (more than ' + this.timeout + ' ms)';
		return error;
	},

	exec: function(){
		var promise = this.createPromise();

		var start = new Date();

		if( this.timeout > 0 ){
			this.timeoutPromise = Promise.timeout(this.timeout).then(function(){
				debug('timedout assertion', this.id, this.timeout);
				throw this.createTimeoutError();
			}.bind(this));

			promise = Promise.race([
				promise,
				this.timeoutPromise
			]);
		}

		return promise.then(function(){
			this.state = 'passed';
			this.duration = new Date() - start;
		}.bind(this)).catch(function(){
			this.state = 'failed';
			this.duration = new Date() - start;
		}.bind(this));
	}
});

var AssertionFactory = proto.extend({
	assertions: {},

	constructor: function(type, args, file, line){
		var Assertion = this.assertions[type];
		var assertion = Assertion.create.apply(Assertion, args);

		assertion.file = file;
		assertion.line = line;

		return assertion;
	},

	register: function(type, properties){
		var assertion = proto.extend.call(Assertion, properties);

		assertion.type = type;

		this.assertions[type] = assertion;
	},
});

AssertionFactory.register('equal', {
	timeout: 0,

	createPromise: function(){
		var value = this.args[0], expected = this.args[1];

		return Promise.resolve(value).then(function(value){
			if( value != expected ){
				var error = this.createError();
				error.message = value + ' not equal to ' + expected;
				throw error;
			}
		}.bind(this));
	}
});

AssertionFactory.register('near', {
	timeout: 0,

	createPromise: function(){
		var value = this.args[0], expected = this.args[1], precision = this.args[2];

		return Promise.resolve(value).then(function(value){
			value = Number(value);
			var diff = value - expect;
			var differ = false;

			if( diff > 0 ? diff >= precision : diff <= precision ){
				var error = this.createError();
				error.message = value + ' not near of ' + expect + ' (' + diff + ')';
				throw error;
			}
		}.bind(this));
	}
});

AssertionFactory.register('resolveIn', {
	timeout: 0,

	createPromise: function(){
		var value = this.args[0], expectedDuration = this.args[1];
		var precision = 2 in this.args ? this.args[2] : expectedDuration * 0.3 + 5;
		var start = new Date();

		return Promise.resolve(value).then(function(value){
			var duration = new Date() - start;
			var diff = duration - expectedDuration;

			if( Math.abs(diff) > precision ){
				var error = this.createError();

				if( duration > expectedDuration ){
					error.message =  'the test took much time than expected (+' + diff  + 'ms)';
				}
				else{
					error.message = 'the test took less time than expected (-' + -diff  + 'ms)';
				}

				throw error;
			}
		}.bind(this));
	}
});

AssertionFactory.register('willResolve', {
	timeout: 100,

	createPromise: function(){
		return this.args[0].catch(function(value){
			var error = this.createError();
			error.message = 'promise expecting to resolve is rejected with ' + value;
			throw error;
		}.bind(this));
	}
});

AssertionFactory.register('willBe', {
	timeout: 100,

	createPromise: function(){
		var expected = this.args[1];

		return this.args[0].then(function(value){
			if( expected != value ){
				var error = this.createError();
				error.message = 'promise expected to resolve to '+ expected + ' but got ' + value;
				throw error;
			}
		}.bind(this));
	}
});

module.exports = AssertionFactory;