/*

Les autres test unitaires ignore les tests qui échouent et lancer les autres
Moi je choisit de m'arrêter au test qui fail

*/

var debug = require('debug');

var LineTemplate = '{lineNumber} {lineSource}';
var LineSeparator = '\n';
var LineStyles = {
	lineNumber: 'grey',
	lineSource: 'grey',
	currentLineNumber: 'white',
	currentLineSource: 'white',
	currentLine: 'bg-yellow'
};
var ConsoleTemplate = require('template-console');

var LineTemplate = ConsoleTemplate.create(LineTemplate);
LineTemplate.registerStyles(LineStyles);

function createErrorSourceLog(file, lineNumber){
	lineNumber = lineNumber - 1;

	// cannot read file out of the working directory
	if( file.indexOf(require('path').sep) === -1 ){
		return null;
	}

	var lines = require('fs').readFileSync(file, 'utf8').split(/\r?\n/);
	var contextDepth = 2;
	var minLine = Math.max(lineNumber - contextDepth, 0);
	var maxLine = Math.min(lineNumber + contextDepth, lines.length);

	lines = lines.slice(minLine, maxLine);

	var source = LineTemplate.repeat(lines, LineSeparator, function(line, index, log, array){
		if( minLine + index == lineNumber ){
			log.globalStyle = 'currentLine';
			log.registerStyle('lineNumber', 'currentLineNumber');
			log.registerStyle('lineSource', 'currentLineSource');
		}

		return {
			lineNumber: minLine + index + 1,
			lineSource: line
		};
	});

	return source;
}

function handleFailure(logger, error){
	if( error.file ){
		var stack = error.stack;
		var source = createErrorSourceLog(error.file, error.line);

		if( error.id ){
			console.log('Error in the test "', error.id, '"');
		}

		if( source == null ){
			logger.error('{stack}\n{source}', {
				stack: stack,
				source: 'node native code (certainly Promise)'
			});
		}
		else{
			logger.error('{stack}\n{path}\n{source}', {
				stack: stack,
				path: error.file,
				source: source
			});
		}
	}
	else{
		logger.error(error.stack);
	}
}

var proto = require('proto');
require('promise/cancellable');
var TerminalTemplate = require('template-terminal');

var TestReporter = proto.extend({
	constructor: function(test, logger, watch){
		this.test = test;
		this.logger = logger;
		this.watch = watch;


		var findTemplate = TerminalTemplate.create('Finding modules: {value}');
		var loadTemplate = TerminalTemplate.create('Loading test files: {value}');
		var loadModuleTemplate = TerminalTemplate.create('Loading module files: {value}');
		var execTestTemplate = TerminalTemplate.create('Executing tests: {value}');
		var moduleFound = 0;
		var testLoaded = 0;
		var moduleLoaded = 0;
		var testExecuted = 0;
		// on pourrait imaginer mettre tout ça dans un table
		// il faut juste pouvoir réécrire une ligne du tableau plusieurs fois
		// var cells = [['task', 'state', 'duration']]

		test.reactions = {
			start: function(){
				console.log('starting folder test');
			},

			done: function(){
				console.log('end of folder test', this.duration, 'ms');
			},

			findModulePaths: {
				start: function(){
					findTemplate.update({value: moduleFound});
				},

				progress: function(){
					moduleFound++;
					findTemplate.update({value: moduleFound});
				},

				done: function(){
					findTemplate.update({value: this.value.length}, true);
					console.log(', done (' + this.duration + 'ms)');
				}
			},

			filterTestFiles: {
				done: function(){
					console.log(
						'filtered test files',
						this.startValue.length -
						this.value.length,
						'(' + this.duration + 'ms)'
					);
				}
			},

			loadModuleTests: {
				start: function(){
					loadTemplate.update({value: testLoaded});
				},

				progress: function(process){
					testLoaded+= process.value.length;
					loadTemplate.update({value: testLoaded});
				},

				done: function(){
					loadTemplate.update({value: testLoaded}, true);
					console.log(', done (' + this.duration + 'ms)');
				}
			},

			filterModules: {
				done: function(){
					console.log(
						'empty modules filtered',
						this.startValue.length -
						this.value.length,
						'(' + this.duration + 'ms)'
					);
				}
			},

			loadModules: {
				start: function(){
					loadModuleTemplate.update({value: moduleLoaded});
				},

				progress: function(tests){
					moduleLoaded++;
					loadModuleTemplate.update({value: moduleLoaded});
				},

				done: function(){
					loadModuleTemplate.update({value: moduleLoaded}, true);
					console.log(', done (' + this.duration + 'ms)');
				}
			},

			sortModules: {
				done: function(){
					console.log(
						'modules sorted by dependency',
						'(' + this.duration + 'ms)'
					);
				}
			},

			execTests: {
				start: function(){
					execTestTemplate.update({value: testExecuted});
				},

				progress: function(tests){
					testExecuted+= tests.length;
					execTestTemplate.update({value: testExecuted});
				},

				done: function(){
					execTestTemplate.update({value: testExecuted}, true);
					console.log(', done (' + this.duration + 'ms)');
				}
			}
		};

		if( watch ) this.enableFileWatch();
		this.start();
	},

	handleFolderResult: function(folderTest){
		//console.log(folderTest);
		return;

		if( folderTest.moduleTests.length === 1 ) return this.handleModuleResult(folderTest.moduleTests[0]);

		var message = 'Test results of {path} ({duration}ms {count} modules)\n{results}';

		this.logger.info(message, {
			path: folderTest.path,
			duration: folderTest.duration,
			count: folderTest.moduleTests.length,
			results: folderTest.toTable().toString()
		});
	},

	handleModuleResult: function(moduleTest){
		if( moduleTest.tests.length === 1 ) return this.handleTestResult(moduleTest.tests[0]);

		var message = 'Module test results {path} ({duration}ms {count} files)\n{results}';

		this.logger.info(message, {
			path: moduleTest.path,
			duration: moduleTest.duration,
			count: moduleTest.tests.length,
			results: moduleTest.toTable().toString()
		});
	},

	handleTestResult: function(meta){
		// we should render an assertions table

		var test = this.test;
		var message = 'Test results {description] ({duration}ms {count} assertions)\n{results}';

		this.logger.info(message, {
			description: test.description,
			duration: test.duration,
			count: test.assertionCount,
			results: test.toTable().toString()
		});
	},

	// EBUSY peut se produire ici aussi, il faudrait la même logique que dans nodeprocess
	moduleChangeReaction: function(moduleTest){
		console.log(moduleTest.path + ' module modified');
		require('module-util').uncache(moduleTest.path);
		//delete require.cache[moduleTest.path];
		delete moduleTest.util.cache[moduleTest.path];
		this.restart();
	},

	fileChangeReaction: function(testFile){
		console.log(testFile.path + ' file modified');
		require('module-util').uncache(testFile.path);
		//delete require.cache[testFile.path];
		this.restart();
	},

	enableFileWatch: function(){
		if( this.test.type === 'folder' ){
			this.test.moduleChangeReaction = this.moduleChangeReaction.bind(this);
			this.test.fileChangeReaction = this.fileChangeReaction.bind(this);
		}
		else if( this.test.type === 'module' ){
			this.test.changeReaction = this.moduleChangeReaction.bind(this);
			this.test.fileChangeReaction = this.fileChangeReaction.bind(this);
		}
	},

	cancel: function(){
		this.promise.cancel();
	},

	start: function(){
		this.promise = Promise.cancellable(this.test.exec());

		this.promise.then(
			function(){
				return null;
			},
			function(error){
				if( !error ) error = new Error('rejected task without error');
				return error;
			}
		).then(function(error){
			if( this.test.type === 'folder' ){
				this.handleFolderResult(this.test);
			}
			else if( this.test.type === 'module' ){
				this.handleModuleResult(this.test);
			}
			else{
				this.handleTestResult(this.test);
			}

			if( error ){
				handleFailure(this.logger, error);
			}

		}.bind(this));
	},

	restart: function(){
		this.cancel();

		// avoid to recall restart when file is modified
		this.test.moduleChangeReaction = null;
		this.test.fileChangeReaction = null;
		this.test.changeReaction = null;
		// reset test metas and other stuff
		// this.test.reset();

		this.start();
	}
});

var unit = require('./unit');
var nodetest = {
	testFolder: function(path, watch){
		path = require('path').resolve(process.cwd(), path);
		return TestReporter.create(unit.testFolder(path), watch);
	},

	testModule: function(path, watch){
		path = require.resolve(path);
		return TestReporter.create(unit.testModule(path), watch);
	},

	testFile: function(path, module){

	},

	test: function(test, module){

	}
};

module.exports = nodetest;