/*
Test.create(fn, description, String | Object | Module)

String -> new ModuleTest(string)
Object -> new ModuleTest(object)
Module -> module
-> TypeError
*/

require('promise');
var proto = require('@dmail/proto');
var debug = require('debug');
var Assertion = require('./assertion');
var stackTrace = require('stack-trace');

var Test = proto.extend({
	Assertion: Assertion,
	type: 'test',
	fn: null,
	imports: null,
	description: 'no desc',
	assertions: [],

	constructor: function(fn, description){
		this.fn = fn;
		this.description = description ? String(description) : fn.name;
		this.reset();
	},

	toString: function(){
		return '[object Test ' + this.description + ']';
	},

	reset: function(){
		this.state = 'created';
		this.assertions = [];
		this.duration = 0;
	},

	getCaller: function(error){
		var stack;

		if( error ){
			stack = stackTrace.fromError(error, __filename);
		}
		else{
			stack = stackTrace.get(__filename);
		}

		return {
			file: stack[0].getFileName(),
			line: stack[0].getLineNumber()
		};
	},

	// how to skip a test?
	skip: function(){
		this.state = 'skipped';
	},

	createAssertion: function(type, args){
		var caller = this.getCaller();
		var assertion = this.Assertion.create(type, args, caller.file, caller.line);

		assertion.id = this.description;

		return assertion;
	},

	assert: function(type, args){
		var assertion = this.createAssertion(type, args);
		this.assertions.push(assertion);
		return assertion;
	},

	createAssertions: function(){
		try{
			if( this.fn.length > 1 ){
				this.fn.call(this, this, this.imports);
			}
			else{
				this.fn.call(this, this);
			}
		}
		catch(e){
			// get error trace
			var caller = this.getCaller(e);
			e.file = caller.file;
			e.line = caller.line;
			throw e;
		}
	},

	execAssertions: function(){
		if( this.state === 'skipped' ) return Promise.resolve();

		return Promise.mapReduce(this.assertions, function(assertion){
			return assertion.exec();
		}).then(function(){
			this.state = 'passed';
			return this;
		}.bind(this)).catch(function(value){
			this.state = 'failed';
			return Promise.reject(value);
		}.bind(this));
	},

	exec: function(){
		var start = new Date();

		return Promise.reduce([
			this.createAssertions,
			this.execAssertions,
			function(){
				this.duration = new Date() - start;
				return this;
			}
		], this);
	}
});

Object.keys(Assertion.assertions).forEach(function(key){
	Test[key] = function(){
		return this.assert(key, arguments);
	};
});

module.exports = Test;
