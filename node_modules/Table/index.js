var proto = require('proto');
var Cell = require('./Cell');
var CellRange = require('./CellRange');
var forOf = require('forOf');

require('array/from');
require('array/prototype/findIndex');
require('object/toSource');

var Table = proto.extend({
	Cell: Cell,
	CellRange: CellRange,
	Comparer: require('array/sortBy').Comparer,
	Graph: require('DependencyResolver'),
	cells: null,
	compiled: false,

	constructor: function(cells){
		this.cells = [];
		if( cells ){
			this.addRows(cells);
		}
	},

	createCell: function(x, y, data){
		var cell = this.Cell.create(x, y, data);
		return cell;
	},

	addRow: function(cellRow){
		var y = this.cells.length;

		this.cells[y] = cellRow.map(function(cellData, x){
			return this.createCell(x, y, cellData);
		}, this);
	},

	addRows: function(cellRows){
		var i = 0, j = cellRows.length;
		for(;i<j;i++){
			this.addRow(cellRows[i]);
		}
	},

	createCellRange: function(x, y, w, h){
		return this.CellRange.create(this.cells, x, y, w, h);
	},

	column: function(x){
		if( typeof x === 'number' ){
			return this.createCellRange(x, 0, 1, 'auto');
		}
		else if( x instanceof CellRange ){
			return x;
		}
		else if( x instanceof Cell ){
			return this.column(x.x);
		}
		else{
			var foundCell = null;
			forOf(this.row(0), function(cell){
				if( cell.data === x ){
					foundCell = cell;
					return true;
				}
			});
			return foundCell ? this.column(foundCell) :  null;
		}
	},

	row: function(y){
		if( typeof y === 'number' ){
			return this.createCellRange(0, y, 'auto', 1);
		}
		else if( y instanceof CellRange ){
			return y;
		}
		else if( y instanceof Cell ){
			return this.column(y.y);
		}
		else{
			var foundCell = null;
			forOf(this.column(0), function(cell){
				if( cell.data === y ){
					foundCell = cell;
					return true;
				}
			});
			return foundCell ? this.row(foundCell) :  null;
		}
	},

	all: function(){
		return this.createCellRange(0, 0, 'auto', 'auto');
	},

	compile: function(){
		if( this.compiled ) return;

		var graph = this.Graph.create();
		forOf(this, function(cell){
			graph.add(cell, cell.dependencies);
		});

		var orderedCells = graph.sort();
		orderedCells.forEach(function(cell){
			cell.compute();
			cell.format();
		}, this);

		this.compiled = true;
	},

	sortRows: function(){
		var args = arguments, comparer = this.Comparer.create(), i = 0, j = args.length, arg, order, column;

		for(;i<j;i+=2){
			arg = args[i];
			order = args[i + 1];
			column = this.column(arg);
			comparer.addDistinction(function(row){
				return row[column.x].data;
			}, order);
		}

		var unfixedRowIndex = Array.from(this.column(0)).findIndex(function(cell){ return cell.fixed === false; });
		this.cells = this.cells.slice(0, unfixedRowIndex).concat(this.cells.slice(unfixedRowIndex).sort(comparer.compare));
	},

	toJSON: function(){
		return {
			cells: this.cells
		};
	},

	toSource: function(){
		return 'Table.create(' + Object.toSource(this.cells) + ')';
	}
});

Table[Symbol.iterator] = function(){
	return this.all()[Symbol.iterator]();
};

module.exports = Table;