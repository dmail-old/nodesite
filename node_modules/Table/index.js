var proto = require('proto');
var Cell = require('./Cell');
var CellRange = require('./CellRange');
var forOf = require('forOf');

require('Array.from');
require('Array.prototype.findIndex');
require('Object.toSource');

var Table = proto.create({
	Cell: Cell,
	CellRange: CellRange,
	Comparer: require('Array.sortBy').Comparer,
	Graph: require('DependencyResolver'),
	cells: null,
	compiled: false,

	constructor: function(cells){
		this.cells = [];
		if( cells ){
			this.addRows(cells);
		}
	},

	createCell: function(x, y, data){
		var cell = new this.Cell(x, y, data);
		return cell;
	},

	addRow: function(cellRow){
		var y = this.cells.length;

		this.cells[y] = cellRow.map(function(cellData, x){
			return this.createCell(x, y, cellData);
		}, this);
	},

	addRows: function(cellRows){
		var i = 0, j = cellRows.length;
		for(;i<j;i++){
			this.addRow(cellRows[i]);
		}
	},

	createCellRange: function(x, y, w, h){
		return new this.CellRange(this.cells, x, y, w, h);
	},
	
	column: function(x){
		if( typeof x === 'number' ){
			return this.createCellRange(x, 0, 1, 'auto');
		}
		else if( x instanceof CellRange ){
			return x;
		}
		else if( x instanceof Cell ){
			return this.column(x.x);
		}
		else{
			var foundCell = null;
			forOf(this.row(0), function(cell){
				if( cell.data === x ){
					foundCell = cell;
					return true;
				}
			});
			return foundCell ? this.column(foundCell) :  null;
		}
	},

	row: function(y){
		if( typeof y === 'number' ){
			return this.createCellRange(0, y, 'auto', 1);
		}
		else if( y instanceof CellRange ){
			return y;
		}
		else if( y instanceof Cell ){
			return this.column(y.y);
		}
		else{
			var foundCell = null;
			forOf(this.column(0), function(cell){
				if( cell.data === y ){
					foundCell = cell;
					return true;
				}
			});
			return foundCell ? this.row(foundCell) :  null;
		}
	},

	compile: function(){
		if( this.compiled ) return;

		var graph = new this.Graph();
		forOf(this, function(cell){
			graph.add(cell, cell.dependencies);
		});

		var orderedCells = graph.sort();
		orderedCells.forEach(function(cell){
			cell.compute();
			cell.format();
		}, this);

		this.compiled = true;
	},

	sortRows: function(){
		var args = arguments, comparer = new this.Comparer(), i = 0, j = args.length, arg, order, column;

		for(;i<j;i+=2){
			arg = args[i];
			order = args[i + 1];
			column = this.column(arg);
			comparer.addDistinction(function(row){
				return row[column.x].data;
			}, order);
		}

		var unfixedRowIndex = Array.from(this.column(0)).findIndex(function(cell){ return cell.fixed === false; });
		this.cells = this.cells.slice(0, unfixedRowIndex).concat(this.cells.slice(unfixedRowIndex));
	},

	toJSON: function(){
		return {
			cells: this.cells
		};
	},

	toSource: function(){
		return 'new Table(' + Object.toSource(this.cells) + ')';
	}
});

Table.prototype[Symbol.iterator] = function(){
	var cells = this.cells, height = cells.length, width;
	width = height === 0 ? 0 : cells[0].length;
	return new CellRange.prototype.Iterator(cells, 0, 0, width, height);
};

module.exports = Table;