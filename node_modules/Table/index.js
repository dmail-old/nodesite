var proto = require('proto');
var Cell = require('./Cell');
var CellRange = require('./CellRange');
var forOf = require('forOf');

var Table = proto.create({
	Comparer: require('Array.sortBy').Comparer,
	Graph: require('DependencyResolver'),
	cells: null,

	constructor: function(){
		this.cells = [];

		if( arguments.length ){
			this.addRows(Array.prototype.slice.call(arguments));
		}
	},

	createCell: function(x, y, meta){
		var cell = new Cell(x, y, meta);
		return cell;
	},

	addRow: function(cellRow){
		var y = this.cells.length;

		this.cells[y] = cellRow.map(function(cellMeta, x){
			return this.createCell(x, y, cellMeta);
		}, this);
	},

	addRows: function(cellRows){
		var i = 0, j = cellRows.length;
		for(;i<j;i++){
			this.addRow(cellRows[i]);
		}
	},
	
	column: function(x){
		if( typeof x === 'number' ){
			return new CellRange(this.cells, x, 0, 1, 'auto');
		}
		else if( x instanceof CellRange ){
			return x;
		}
		else if( x instanceof Cell ){
			return this.column(x.x);
		}
		else{
			var foundCell = null;
			forOf(this.row(0), function(cell){
				if( cell.data === x ){
					foundCell = cell;
					return true;
				}
			});
			return foundCell ? this.column(foundCell) :  null;
		}
	},

	row: function(y){
		if( typeof y === 'number' ){
			return new CellRange(this.cells, 0, y, 'auto', 1);
		}
		else if( y instanceof CellRange ){
			return y;
		}
		else if( y instanceof Cell ){
			return this.column(y.y);
		}
		else{
			var foundCell = null;
			forOf(this.column(0), function(cell){
				if( cell.data === y ){
					foundCell = cell;
					return true;
				}
			});
			return foundCell ? this.row(foundCell) :  null;
		}
	},

	sortRowsBy: function(){
		this.sortBy = arguments;
	},

	sort: function(args){
		var comparer = new this.Comparer(), i = 0, j = args.length, arg, order, column;

		for(;i<j;i+=2){
			arg = args[i];
			order = args[i + 1];
			column = this.column(arg);
			comparer.addDistinction(function(row){
				return row[column.x].data;
			}, order);
		}

		var cells = this.cells, fixedRows = [];
		i = 0;
		j = cells.length;
		for(;i<j;i++){
			if( cells[i][0].fixed === true ){
				fixedRows.push(cells.shift());
				j--;
			}
		}

		this.cells = fixedRows.concat(cells.sort(comparer.compare));
	},

	prepare: function(){
		/*
		lorsqu'une colonne à des dépendances
		on va remplir le contenu en fonction des valeurs trouvé dans les colonnes en rapport
		il faudrais commencer par remplir les colonnes les moins dépendantes
		*/

		var graph = new this.Graph();

		forOf(this, function(cell){
			graph.add(cell, cell.dependencies);
		});

		var orderedCells = graph.sort();

		// obtiens les valeurs des cellules dans le bon ordre
		orderedCells.forEach(function(cell){
			cell.compute();
		}, this);

		// génère le contenu formatté depuis la valeur de la celulle
		orderedCells.forEach(function(cell){
			cell.format();
		});

		if( this.sortBy ){
			this.sort(this.sortBy);
		}
	}
});

Table.prototype[Symbol.iterator] = function(){
	var cells = this.cells, height = cells.length, width;
	width = height === 0 ? 0 : cells[0].length;
	return new CellRange.prototype.Iterator(cells, 0, 0, width, height);
};

module.exports = Table;