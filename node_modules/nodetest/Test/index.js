/*

Ici aussi on pourrait avoir un event 'progress' au fur et à mesure
que les assertions sont vérifiées
lengthComputable vaudrait null lorsqu'on ne connait pas le nombre total d'assertions
sinon il serait égal à expectedAssertions

*/

var TestPrototype = require('../TestPrototype');
var proto = require('proto');

var Test = proto.extend(TestPrototype, {
	type: 'test',
	name: 'Anonymous test',
	timeout: 100,
	imports: null,
	assertions: null,
	expectedAssertions: null,
	progressEvent: null,
	assertMethods: {
		'ok': function(a){
			return Boolean(a);
		},

		'equal': function(a, b){
			return a == b;
		},

		'strictEqual': function(a, b){
			return a === b;
		},

		'typeOf': function(a, b){
			return typeof a === b;
		},

		'protoOf': function(a, b){
			return Object.getPrototypeOf(a) === b;
		},

		'error': function(a, b){
			try{
				a();
			}
			catch(e){
				if( b ){
					if( typeof b == 'string' ){
						return e.type.toLowerCase() === b.toLowerCase();
					}
					else if( typeof b == 'function' ){
						return e instanceof b;
					}
				}				
				return true;
			}
			return false;
		}
	},

	constructor: function(name, test){
		TestPrototype.call(this, test);
		this.name = String(name);
	},

	onprogress: function(){},

	get module(){
		return this.parent ? this.parent.module : null;
	},

	createImports: function(){
		// can be commented because module cache is invalidated so module.exports is safe
		//return this.clone(this.module.exports);
		return this.module ? this.module.exports : null;
	},

	setup: function(){
		this.imports = this.createImports();
		this.assertions = [];
		this.progressEvent = {
			target: this,
			total: this.expectedAssertions,
			lengthComputable: typeof this.expectedAssertions == 'number',
			loaded: 0
		};
		//global.imports = this.imports;
	},

	teardown: function(){
		//global.imports = null;
	},

	_exec: function(){
		return this.test.call(this, this, this.imports);
	},

	expect: function(length){
		this.expectedAssertions = length;
		if( this.progressEvent ){
			this.progressEvent.lengthComputable = true;
			this.progressEvent.total = length;
		}
		return this;
	},

	createAssertionError: function(type, args){
		var error = new Error('failed assertion');
		error.name = 'AssertionError';
		error.type = type;
		error.args = args;
		error.fileName = this.parent.path;
		return error;
	},

	assert: function(type, args){
		// test already completed, assertion ignored
		if( this.isCompleted() ) return;

		var assertion = {
			type: type,
			args: args,
			ok: this.assertMethods[type].apply(this, args)
		};

		this.assertions.push(assertion);

		if( !assertion.ok ){
			// le test échoue dès qu'une assertion échoue
			this.reject(this.createAssertionError(type, args));
		}
		else{
			this.progressEvent.loaded++;
			this.onprogress(this.progressEvent);
		}
	},

	createAssertionsLengthError: function(){
		return new Error('Expect' + this.expectedAssertions + 'and got ' + this.assertions.length);
	},

	done: function(){
		// test already completed, done() ignored
		if( this.isCompleted() ) return;
	
		// only happens when expect(length) is called and we haven't check length stuff
		if( typeof this.expectedAssertions == 'number' && this.assertions.length != this.expectedAssertions ){
			this.reject(this.createAssertionsLengthError());
		}
		else{
			this.resolve();
		}
	},

	toString: function(){
		return '[object Test ' + this.name + ']';
	}
});

Object.keys(Test.prototype.assertMethods).forEach(function(key){
	Test.prototype[key] = function(){
		return this.assert(key, arguments);
	};
});

module.exports = Test;