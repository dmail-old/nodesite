var proto = require('proto');
var debug = require('debug');

require('promise');
require('promise/timeout');

var Assertion = proto.extend({
	id: null,
	timeout: 0,
	type: null,
	args: null,

	constructor: function(){
		this.args = arguments;
		this.state = 'created';
	},

	createPromise: function(){
		return Promise.resolve();
	},

	setTimeout: function(ms){
		this.timeout = ms;
		// test is pending change the promise timeout
		if( this.timeoutPromise ) this.timeoutPromise.setTimeout(ms);
	},

	setErrorProperties: function(error){
		var type = this.type, args = this.args;

		error.name = 'AssertionError';
		error.type = type;
		error.args = args;

		if( this.id ) error.id = this.id;

		error.file = this.file;
		error.line = this.line;
	},

	createError: function(){
		var error = new Error('failed assertion');
		this.setErrorProperties(error);
		return error;
	},

	createTimeoutError: function(){
		var error = this.createError();
		error.message = 'assertion is too slow (more than ' + this.timeout + ' ms)';
		return error;
	},

	exec: function(){
		var promise = this.createPromise();

		if( this.timeout > 0 ){
			this.timeoutPromise = Promise.timeout(this.timeout).then(function(){
				debug('timedout assertion', this.id, this.timeout);
				throw this.createTimeoutError();
			}.bind(this));

			promise = Promise.race([
				promise,
				this.timeoutPromise
			]);
		}

		return promise.then(function(){
			this.state = 'passed';
		}.bind(this)).catch(function(){
			this.state = 'failed';
		}.bind(this));
	}
});

var AssertionFactory = proto.extend({
	assertions: {},

	constructor: function(type, args, file, line){
		var Assertion = this.assertions[type];
		var assertion = Assertion.create.apply(Assertion, args);

		assertion.file = file;
		assertion.line = line;

		return assertion;
	},

	register: function(type, properties){
		var assertion = proto.extend.call(Assertion, properties);

		assertion.type = type;

		this.assertions[type] = assertion;
	},
});

AssertionFactory.register('equal', {
	timeout: 0,

	createPromise: function(){
		var value = this.args[0], expected = this.args[1];

		return new Promise(function(resolve, reject){
			if( value == expected ){
				resolve();
			}
			else{
				var error = this.createError();
				error.message = value + ' not equal to ' + expected;
				throw error;
			}
		}.bind(this));
	}
});

AssertionFactory.register('willResolve', {
	timeout: 100,

	createPromise: function(){
		return this.args[0].catch(function(value){
			var error = this.createError();
			error.message = 'promise expecting to resolve is rejected with ' + value;
			throw error;
		}.bind(this));
	}
});

AssertionFactory.register('willBe', {
	timeout: 100,

	createPromise: function(){
		var expected = this.args[1];

		return this.args[0].then(function(value){
			if( expected != value ){
				var error = this.createError();
				error.message = 'promise expected to resolve to '+ expected + ' but got ' + value;
				throw error;
			}
		}.bind(this));
	}
});

module.exports = AssertionFactory;