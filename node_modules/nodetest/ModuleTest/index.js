/*
Why Loader ?

-> We have to test the most dependent module in the end

To order the module tests by dependency we have to require() them and add their children count recursively
Because require.cache mess with children we have to delete all require.cache before require()
But we keep the module cache once the dependency level of this module is known
*/

var TestSerie = require('../TestSerie');
var proto = require('proto');

var ModuleTest = proto.extend(TestSerie, {
	type: 'module',
	Test: require('../FileTest'),
	Collector: require('../FileTestCollector'),
	FileObserver: require('FileObserver'),
	module: null,

	constructor: function(module, tests){
		this.module = module;
		this.path = module.filename;
		this.name = 'Test for module: ' + this.path;
		TestSerie.call(this, tests);		
	},

	load: function(){
		var filePaths = this.Collector.collect(this.path), i = 0, j = filePaths.length;

		for(;i<j;i++){
			var fileTest = this.createChild(filePaths[i]);
			fileTest.load();
			if( fileTest.length ){
				this.add(fileTest);
			}
		}
	},

	observe: function(fn, bind){
		// currently this.path is the path to the module file, dpenedencies are ignored
		// so we always got a file no need to collectFileSync
		/*
		require('fs.extra').collectFileSync(this.path).forEach(function(file){
			this.FileObserver.observe(file, this.onChange, this);
		}, this);
		*/

		function listener(){
			fn.call(bind, this);
		}

		this.FileObserver.prototype.observe(this.path, listener, this);

		this.forEach(function(fileTest){
			this.FileObserver.prototype.observe(fileTest.path, listener, fileTest);	
		}, this);
	}
});

module.exports = ModuleTest;