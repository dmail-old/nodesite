/*

TODO

TestFile est destiné à disparaitre
c'est à dire qu'un module peut avoir une liste de tests associés, testFile est un moyen
de remplir cette liste mais pas le seul genre

var ModuleTest = new ModuleTest();

ModuleTest.addTest(new Test(function(){}));

MORE

- maybe add a skip(reason) method a skip the test under some conditions (reason is optionnal)
and a method skipIf(condition, reason)

*/

require('promise/reduce');
require('promise/map');
require('promise/mapReduce');
require('promise/timeout');
var proto = require('proto');
var debug = require('debug');

var Assertion = proto.extend({
	type: null,
	args: null,
	error: null,
	methods: {
		'ok': function(a){
			return Boolean(a);
		},

		'equal': function(a, b){
			return a == b;
		},

		'strictEqual': function(a, b){
			return a === b;
		},

		'typeOf': function(a, b){
			return typeof a === b;
		},

		'protoOf': function(a, b){
			return Object.getPrototypeOf(a) === b;
		},

		'error': function(a, b){
			try{
				a();
			}
			catch(e){
				if( b ){
					if( typeof b == 'string' ){
						return e.type.toLowerCase() === b.toLowerCase();
					}
					else if( typeof b == 'function' ){
						return e instanceof b;
					}
				}
				return true;
			}
			return false;
		},


	},

	constructor: function(type, args, file, line){
		this.type = type;
		this.args = args;
		this.file = file;
		this.line = line;
	},

	exec: function(){
		return this.methods[this.type].apply(this, this.args);
	},

	setErrorProperties: function(error){
		var type = this.type, args = this.args;

		if( type == 'equal' ){
			error.message = args[0] + ' not equal to ' + args[1];
		}
		else if( type == 'unexpectedRejection' ){
			error.message = 'promise expecting to resolve is rejected with ' + args[0];
		}
		else if( type == 'unexpectedResolution' ){
			error.message = 'promise expecting to fail is resolved with ' + args[0];
		}
		else if( type == 'timeout' ){
			error.message = 'test is too slow (more than ' + args[0] + ' ms)';
		}
		else if( type == 'uncaughtException' ){
			error.message = 'test has raised an error ' + args[0];
		}

		error.name = 'AssertionError';
		error.type = type;
		error.args = args;

		if( this.id ) error.id = this.id;

		error.file = this.file;
		error.line = this.line;
	},

	createError: function(){
		var error = new Error('failed assertion');
		this.setErrorProperties(error);
		return error;
	}
});

/*
new Test(fn, description, String | Object | Module)

String -> new ModuleTest(string)
Object -> new ModuleTest(object)
Module -> module
-> TypeError
*/

require('array/prototype/findIndex');

var Test = proto.extend({
	timeout: 100,
	type: 'test',
	fn: null,
	moduleTest: null,
	description: 'no desc',
	assertions: null,
	pendingCount: 0,

	constructor: function(fn, moduleTest, description){
		this.fn = fn;
		if( moduleTest ) this.moduleTest = ModuleTest.create(moduleTest);
		this.description = description ? String(description) : fn.name;
		this.reset();
	},

	reset: function(){
		this.state = 'created';
		this.assertions = [];
		this.duration = 0;
	},

	trace: function(error){
		var stackTrace = require('stackTrace'), stack;

		if( error ){
			stack = stackTrace.fromError(error, __filename);
		}
		else{
			stack = stackTrace.get(__filename);
		}

		return {
			file: stack[0].getFileName(),
			line: stack[0].getLineNumber()
		};
	},

	createAssertion: function(type, args){
		var trace = this.trace();
		var assertion = Assertion.create(type, args, trace.file, trace.line);

		assertion.test = this;
		assertion.id = this.description;

		return assertion;
	},

	assert: function(type, args){
		var assertion = this.createAssertion(type, args);

		this.assertions.push(assertion);

		if( !assertion.exec() ){
			throw assertion.createError();
		}
	},

	willResolve: function(promise, internal){
		promise = this.promise(promise);

		if( !internal ){
			// create assertion now, else the trace is lost into promise callbacks
			var assertion = this.createAssertion('resolve', [promise]);
			this.assertions.push(assertion);

			this.pendingCount++;
		}

		promise.then(
			function(value){
				debug('promise resolved');

				this.pendingCount--;
				if( this.pendingCount !== 0 ) return;

				this.resolve(); // test resolved
			}.bind(this),
			function(value){
				debug('promise rejected');
				this.pendingCount--;
				// if( this.pendingCount !== 0 ) return; // we reject the test immediatly

				if( value && value.name == 'AssertionError' ){
					throw value;
				}
				else{
					assertion.args.push(value);
					throw assertion.createError();
				}
			}.bind(this)
		);
	},

	willBe: function(promise, expected){
		promise = this.promise(promise);

		// create assertion now, else the trace is lost into promise callbacks
		var assertion = this.createAssertion('willBe', [promise, expected]);
		this.assertions.push(assertion);

		promise = promise.then(
			function(value){
				assertion.args.push(value);
				if( expected != value ){
					throw assertion.createError();
				}
				return value;
			}.bind(this)
		);

		return this.willResolve(promise, true);
	},

	promise: function(executor){
		var promise;

		if( typeof executor == 'function' ){
			promise = new Promise(executor);
		}
		else{
			promise = executor;
		}

		return promise;
	},

	loadModule: function(){
		return this.fn.length === 1 ? Promise.resolve() : this.moduleTest.load();
	},

	createTimeoutError: function(){
		var error = this.createAssertion('timeout', [this.timeout]).createError();
		return error;
	},

	setTimeout: function(ms){
		this.timeout = ms;
		// test is pending change the promise timeout
		if( this.timeoutPromise ) this.timeoutPromise.setTimeout(ms);
	},

	exec: function(){
		var start = new Date();

		var promise = new Promise(function(resolve, reject){
			this.state = 'started';
			this.resolve = resolve;
			this.reject = reject;
			this.pendingCount = 0;
			// voué à disparaitre, uniquement accessible via le second arguments de la fonction
			this.imports = this.moduleTest.module.exports;

			if( this.fn.length > 1 ){
				this.fn.call(this, this, this.imports);
			}
			else{
				this.fn.call(this, this);
			}

			if( this.pendingCount === 0 ){
				resolve();
			}
		}.bind(this)).catch(function(error){
			if( error.name != 'AssertionError' ){
				// get error trace
				var trace = this.trace(error);
				error.file = trace.file;
				error.line = trace.line;
			}
			return Promise.reject(error);
		}.bind(this)).then(function(){
			debug('test resolved', this.description);
			this.state = 'passed';
			this.duration = new Date() - start;
		}.bind(this));

		if( this.timeout > 0 && this.pendingCount > 0 ){
			this.timeoutPromise = Promise.timeout(this.timeout).then(function(){
				debug('timedout test', this.description, this.timeout);
				throw this.createTimeoutError();
			}.bind(this));
			promise = Promise.race([
				promise,
				this.timeoutPromise
			]);
		}

		return promise.catch(function(value){
			debug('test rejected', this.description, 'with', value);
			this.state = 'failed';
			return Promise.reject(value);
		}.bind(this));
	},

	// loadModule + loadAssertion + execAssertions
	test: function(){
		return Promise.reduce([
			this.loadModule,
			this.exec
		], this);
	},

	toString: function(){
		return '[object Test ' + this.description + ']';
	}
});

Object.keys(Assertion.methods).forEach(function(key){
	Test[key] = function(){
		return this.assert(key, arguments);
	};
});


/*
new FileTest(path, undefined | String | Object | Module)

undefined -> convertit en un possible module en utilisant path de fileTest
String -> new ModuleTest(string)
Object -> new ModuleTest(object)
Module -> module
*/

var TestFile = proto.extend({
	type: 'file',
	FileObserver: require('FileObserver'),
	path: null,
	moduleTest: null,
	tests: null,

	constructor: function(path, moduleTest, changeReaction){
		if( !moduleTest ){
			moduleTest = FolderTest.FileCollector.getModuleFromTestFile(moduleTest);
		}
		moduleTest = ModuleTest.create(moduleTest);
		this.path = path;
		this.moduleTest = moduleTest; // trouve module grâce à filePath
		this.reset();

		changeReaction = changeReaction || moduleTest.fileChangeReaction;

		if( changeReaction ){
			this.observe(function(){
				changeReaction(this);
			}, this);
		}
	},

	reset: function(){
		this.state = 'created';
		this.tests = [];
		this.execDuration = 0;
	},

	observe: function(fn, bind){
		this.FileObserver.observe(this.path, fn, bind);
	},

	createTest: function(testFn, description){
		return Test.create(testFn, this.moduleTest, description);
	},

	load: function(){
		return new Promise(function(resolve, reject){
			this.state = 'loaded';
			this.exports = require(this.path);
			resolve(this.exports);
		}.bind(this));
	},

	createTests: function(){
		return this.tests = Object.keys(this.exports).map(function(key){
			return this.createTest(this.exports[key], key);
		}, this);
	},

	loadModule: function(){
		return this.moduleTest.load();
	},

	execTests: function(){
		var start = new Date();

		return Promise.map(this.tests, function(test){
			return test.exec();
		}).then(function(){
			this.state = 'passed';
			this.execDuration = new Date() - start;
			return this;
		}.bind(this)).catch(function(value){
			debug('testfile rejected', this.path, 'with', value);
			this.state = 'failed';
			return Promise.reject(value);
		}.bind(this));
	},

	test: function(){
		var start = new Date();

		return Promise.reduce([
			this.load, // load file content
			this.createTests, // create tests from file content
			this.loadModule, // load the module
			this.execTests, // exec test in the file
		], this).then(function(){
			this.duration = new Date() - start;
			return this;
		});
	}
});

/*
new ModuleTest(path)
*/
var ModuleTest = proto.extend({
	type: 'module',
	TestFile: TestFile,
	FileObserver: require('FileObserver'),
	FileCollector: require('../TestFileCollector'),
	util: require('module-util'),
	path: null,
	module: null,
	testFiles: null,

	constructor: function(path, changeReaction, fileChangeReaction){
		if( ModuleTest.isPrototypeOf(path) ) return path;
		if( typeof path === 'object' ){
			this.module = {
				exports: path,
				dependencyLevel: 0,
				parent: null,
				children: []
			};
			this.load = function(){
				return this.module;
			};
		}

		this.path = path;
		this.reset();

		if( changeReaction ){
			this.observe(function(){
				changeReaction(this);
			}, this);
		}
		if( fileChangeReaction ){
			this.fileChangeReaction = fileChangeReaction;
		}
	},

	reset: function(){
		this.state = 'created';
		this.testFiles = [];
		this.requireDuration = 0;
		this.findDuration = 0;
		this.loadDuration = 0;
		this.execDuration = 0;
		this.duration = 0;
	},

	toJSON: function(){
		return {
			state: this.state,
			testFiles: this.testFiles,
			requireDuration: this.requireDuration,
			findDuration: this.findDuration,
			loadDuration: this.loadDuration,
			execDuration: this.execDuration,
			duration: this.duration
		};
	},

	hasTest: function(){
		return this.testFiles.some(function(testFile){
			return testFile.tests.length !== 0;
		});
	},

	observe: function(fn, bind){
		// test.path lead to the module main file (index.js), dependencies are ignored
		// to be exaustive we should detect dependencies changes too
		this.FileObserver.observe(this.path, fn, bind);
	},
	fileChangeReaction: function(testFile){},

	load: function(){
		var start = new Date();
		return new Promise(function(resolve){
			this.module = this.util.requireModule(this.path);
			resolve(this.module);
		}.bind(this)).then(function(module){
			this.state = 'loaded';
			this.requireDuration = new Date() - start;
			return module;
		}.bind(this));
	},

	findFilePaths: function(){
		var start = new Date();
		return new Promise(function(resolve, reject){
			this.FileCollector.collect(this.path, function(error, filePaths){
				if( error ) reject(error);
				else resolve(filePaths);
			}, this);
		}.bind(this)).then(function(filePaths){
			this.state = 'prepared';
			this.findDuration = new Date() - start;
			return filePaths;
		}.bind(this));
	},

	createFiles: function(filePaths){
		return this.testFiles = filePaths.map(function(filePath){
			return this.TestFile.create(filePath, this, this.fileChangeReaction);
		}, this);
	},

	loadFiles: function(){
		var start = new Date();

		return Promise.mapReduce(this.testFiles, function(testFile){
			return testFile.load();
		}).then(function(){
			this.state = 'ready';
			this.loadDuration = new Date() - start;
		}.bind(this));
	},

	createTests: function(){
		return Promise.mapReduce(this.testFiles, function(testFile){
			return testFile.createTests();
		});
	},

	execTests: function(){
		var start = new Date();

		return Promise.map(this.testFiles, function(testFile){
			return testFile.execTests();
		}, this).then(function(){
			this.state = 'passed';
			this.execDuration = new Date() - start;
			return this;
		}.bind(this)).catch(function(value){
			debug('moduletest rejected', this.path, 'with', value);
			this.state = 'failed';
			return Promise.reject(value);
		}.bind(this));
	},

	test: function(){
		var start = new Date();

		return Promise.reduce([
			this.load, // load the module
			this.findFilePaths, // find the file paths
			this.createFiles, // create the files
			this.loadFiles, // load files content
			this.createTests, // create test from file content
			this.execTests // exec file tests
		], this).then(function(){
			this.duration = new Date() - start;
			return this;
		}.bind(this));
	}
});

require('array/prototype/find');
var FolderTest = proto.extend({
	type: 'folder',
	util: require('module-util'),
	ModuleTest: ModuleTest,
	moduleChangeReaction: null,
	fileChangeReaction: null,
	moduleTests: null,

	constructor: function(path){
		this.path = path;
		this.reset();
	},

	reset: function(){
		this.state = 'created';
		this.moduleTests = [];
		this.findDuration =  0;
		this.loadDuration =  0;
		this.requireDuration = 0;
		this.execDuration = 0;
		this.duration = 0;
	},

	toJSON: function(){
		return {
			state: this.state,
			path: this.path,
			moduleTests: this.moduleTests,
			findDuration: this.findDuration,
			loadDuration: this.loadDuration,
			requireDuration: this.requireDuration,
			execDuration: this.execDuration,
			duration: this.duration
		};
	},

	createModuleTest: function(path){
		return this.ModuleTest.create(path, this.moduleChangeReaction, this.fileChangeReaction);
	},

	findModulePaths: function(){
		var start = new Date();
		var folderPath = this.path;
		return new Promise(function(resolve, reject){
			this.util.collectModulePaths(folderPath, function(error, modulePaths, badPaths){
				/*
				// faudrais faire kkchose avec badPaths
				if( badPaths.length ){
					// test files cannot be considered as bad modules
					badPaths = badPaths.filter(this.Collector.filterFolder, this.Collector);
					//if( badSignaturePaths.length ) this.test.emit('badSignature', badSignaturePaths);
				}
				*/

				if( error ) reject(error);
				else resolve(modulePaths);
			}, this);
		}.bind(this)).then(function(modulePaths){
			this.findDuration = new Date() - start;
			return modulePaths;
		}.bind(this));
	},

	filterTestModules: function(modulePaths){
		return modulePaths.filter(function(modulePath){
			return !ModuleTest.FileCollector.isTestFile(modulePath);
		}, this);
	},

	createModules: function(modulePaths){
		return this.moduleTests = modulePaths.map(this.createModuleTest, this);
	},

	createTests: function(){
		var start = new Date();

		return Promise.mapReduce(this.moduleTests, function(moduleTest){
			return Promise.reduce([
				moduleTest.findFilePaths,
				moduleTest.createFiles,
				moduleTest.loadFiles,
				moduleTest.createTests
			], moduleTest);
		}, this).then(function(){
			this.loadDuration = new Date() - start;
		}.bind(this));
	},

	filterModules: function(){
		return this.moduleTests = this.moduleTests.filter(function(moduleTest){
			return moduleTest.hasTest();
		});
	},

	loadModules: function(){
		var start = new Date();
		return Promise.mapReduce(this.moduleTests, function(moduleTest){
			return moduleTest.load();
		}).then(function(){
			this.requireDuration = new Date() - start;
		}.bind(this));
	},

	sortModules: function(){
		return this.moduleTests = this.moduleTests.sort(function(a, b){
			return this.util.getDependencyLevel(a.module) - this.util.getDependencyLevel(b.module);
		}.bind(this));
	},

	execTests: function(){
		var start = new Date();

		return Promise.map(this.moduleTests, function(moduleTest){
			return moduleTest.execTests();
		}).then(function(){
			this.execDuration = new Date() - start;
		}.bind(this)).catch(function(value){
			debug('foldertest rejected', this.path, 'with', value);
			return Promise.reject(value);
		}.bind(this));
	},

	test: function(){
		var start = new Date();

		return Promise.reduce([
			this.findModulePaths, // find modules
			this.filterTestModules, // exclude test that sounds like modules byt are not
			this.createModules, // create module object
			this.createTests, // create module tests
			this.filterModules, // filter the module without tests
			this.loadModules, // require the module
			this.sortModules, // sort module by dependency
			this.execTests // exec module tests
		], this, this.path).then(function(){
			debug('tests are over');
			this.state = 'passed';
			this.duration = new Date() - start;
			return this;
		}.bind(this)).catch(function(value){
			debug('folder rejected', this.path, 'with', value);
			this.state = 'failed';
			this.duration = new Date() - start;
			return Promise.reject(value);
		}.bind(this));
	}
});

var TestRunner = {
	Test: Test,
	TestFile: TestFile,
	ModuleTest: ModuleTest,
	FolderTest: FolderTest,

	test: function(fn, module){
		return Test.create(fn, module);
	},

	testFile: function(filePath, module){
		return TestFile.create(filePath, module);
	},

	testModule: function(modulePath){
		return ModuleTest.create(modulePath);
	},

	testFolder: function(folderPath){
		return FolderTest.create(folderPath);
	}
};

module.exports = TestRunner;