/*

TODO

- Test, TestFile devrait ptet avoir une méthode .toJSON() qui retourne en gros this.meta

MORE

- maybe add a skip(reason) method a skip the test under some conditions (reason is optionnal)
and a method skipIf(condition, reason)


// a basic test looks like
exports['foo module is named foo'] = function(foo){
	if( foo.name !== 'foo' ) throw new Error('foo name is not foo');	
};

// the second argument will help you to do assertions
exports['2+2 = 4'] = function(foo, test){
	test.equal(foo.name, 'foo');
};

exports['test stuff'] = function(foo, test){
	test.equal('a', 'a');

	var task = test.task(function(){
		require('fs').readFile('test.txt', this.complete);
	}).then(function(value){
		test.equal(value, 'oki');
	});

	test.willResolve(task);

	// short version
	test.willBe(function(){
		require('fs').readFile('test.txt', this.complete);
	}, 'oki');
};

// test basique
exports['test'] = function(){}
// test où on utilise assert
exports['test'] = function(assert){}
// test d'un module
exports['test'] = function(assert, Foo){}

peut être qu'il faut pouvoir inidquer qu'un module fait partie des modules coté client
et donc qu'on ne les teste pas

*/

require('Promise');
var proto = require('proto');

var Assertion = proto.create({
	name: null,
	args: null,
	error: null,
	methods: {
		'ok': function(a){
			return Boolean(a);
		},

		'equal': function(a, b){
			return a == b;
		},

		'strictEqual': function(a, b){
			return a === b;
		},

		'typeOf': function(a, b){
			return typeof a === b;
		},

		'protoOf': function(a, b){
			return Object.getPrototypeOf(a) === b;
		},

		'error': function(a, b){
			try{
				a();
			}
			catch(e){
				if( b ){
					if( typeof b == 'string' ){
						return e.type.toLowerCase() === b.toLowerCase();
					}
					else if( typeof b == 'function' ){
						return e instanceof b;
					}
				}				
				return true;
			}
			return false;
		}
	},

	constructor: function(name, args){
		this.name = name;
		this.args = args;
	},

	createError: function(type, args){
		var error = new Error('failed assertion');
		error.name = 'AssertionError';
		error.type = this.name;
		error.args = this.args;
		return error;
	},

	exec: function(){
		return this.methods[this.name].apply(this, this.args);
	},

	check: function(){
		if( !this.exec() ){
			this.error = this.createError();
			return false;
		}
		return true;
	},

	checkThrow: function(){
		if( !this.check() ) throw this.error;
	}
});

/*
new Test(fn, description, String | Object | Module)

String -> new ModuleTest(string)
Object -> new ModuleTest(object)
Module -> module
-> TypeError
*/

var Test = proto.create({
	timeout: 100,
	type: 'test',
	fn: null,
	moduleTest: null,
	description: 'no desc',
	assertions: [],
	pendingCount: 0,
	meta: null,

	constructor: function(fn, moduleTest, description){
		moduleTest = new ModuleTest(moduleTest);
		this.fn = fn;		
		this.moduleTest = moduleTest;
		this.description = String(description);
		this.reset();
	},

	reset: function(){
		this.meta = {};	
		this.meta.description = this.description;
		this.assertions = this.constructor.prototype.assertions;	
	},

	assert: function(type, args){
		var assertion = new Assertion(type, args);
		this.assertions.push(assertion);

		if( !assertion.check() ){
			var stackTrace = require('stackTrace');
			var error = assertion.error;
			var stack = stackTrace.get(error, this.assert);

			error.file = stack[1].getFileName();
			error.line = stack[1].getLineNumber();

			throw error;
		}	
	},	

	promise: function(executor){
		var promise;

		if( typeof executor == 'function' ){
			promise = new promise(executor);
		}
		else{
			promise = executor;
		}

		return promise;
	},

	willResolve: function(promise){
		promise = this.promise(promise);

		this.pendingCount++;

		promise.then(
			function(value){
				this.pendingCount--;
				if( this.pendingCount === 0 ){
					this.resolve();
				}
			}.bind(this),
			function(value){
				this.pendingCount--;
				if( this.pendingCount === 0 ){
					this.reject(value);
				}
			}.bind(this)
		);
	},

	willReject: function(promise){
		promise = this.promise(promise);

		promise = promise.then(
			function(){
				throw new Error('resolved assertion should have failed');
			},
			function(){
				return true;
			}
		);

		return this.willResolve(promise);
	},

	willBe: function(promise, expected){
		promise = this.promise(promise);

		promise = promise.then(
			function(value){			
				var assertion = new Assertion('equal', [expected, value]);
				assertion.checkThrow();
				return value;
			}
		);

		return this.willResolve(promise);
	},

	loadModule: function(){
		return this.moduleTest.load();
	},

	createTimeoutError: function(){
		var error = new Error(this + ' test is too slow');
		error.code = 'TEST_TIMEOUT';
		return error;
	},

	exec: function(){
		var start = new Date();

		return new Promise(function(resolve, reject){
			this.resolve = resolve;
			this.reject = reject;
			this.assertions = [];
			this.pendingCount = 0;
			this.imports = this.moduleTest.module.exports;
			this.fn.call(this, this, this.imports);
			
			if( this.pendingCount === 0 ){
				resolve();
			}
			else{
				setTimeout(function(){
					reject(this.createTimeoutError());
				}.bind(this), 100);
			}
		}.bind(this)).then(function(){
			this.meta.assertionCount = this.assertions.length;
			this.meta.duration = new Date() - start;
			return this.meta;
		}.bind(this));
	},

	// loadModule + loadAssertion + execAssertions
	test: function(){
		return Promise.reduce([
			this.loadModule,
			this.exec
		], this);
	},

	toString: function(){
		return '[object Test ' + this.description + ']';
	}
});

Object.keys(Assertion.prototype.methods).forEach(function(key){
	Test.prototype[key] = function(){
		return this.assert(key, arguments);
	};
});


/*
new FileTest(path, undefined | String | Object | Module)

undefined -> convertit en un possible module en utilisant path de fileTest
String -> new ModuleTest(string)
Object -> new ModuleTest(object)
Module -> module
*/

var TestFile = proto.create({
	type: 'file',
	FileObserver: require('FileObserver'),
	path: null,
	moduleTest: null,
	tests: [],
	meta: null,

	constructor: function(path, moduleTest, changeReaction){
		if( !moduleTest ){
			moduleTest = FolderTest.prototype.FileCollector.getModuleFromTestFile(moduleTest);
		}
		moduleTest = new ModuleTest(moduleTest);
		this.path = path;
		this.moduleTest = moduleTest; // trouve module grâce à filePath
		this.reset();

		changeReaction = changeReaction || moduleTest.fileChangeReaction;

		if( changeReaction ){
			this.observe(function(){
				changeReaction(this);
			}, this);
		}	
	},

	reset: function(){
		this.meta = {};
		this.meta.path = this.path;
		this.tests = this.constructor.prototype.tests;
	},

	observe: function(fn, bind){
		this.FileObserver.prototype.observe(this.path, fn, bind);
	},

	createTest: function(testFn, description){
		return new Test(testFn, this.moduleTest, description);
	},

	load: function(){
		return new Promise(function(resolve, reject){
			this.exports = require(this.path);
			resolve(this.exports);
		}.bind(this));
	},

	createTests: function(){
		return this.tests = Object.keys(this.exports).map(function(key){
			return this.createTest(this.exports[key], key);
		}, this);
	},

	loadModule: function(){
		return this.moduleTest.load();
	},

	execTests: function(){
		var start = new Date();

		return Promise.map(this.tests, function(test){
			return test.exec();
		}).then(function(testMetas){
			this.meta.testMetas = testMetas;
			this.meta.execDuration = new Date() - start;
			return this.meta;
		}.bind(this));
	},

	test: function(){
		var start = new Date();

		return Promise.reduce([
			this.load, // load file content
			this.createTests, // create tests from file content
			this.loadModule, // load the module
			this.execTests, // exec test in the file
		], this).then(function(){
			this.meta.duration = new Date() - start;
			return this.meta;
		});
	}
});

/*
new ModuleTest(path)

dans meta mettre perfData qui retourne duration etc
*/
var ModuleTest = proto.create({
	type: 'module',
	TestFile: TestFile,
	FileObserver: require('FileObserver'),
	FileCollector: require('../TestFileCollector'),
	util: require('module-util'),
	path: null,
	module: null,
	testFiles: [],
	meta: null,

	constructor: function(path, changeReaction, fileChangeReaction){
		if( path instanceof ModuleTest ) return path;
		if( typeof path === 'object' ){
			this.module = {
				exports: path,
				dependencyLevel: 0,
				parent: null,
				children: []
			};
			this.load = function(){
				return this.module;
			};
		}

		this.path = path;
		this.reset();

		if( changeReaction ){
			this.observe(function(){
				changeReaction(this);
			}, this);
		}
		if( fileChangeReaction ){
			this.fileChangeReaction = fileChangeReaction;
		}
	},

	reset: function(){
		this.meta = {};
		this.meta.path = this.path;
		this.testFiles = this.constructor.prototype.testFiles;
	},

	hasTest: function(){
		return this.testFiles.some(function(testFile){
			return testFile.tests.length !== 0;
		});
	},

	observe: function(fn, bind){
		// test.path lead to the module main file (index.js), dependencies are ignored
		// to be exaustive we should detect dependencies changes too
		this.FileObserver.prototype.observe(this.path, fn, bind);
	},
	fileChangeReaction: function(testFile){},

	load: function(){
		var start = new Date();
		return new Promise(function(resolve){
			this.module = this.util.requireModule(this.path);
			resolve(this.module);
		}.bind(this)).then(function(module){
			this.meta.requireDuration = new Date() - start;
			return module;
		}.bind(this));
	},

	findFilePaths: function(){
		var start = new Date();
		return new Promise(function(resolve, reject){
			this.FileCollector.collect(this.path, function(error, filePaths){
				if( error ) reject(error);
				else resolve(filePaths);
			}, this);
		}.bind(this)).then(function(filePaths){
			this.meta.findDuration = new Date() - start;
			return filePaths;
		}.bind(this));
	},

	createFiles: function(filePaths){
		return this.testFiles = filePaths.map(function(filePath){
			return new this.TestFile(filePath, this, this.fileChangeReaction);
		}, this);
	},

	loadFiles: function(){
		var start = new Date();

		return Promise.mapReduce(this.testFiles, function(testFile){
			return testFile.load();
		}).then(function(){
			this.meta.loadDuration = new Date() - start;
		}.bind(this));
	},

	createTests: function(){
		return Promise.mapReduce(this.testFiles, function(testFile){			
			return testFile.createTests();
		});
	},

	execTests: function(){
		var start = new Date();

		return Promise.map(this.testFiles, function(testFile){
			return testFile.execTests();
		}, this).then(function(fileMetas){
			this.meta.fileMetas = fileMetas;
			this.meta.execDuration = new Date() - start;
			return this.meta;
		}.bind(this));
	},

	test: function(){
		var start = new Date();

		return Promise.reduce([
			this.load, // load the module
			this.findFilePaths, // find the file paths
			this.createFiles, // create the files
			this.loadFiles, // load files content
			this.createTests, // create test from file content
			this.execTests // exec file tests
		], this).then(function(){
			this.meta.duration = new Date() - start;
			return this.meta;
		}.bind(this));
	}
});

var FolderTest = proto.create({
	type: 'folder',
	util: require('module-util'),
	ModuleTest: ModuleTest,
	moduleChangeReaction: null,
	fileChangeReaction: null,
	moduleTests: [],
	meta: null,

	constructor: function(path){
		this.path = path;
		this.reset();
	},

	createModuleTest: function(path){
		return new this.ModuleTest(path, this.moduleChangeReaction, this.fileChangeReaction);
	},

	findModulePaths: function(){
		var start = new Date();
		var folderPath = this.path;
		return new Promise(function(resolve, reject){
			// il faut retourner une liste de path déjà ordonnée
			this.util.collectModulePaths(folderPath, function(error, modulePaths, badPaths){
				/*
				// faudrais faire kkchose avec badPaths
				if( badPaths.length ){
					// test files cannot be considered as bad modules
					badPaths = badPaths.filter(this.Collector.filterFolder, this.Collector);
					//if( badSignaturePaths.length ) this.test.emit('badSignature', badSignaturePaths);
				}
				*/

				if( error ) reject(error);
				else resolve(modulePaths);
			}, this);
		}.bind(this)).then(function(modulePaths){
			this.meta.findDuration = new Date() - start;
			return modulePaths;
		}.bind(this));
	},

	filterTestModules: function(modulePaths){
		return modulePaths.filter(function(modulePath){
			return !ModuleTest.prototype.FileCollector.isTestFile(modulePath);
		}, this);
	},

	createModules: function(modulePaths){
		return this.moduleTests = modulePaths.map(this.createModuleTest, this);
	},

	createTests: function(){
		var start = new Date();

		return Promise.mapReduce(this.moduleTests, function(moduleTest){
			return Promise.reduce([
				moduleTest.findFilePaths,
				moduleTest.createFiles,
				moduleTest.loadFiles,
				moduleTest.createTests
			], moduleTest);
		}, this).then(function(){
			this.meta.loadDuration = new Date() - start;
		}.bind(this));
	},

	filterModules: function(){
		return this.moduleTests = this.moduleTests.filter(function(moduleTest){
			return moduleTest.hasTest();
		});
	},

	loadModules: function(){
		var start = new Date();
		return Promise.mapReduce(this.moduleTests, function(moduleTest){
			return moduleTest.load();
		}).then(function(){
			this.meta.requireDuration = new Date() - start;
		}.bind(this));
	},

	sortModules: function(){
		return this.moduleTests = this.moduleTests.sort(function(a, b){
			return a.module.dependencyLevel, b.module.dependencyLevel;
		});
	},

	execTests: function(){
		var start = new Date();

		return Promise.map(this.moduleTests, function(moduleTest){
			return moduleTest.execTests();
		}).then(function(moduleMetas){
			this.meta.execDuration = new Date() - start;
			this.meta.moduleMetas = moduleMetas;
		}.bind(this));
	},

	reset: function(){
		this.meta = {};	
		this.meta.path = this.path;
		this.moduleTests = this.constructor.prototype.moduleTests;
	},

	test: function(){
		var start = new Date();

		return Promise.reduce([
			this.findModulePaths, // find modules
			this.filterTestModules,
			this.createModules, // create module object
			this.createTests, // create module tests
			this.filterModules, // filter the module without tests
			this.loadModules, // require the module
			this.sortModules, // sort module by dependency
			this.execTests // exec module tests
		], this, this.path).then(function(){
			this.meta.duration = new Date() - start;
			return this.meta;
		}.bind(this));
	}
});

var TestRunner = {
	Test: Test,
	TestFile: TestFile,
	ModuleTest: ModuleTest,
	FolderTest: FolderTest,

	test: function(fn, module){
		return new Test(fn, module);
	},

	testFile: function(filePath, module){		
		return new TestFile(filePath, module);
	},

	testModule: function(modulePath){
		return new ModuleTest(modulePath);
	},

	testFolder: function(folderPath){
		return new FolderTest(folderPath);
	}
};

module.exports = TestRunner;