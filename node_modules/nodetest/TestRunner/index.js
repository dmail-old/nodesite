/*

maybe add a skip(reason) method a skip the test under some conditions (reason is optionnal)
and a method skipIf(condition, reason)

reste à redémarrer loadtask lorsque modifié pendant qu'il s'éxécute (narriveras jamais en pratique)
à capter les fichiers/modules ayant été changé et dans ce cas interrupt les tests en cours, ou pas plutot mettre ça
quelque part pour que lorsque les tests sont terminé on regardé si y'a des choses à relancer
si aucun test en cours on relance juste ce qui a été changé, juste un fileTest ou juste un moduleTest

// a basic test looks like
exports['foo module is named foo'] = function(foo){
	if( foo.name !== 'foo' ) throw new Error('foo name is not foo');	
};

// the second argument will help you to do assertions
exports['2+2 = 4'] = function(foo, test){
	test.equal(foo.name, 'foo');
};

exports['test stuff'] = function(foo, test){
	test.equal('a', 'a');

	var task = test.task(function(){
		require('fs').readFile('test.txt', this.complete);
	}).then(function(value){
		test.equal(value, 'oki');
	});

	test.willResolve(task);

	// short version
	test.willBe(function(){
		require('fs').readFile('test.txt', this.complete);
	}, 'oki');
};

// test basique
exports['test'] = function(){}
// test où on utilise assert
exports['test'] = function(assert){}
// test d'un module
exports['test'] = function(assert, Foo){}

peut être qu'il faut pouvoir inidquer qu'un module fait partie des modules coté client
et donc qu'on ne les teste pas

*/

var Task = require('Task');
var proto = require('proto');

var Assertion = proto.create({
	name: null,
	args: null,
	error: null,
	methods: {
		'ok': function(a){
			return Boolean(a);
		},

		'equal': function(a, b){
			return a == b;
		},

		'strictEqual': function(a, b){
			return a === b;
		},

		'typeOf': function(a, b){
			return typeof a === b;
		},

		'protoOf': function(a, b){
			return Object.getPrototypeOf(a) === b;
		},

		'error': function(a, b){
			try{
				a();
			}
			catch(e){
				if( b ){
					if( typeof b == 'string' ){
						return e.type.toLowerCase() === b.toLowerCase();
					}
					else if( typeof b == 'function' ){
						return e instanceof b;
					}
				}				
				return true;
			}
			return false;
		}
	},

	constructor: function(name, args){
		this.name = name;
		this.args = args;
	},

	createError: function(type, args){
		var error = new Error('failed assertion');
		error.name = 'AssertionError';
		error.type = this.name;
		error.args = this.args;
		return error;
	},

	exec: function(){
		return this.methods[this.name].apply(this, this.args);
	},

	check: function(){
		if( !this.exec() ){
			this.error = this.createError();
			return false;
		}
		return true;
	},

	checkThrow: function(){
		if( !this.check() ) throw this.error;
	}
});

/*
new Test(fn, description, String | Object | Module)

String -> new ModuleTest(string)
Object -> new ModuleTest(object)
Module -> module
-> TypeError
*/

var Test = proto.create({
	timeout: 100,
	type: 'test',
	fn: null,
	moduleTest: null,
	description: 'no desc',
	assertions: [],
	pendingCount: 0,
	meta: null,

	constructor: function(fn, moduleTest, description){
		moduleTest = new ModuleTest(moduleTest);
		this.fn = fn;		
		this.moduleTest = moduleTest;
		this.description = String(description);
		this.meta = {};
	},

	assert: function(type, args){
		var assertion = new Assertion(type, args);
		this.assertions.push(assertion);

		if( !assertion.check() ){
			var stackTrace = require('stackTrace');
			var error = assertion.error;
			var stack = stackTrace.get(error, this.assert);

			error.file = stack[1].getFileName();
			error.line = stack[1].getLineNumber();

			throw error;
		}	
	},	

	task: function(executor){
		var task;

		if( typeof executor == 'function' ){
			task = new Task(executor);
		}
		else{
			task = executor;
		}

		return task;
	},

	willResolve: function(task){
		task = this.task(task);

		this.pendingCount++;

		task.then(
			function(value){
				this.pendingCount--;
				if( this.pendingCount === 0 ){
					this.resolve(value);
				}
			}.bind(this),
			function(value){
				this.pendingCount--;
				if( this.pendingCount === 0 ){
					this.reject(value);
				}
			}.bind(this)
		);
	},

	willReject: function(task){
		task = this.task(task);

		task = task.then(
			function(){
				throw new Error('resolved assertion should have failed');
			},
			function(){
				return true;
			}
		);

		return this.willResolve(task);
	},

	willBe: function(task, expected){
		task = this.task(task);

		task = task.then(function(value){
			var assertion = new Assertion('equal', [expected, value]);
			return assertion.checkThrow();
		});

		return this.willResolve(task);
	},

	loadModule: function(){
		return this.moduleTest.load();
	},

	exec: function(){
		var self = this;

		return new Task(function(resolve, reject){
			this.resolve = resolve;
			this.reject = reject;
			this.assertions = [];
			this.pendingCount = 0;
			this.imports = this.moduleTest.module.exports;
			this.fn.call(this, this, this.imports);
			if( this.pendingCount === 0 ) resolve();
		}, this).then(function(){
			self.meta.assertionCount = self.assertions.length;
			return self.meta;
		});
	},

	// loadModule + loadAssertion + execAssertions
	test: function(){
		return Task.reduce([
			this.loadModule,
			this.exec
		], this);
	},

	toString: function(){
		return '[object Test ' + this.description + ']';
	}
});

Object.keys(Assertion.prototype.methods).forEach(function(key){
	Test.prototype[key] = function(){
		return this.assert(key, arguments);
	};
});


/*
new FileTest(path, undefined | String | Object | Module)

undefined -> convertit en un possible module en utilisant path de fileTest
String -> new ModuleTest(string)
Object -> new ModuleTest(object)
Module -> module
*/

var TestFile = proto.create({
	FileObserver: require('FileObserver'),
	path: null,
	moduleTest: null,
	tests: [],
	meta: null,

	constructor: function(path, moduleTest, changeReaction){
		if( !moduleTest ){
			moduleTest = FolderTest.prototype.FileCollector.getModuleFromTestFile(moduleTest);
		}
		moduleTest = new ModuleTest(moduleTest);
		this.path = path;
		this.moduleTest = moduleTest; // trouve module grâce à filePath
		this.meta = {};

		if( changeReaction ){
			this.observe(function(){
				changeReaction.call(this);
			}, this);
		}	
	},

	observe: function(fn, bind){
		this.FileObserver.prototype.observe(this.path, fn, bind);
	},

	createTest: function(testFn, description){
		return new Test(testFn, this.moduleTest, description);
	},

	load: function(){
		return new Task(function(resolve, reject){
			this.exports = require(this.path);
			resolve(this.exports);
		}, this);
	},

	createTests: function(){
		return this.tests = Object.keys(this.exports).map(function(key){
			return this.createTest(this.exports[key], key);
		}, this);
	},

	loadModule: function(){
		return this.moduleTest.load();
	},

	execTests: function(){
		var start = new Date();

		return Task.map(this.tests, function(test){
			return test.exec();
		}).then(function(testMetas){
			this.meta.testMetas = testMetas;
			this.meta.execDuration = new Date() - start;
			return this.meta;
		}.bind(this));
	},

	test: function(){
		var start = new Date();

		return Task.reduce([
			this.load, // load file content
			this.createTests, // create tests from file content
			this.loadModule, // load the module
			this.execTests, // exec test in the file
		], this).then(function(){
			this.meta.duration = new Date() - start;
			return this.meta;
		});
	}
});

/*
new ModuleTest(path)
*/
var ModuleTest = proto.create({
	TestFile: TestFile,
	FileObserver: require('FileObserver'),
	FileCollector: require('../TestFileCollector'),
	util: require('module-util'),
	path: null,
	module: null,
	testFiles: [],
	meta: null,

	constructor: function(path, changeReaction, fileChangeReaction){
		if( path instanceof ModuleTest ) return path;
		if( typeof path === 'object' ){
			this.module = {
				exports: path,
				dependencyLevel: 0,
				parent: null,
				children: []
			};
			this.load = function(){
				return this.module;
			};
		}

		this.path = path;
		this.meta = {};

		if( changeReaction ){
			this.observe(function(){
				changeReaction(this);
			}, this);
		}
		if( fileChangeReaction ){
			this.fileChangeReaction = fileChangeReaction;
		}
	},

	hasTest: function(){
		return this.testFiles.some(function(testFile){
			return testFile.tests.length !== 0;
		});
	},

	observe: function(fn, bind){
		// test.path lead to the module main file (index.js), dependencies are ignored
		// to be exaustive we should detect dependencies changes too
		this.FileObserver.prototype.observe(this.path, fn, bind);
	},
	fileChangeReaction: function(testFile){},

	load: function(){
		return new Task(function(resolve){
			this.module = this.util.requireModule(this.path);
			resolve(this.module);
		}, this);
	},

	findFilePaths: function(){
		return new Task(function(resolve, reject){
			this.FileCollector.collect(this.path, function(error, filePaths){
				if( error ) reject(error);
				else resolve(filePaths);
			}, this);
		}, this);
	},

	createFiles: function(filePaths){
		return this.testFiles = filePaths.map(function(filePath){
			return new this.TestFile(filePath, this);
		}, this);
	},

	loadFiles: function(){
		var start = new Date();

		return Task.mapReduce(this.testFiles, function(testFile){
			return testFile.load();
		}).then(function(){
			this.meta.loadDuration = new Date() - start;
		}.bind(this));
	},

	createTests: function(){
		return Task.mapReduce(this.testFiles, function(testFile){			
			return testFile.createTests();
		});
	},

	execTests: function(){
		var start = new Date();

		return Task.map(this.testFiles, function(testFile){
			return testFile.execTests();
		}, this).then(function(fileMetas){
			this.meta.fileMetas = fileMetas;
			this.meta.execDuration = new Date() - start;
			return this.meta;
		}.bind(this));
	},

	test: function(){
		var start = new Date();

		return Task.reduce([
			this.load, // load the module
			this.findFilePaths, // find the file paths
			this.createFiles, // create the files
			this.loadFiles, // load files content
			this.createTests, // create test from file content
			this.execTests // exec file tests
		], this).then(function(){
			this.meta.duration = new Date() - start;
			return this.meta;
		}.bind(this));
	}
});

var FolderTest = proto.create({
	util: require('module-util'),
	ModuleTest: ModuleTest,
	watch: false,
	moduleChangeReaction: null,
	fileChangeReaction: null,
	moduleTests: [],
	meta: null,

	constructor: function(path, options){
		this.path = path;
		this.meta = {};
	},

	createModuleTest: function(path){
		return new this.ModuleTest(path, this.moduleChangeReaction, this.fileChangeReaction);
	},

	findModulePaths: function(folderPath){
		return new Task(function(resolve, reject){
			// il faut retourner une liste de path déjà ordonnée
			this.util.collectModulePaths(folderPath, function(error, modulePaths, badPaths){
				/*
				// faudrais faire kkchose avec badPaths
				if( badPaths.length ){
					// test files cannot be considered as bad modules
					badPaths = badPaths.filter(this.Collector.filterFolder, this.Collector);
					//if( badSignaturePaths.length ) this.test.emit('badSignature', badSignaturePaths);
				}
				*/

				if( error ) reject(error);
				else resolve(modulePaths);
			}, this);
		}, this);
	},

	createModules: function(modulePaths){
		return this.moduleTests = modulePaths.map(this.createModuleTest, this);
	},

	createTests: function(){
		return Task.mapReduce(this.moduleTests, function(moduleTest){
			return Task.reduce([
				moduleTest.findFilePaths,
				moduleTest.createFiles,
				moduleTest.loadFiles,
				moduleTest.createTests
			], moduleTest);
		}, this);
	},

	filterModules: function(){
		return this.moduleTests = this.moduleTests.filter(function(moduleTest){
			return moduleTest.hasTest();
		});
	},

	loadModules: function(){
		var start = new Date();
		return Task.mapReduce(this.moduleTests, function(moduleTest){
			return moduleTest.load();
		}).then(function(){
			this.meta.loadDuration = new Date() - start;
		}.bind(this));
	},

	sortModules: function(){
		return this.moduleTests = this.moduleTests.sort(function(a, b){
			return a.module.dependencyLevel, b.module.dependencyLevel;
		});
	},

	execTests: function(){
		var start = new Date();

		return Task.map(this.moduleTests, function(moduleTest){
			return moduleTest.execTests();
		}).then(function(moduleMetas){
			this.meta.execDuration = new Date() - start;
			this.meta.moduleMetas = moduleMetas;
		}.bind(this));
	},

	test: function(){
		var start = new Date();

		return Task.reduce([
			this.findModulePaths, // find modules
			this.createModules, // create module object
			this.createTests, // create module tests
			this.filterModules, // filter the module without tests
			this.loadModules, // require the module
			this.sortModules, // sort module by dependency
			this.execTests // exec module tests
		], this, this.path).then(function(){
			this.meta.duration = new Date() - start;
			return this.meta;
		}.bind(this));
	}
});

var TestRunner = {
	test: function(fn, module){
		var test = new Test(fn, module);
		var task = test.test();
		return task;
	},

	testFile: function(filePath, module, options){		
		var testFile = new TestFile(filePath, module);
		var task = testFile.test();
		return task;
	},

	testModule: function(modulePath, options){
		var moduleTest = new ModuleTest(modulePath);
		var task = moduleTest.test();
		return task;
	},

	testFolder: function(folderPath, options){
		var folderTest = new FolderTest(folderPath);
		var task = folderTest.test();
		return task;
	}
};

module.exports = TestRunner;