/*

Ce que je veux c'est :

lancer un processus qui consiste à collecter, observer, charger, éxécuter des fichiers

à tout moment je veux pouvoir mettre ce process en pause
puis reprendre ce process où il en était (et même être capable de revenir en arrière)

pour l'utilisation que j'en ai ici :
- besoin de pouvoir recharger un fichier lorsqu'il est modifié pendant la phase "charger"
	déjà chargé -> à recharger
	pas encore chargé -> NOOP
	en cours de chargement -> ignorer le résultat et recharger
- besoin de pouvoir réexecuter un fichier lorsqu'il est modifié pendant la phase "éxécuter"
	déjà éxécuté -> à relancer
	pas encore éxecuté -> NOOP
	en cours d'éxécution -> ignorer le résultat et éxécuter à nouveau
- besoin de pouvoir recharger/rééxecuter un fichier (ou un groupe) lorsqu'il est modifié après la phase "exécuter"
- pas besoin de mettre en pause la phase "collecter"
- besoin de mettre en pause la phase "charger" en cas d'erreur
- besoin de mettre en pause la phase "éxécuter" en cas d'erreur

*/
var Task = require('Task');
var proto = require('proto');

var TestPrototype = require('../TestPrototype');
var TestSerie = proto.create({
	name: 'Anonymous testSerie',
	Test: require('../Test'),
	type: 'serie',
	tests: null,

	constructor: function(tests){
		this.tests = tests || [];
	},	

	get count(){
		var i = 0, j = this.tests.length, count = 0, test;

		for(;i<j;i++){
			test = this.tests[i];
			if( TestSerie.isPrototypeOf(test) ){
				count+= test.count;
			}
			else{
				count++;
			}
		}

		return count;
	},

	get length(){
		return this.tests.length;
	},

	createTest: function(){
		var test;

		if( this.Test.isPrototypeOf(arguments[0]) ) {
			test = arguments[0];
		}
		else{
			test = this.Test.new.apply(this.Test, arguments);
		}

		test.parent = this;

		return test;
	},

	createChild: function(){
		return this.createTest.apply(this, arguments);
	},

	add: function(){
		var test = this.createTest.apply(this, arguments);
		this.tests.push(test);
		return this;
	}
});

module.exports = TestSerie;

var Test = require('Test');

var FileTest = proto.extend(TestSerie, {
	Test: Test,
	path: null,
	type: 'file',

	constructor: function(){
		this.path = path;
		TestSerie.call(this);
	},

	get module(){
		return this.parent ? this.parent.module : null;
	},

	load: function(fn, bind){
		var error, exports;

		try{
			exports = require(this.path);

			this.tests = Object.keys(exports).map(function(key){
				return this.createChild(key, exports[key]);
			}, this);
		}
		catch(e){
			error = e;
		}

		fn.call(bind, error);
	}
});

var ModuleTest = proto.extend(TestSerie, {
	FileCollector: require('./FileTestCollector'),
	Test: FileTest,
	type: 'module',
	path: null,
	module: null,

	constructor: function(path){
		this.path = path;
		TestSerie.call(this);
	},

	collect: function(fn, bind){
		this.FileCollector.collect(this.path, function(error, paths){
			if( !error ){
				this.tests = paths.map(function(path){
					return this.createChild(path);
				});
			}

			fn.call(bind, error);
		}, this);
	},

	load: function(fn, bind){
		var error, module;

		try{
			module = this.util.requireModule(this.path);
			this.module = module;
		}
		catch(e){
			error = e;
		}

		fn.call(bind, error);
	}
});

var ModuleCollector = proto.create({
	util: require('module-util'),
	startDate: null,
	endDate: null,

	collect: function(path, fn, bind){
		this.startDate = new Date();
		this.util.collectModulePaths(path, function(error, modulePaths, badPaths){
			this.endDate = new Date();
			this.error = error;
			this.result = modulePaths;

			/*
			// faudrais faire kkchose avec badPaths
			if( badPaths.length ){
				// test files cannot be considered as bad modules
				badPaths = badPaths.filter(this.Collector.filterFolder, this.Collector);
				//if( badSignaturePaths.length ) this.test.emit('badSignature', badSignaturePaths);
			}
			*/

			fn.call(bind, error, modulePaths, this.startDate - this.endDate, this);
		}, this);
	}	
});

var TestRunnerTask = proto.extend(Task, {
	constructor: function(runner, name, test){
		this.runner = runner;
		this.name = name;
		this.test = test;

		Task.call(this, this.fn, this);
	},

	fn: function(){
		this.test[this.name](this.handle, this);
	},

	start: function(){
		this.runner.currentTask = this;
		Task.prototype.start.call(this);
	}
});

var TestRunner = proto.create({
	FileObserver: require('FileObserver'),

	phase: null, // null, 'collect', 'load', 'setup', 'run'
	state: 'created', // 'created', 'collecting', 'preparing', 'loading', 'running', 'ended'
	test: null,
	collector: null,

	onerror: function(){},
	oncollect: function(){},
	onmodulechange: function(){},
	onfilechange: function(){},
	onloadprogress: function(){},
	onload: function(){},
	ontestprogress: function(){},
	onend: function(){},

	collectError: function(e){
		this.onerror(e);
	},

	loadError: function(e){
		this.onerror(e);
	},

	loadProgress: function(e){
		this.onloadprogress(e);
	},

	/*
	load: function(){
		this.onload(new Date() - this.loadStartDate);
		this.start(this.test);
	},
	*/

	createTask: function(name, test){
		return new TestRunnerTask(this, name, test);
	},

	createTaskList: function(array, name){
		return array.map(function(item){
			return this.createTask(name, item);
		}, this);
	},

	waitUntilTaskIsRestarted: function(taskA, taskB){
		// pause the task
		taskA.abort();
		taskB.then(taskA.start.bind(taskA));
		taskB.restart();
	},

	waitUntilReload: function(task, test){
		this.pauseUntilTaskIsCompleted(task, test.loadTask);
	},

	moduleChanged: function(module){
		/*
		TODO: on va indiquer les tâche en cours sur les tests
		
		module.collectTask (inutilisé)
		module.loadTask (restart() lorsque modifié)
		module.loadFileTask (inutilisé)
		module.runTask (restart() lorsque reloaded)
		
		file.loadTask (restart() lorsque modifié )
		file.runTask (restart() lorsque reloaded )

		test.runTask (inutilisé)
		*/


		if( module.loadTask && module.loadTask.isFailed() ){
			module.loadTask.restart();
			// it will reload the module, and resume parent tasks		
		}
		else if( module.loadTask && module.loadTask.isPending() ){
			module.loadTask.restart();
		}
		else if( module.runTask && module.runTask.isPending() ){
			this.waitUntilReload(module.runTask, module);
		}
		else if( this.currentTask && this.currentTask.isPending() ){
			this.waitUntilReload(this.currentTask, module);
		}
		else{
			// delete cache
			delete require.cache[module.path];
			// create a load task and a run task
			var task = Task.serie([this.createTask(module, 'load'), this.createTask(module, 'run')]);				
			// make it the current task
			task.then(this.onmodulererun.bind(this, module), this.onerror);
			task.start();
		}
	},

	fileChanged: function(file){
		var task = this.currentTask;

		// file changed while a file is being loaded
		if( task.name === 'load' && task.test instanceof FileTest ){
			// we are loading the changed file, restart
			if( task.test === file ){
				task.restart();
			}
			// we are loading a file after this one in the same module
			else if( task.test.parent === file.parent && file.tests.indexOf(task.test) > file.tests.indexOf(file) ){
				this.pauseUntilReload(task, file);
			}
			// we are loading a file in a module after this file module (meaning it need reload)
			else if( this.modules.indexOf(task.test.parent) > this.modules.indexOf(file.parent) ){
				this.pauseUntilReload(task, file);
			}
		}
		// file changed while an other task is running
		else if( task.isPending() ){
			this.pauseUntilReload(task, file);
		}
		else{
			// delete cache
			delete require.cache[file.path];
			// create a new load task followed by a run task
			task = Task.serie([this.createLoadTask(file), new Task(file.run, file)]);
			this.task = task;
			task.then(this.onfilererun.bind(this, file), this.onerror);
		}
	},

	observeModules: function(){
		this.modules = this.modules.filter(function(module){
			return module.tests.length === 0;
		}, this);

		this.modules.forEach(function(module){
			// test.path lead to the module main file (index.js), dependencies are ignored
			// to be exaustive we should detect dependencies changes too
			this.FileObserver.prototype.observe(module.path, function(){
				this.moduleChanged(module);
			}, this);
		}, this);
	},

	observeFiles: function(){
		this.modules.forEach(function(module){
			module.tests.forEach(function(file){
				this.FileObserver.prototype.observe(file.path, function(){
					this.fileChanged(file);
				}, this);
			}, this);
		}, this);		
	},
	
	collectModuleFile: function(module){
		return this.createTask('collect', module);
	},

	collectFiles: function(){
		return Task.serie(this.modules.map(this.collectModuleFile, this)).then(this.observeModules.bind(this));
	},

	loadModule: function(module){
		var task = this.createTask('load', module);
		task.reset = function(){
			delete require.cache[this.test.path];
		};
		return task;
	},

	loadModules: function(){
		return Task.serie(this.modules.map(this.loadModule, this)).then(this.observeFiles.bind(this));
	},

	loadModuleFile: function(file){
		var task = this.createTask('load', file);
		task.reset = function(){
			delete require.cache[this.test.path];
		};
		return task;
	},

	loadModuleFiles: function(module){
		return Task.serie(module.tests.map(this.loadModuleFile, this));
	},
	
	loadFiles: function(){
		return Task.serie(this.modules.map(this.loadModuleFiles, this));
	},

	runTest: function(test){
		return test; // test is already a task
	},

	runTestSerie: function(serie){
		return Task.serie(serie.tests.map(this.runTest, this));
	},

	runFileTests: function(file){
		return Task.serie(file.tests.map(this.runTestSerie, this));
	},

	runModuleTests: function(module){
		return Task.serie(module.tests.map(this.runFileTests, this));
	},

	runTests: function(){
		return Task.serie(this.modules.map(this.runModuleTests, this));
	},

	run: function(path){
		this.path = path;
		this.collector = ModuleCollector.new();
		this.state = 'collecting';

		this.collector.collect(path, function(error, paths, duration){
			if( error ) return this.collectError(error);

			this.oncollect(duration);

			this.modules = paths.map(function(path){
				return ModuleTest.new(path);
			});

			var iterable = {
				runner: this,
				phases: ['collectFiles', 'loadModules', 'loadFiles', 'runTests'],
				index: 0,

				next: function(){
					if( this.index >= this.phases.length ){
						return {done: true, value: undefined};
					}
					this.index++;
					return {done: false, value: this.runner[this.phases[this.index]]()};
				},

				'@@iterator': function(){
					return this;
				}
			};

			this.task = Task.serie(iterable);
			this.task.then(this.end.bind(this), this.error.bind(this));
			this.task.run();
		}, this);
	}
});