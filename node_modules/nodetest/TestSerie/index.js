/*

Ce que je veux c'est :

lancer un processus qui consiste à collecter, observer, charger, éxécuter des fichiers

à tout moment je veux pouvoir mettre ce process en pause
puis reprendre ce process où il en était (et même être capable de revenir en arrière)

pour l'utilisation que j'en ai ici :
- besoin de pouvoir recharger un fichier lorsqu'il est modifié pendant la phase "charger"
	déjà chargé -> à recharger
	pas encore chargé -> NOOP
	en cours de chargement -> ignorer le résultat et recharger
- besoin de pouvoir réexecuter un fichier lorsqu'il est modifié pendant la phase "éxécuter"
	déjà éxécuté -> à relancer
	pas encore éxecuté -> NOOP
	en cours d'éxécution -> ignorer le résultat et éxécuter à nouveau
- besoin de pouvoir recharger/rééxecuter un fichier (ou un groupe) lorsqu'il est modifié après la phase "exécuter"
- pas besoin de mettre en pause la phase "collecter"
- besoin de mettre en pause la phase "charger" en cas d'erreur
- besoin de mettre en pause la phase "éxécuter" en cas d'erreur

*/

var Executor = proto.create({
	done: false,

	constructor: function(task, fn, bind){
		this.task = task;

		try{
			var ret = fn.call(bind, this.task);
			if( ret && typeof ret.then === 'function' ){ // support promise
				ret.then(this.resolve.bind(this), this.reject.bind(this));
			}
		}
		catch(e){
			this.reject(e);
		}
	},

	complete: function(error, result){
		if( error ) this.reject(error);
		else this.resolve(result);
	},

	resolve: function(value){
		if( !this.done ){
			this.done = true;
			this.task.resolve(value);
		}
	},

	reject: function(value){
		if( !this.done ){
			this.done = true;
			this.task.reject(value);
		}
	}
});

/*
unlike promise, task dont try to resolve until task.run() is called
*/
var Task = proto.create({
	value: null,
	state: undefined,
	fn: null,
	bind: null,
	paused: false,
	autorun: false,

	constructor: function(fn, bind){
		if( arguments.length > 0 ){
			if( typeof fn != 'function' ) throw new TypeError('function expected');
			this.fn = fn;
			this.bind = bind;
		}

		if( this.autorun ) this.run();
	},

	isRunning: function(){
		return this.state === null;
	},

	isPassed: function(){
		return this.state === true;
	},

	isFailed: function(){
		return this.state === false;
	},

	isCompleted: function(){
		return this.state !== null;
	},

	isPaused: function(){
		return this.paused === true;
	},

	onresolve: function(){
		// do some logic on resolve
	},

	onreject: function(){
		// do some logic on reject
	},

	resolve: function(value){
		try{
			if( value === this) throw new TypeError('A task cannot be resolved with itself.');
			if( value && (typeof value === 'object' || typeof value === 'function') ){
				var then = value.then;
				if( typeof then === 'function' ){
					this.execute(then, value);
					return;
				}
			}
		}
		catch(e){
			this.reject(e);
		}

		this.state = true;
		this.value = value;
		this.onresolve();
	},

	reject: function(value){
		this.state = false;
		this.value = value;
		this.onreject();
	},

	complete: function(error, result){
		if( error ){
			this.reject(error);
		}
		else{
			this.resolve(result);
		}
	},

	exec: function(fn, bind){
		this.state = null;
		this.executor = Executor.new(this, fn, bind);
	},

	run: function(){
		this.exec(this.fn, this.bind);
	},

	// faut pouvoir en mettre plusieurs, je vais utiliser Notifier je pense
	then: function(onresolve, onreject){
		this.onresolve = onresolve;
		this.onreject = onreject;
		if( this.isCompleted() ){
			if( this.isPassed() ) this.onresolve();
			else this.onreject();
		}
	},

	prevent: function(){
		if( this.isCompleted() ) throw new TypeError('cannot prevent a completed task');
		this.executor.done = true;
	},

	pause: function(){
		this.prevent();
		this.paused = true;
	},

	resume: function(){
		this.paused = false;
		this.run();
	},

	rerun: function(){
		this.prevent();
		this.run();
	}
});

// return a task completed once all values in iterable are resolved (one after an other) or a value is rejected
var TaskSerie = proto.extend(Task, {
	iterable: null,
	iterator: null,
	index: null,
	length: null,
	current: null,

	constructor: function(iterable){
		this.iterator = iterable['@@iterator']();
		Task.call(this, this.start, this);
	},

	start: function(){
		this.index = 0;
		this.length = 0;
		this.current = null;
		this.values = [];
		this.next();
	},

	progress: function(value){
		this.values[this.index] = value;
		this.index++;
		this.length++;
		this.next();
	},

	next: function(){
		if( this.paused ) return;

		var next = this.iterator.next(), value;

		if( next.done === true ){
			this.resolve(this.values);
		}
		else{
			value = next.value;
			this.current = value;

			if( value && (typeof value === 'object' || typeof value === 'function') ){
				var then = value.then;
				if( typeof value.then === 'function' ){
					value.then(this.progress.bind(this), this.reject.bind(this));
					// autorun the task
					if( value instanceof Task && !value.isRunning() ) value.run();
				}
				else{
					this.progress(value);
				}
			}
			else{
				this.progress(value);
			}
		}
	},

	pause: function(){
		this.paused = true;

		if( this.current && typeof this.current === 'object' ){
			var pause = this.current.pause;
			if( typeof pause === 'function' ) pause.call(this.current);
		}
	},

	resume: function(){
		this.paused = false;

		if( this.current && typeof this.current === 'object' ){
			var resume = this.current.resume;
			if( typeof resume === 'function' ) resume.call(this.current);
			else this.next();
		}
		else{
			this.next();
		}
	}
});

Task.serie = function(iterable){
	return new TaskSerie(iterable);
};

// comme les tâche ne sont pas autorun() comme les promise
// il est moins intéréssant des les wrapper dans des itérateurs pour ne pas les instancier
// on peut très bien les instancier et les passer à Task.serie

require('Iterator.map');
var IterableTasks = proto.create({
	constructor: function(iterable){		
		return Iterator.map(iterable, this.createTask, this);
	},

	createTask: function(fn){
		return new Task(fn);
	},

	toString: function(){
		return '[object Task Iterator]';
	}
});

var IterableCollectFileTasks = proto.extend(IterableTasks, {
	createTask: function(module){
		return new Task(module.collect, module);
	}
});

var IterableLoadModuleTasks = proto.extend(IterableTasks, {
	createLoadTask: function(module){
		return new Task(module.load, module);
	},

	createTask: function(module){
		var task = this.createLoadTask(module);

		// this.task est en réalité runner.task
		// faut juste que je puisse accéder à runner.tas

		/*

		ce que je pourrais faire, c'est que dans runner avant de créer les tâches loadModules
		j'observe les fichiers
		ensuite par contre je dois savoir la tâche en cours par rapport au module
		ça je dois pas trop comment faire

		if( this.task.current.name === 'loadModules' && this.task.current.current.bind === module ){
			// la tâche en cours est le chargement de ce module
		}
		else if( this.task.isRunning() ){
			// la tâche en cours est le chargement d'un module
			// case particulier si la tâche en cours consiste à charger un autre module que celui-ci
			// et qu'ensuite on cherche à loader ce module
			// ou une autre tâche
		}
		else{
		
		}

		this.task.current = 
		*/

		// test.path lead to the module main file (index.js), dependencies are ignored
		// to be exaustive we should detect dependencies changes too
		this.FileObserver.prototype.observe(module.path, function(){
			// module changed while loading or after load error
			if( task.isRunning() || task.isFailed() ){
				task.rerun();
			}
			// module changed while an other task is running
			else if( this.task.isRunning() ){
				// pause the task
				this.task.pause();
				// delete cache
				delete require.cache[module.path];
				// create a new load task
				task = this.createLoadTask(module);
				// once the module is reloaded resume the previous task
				task.then(this.task.resume.bind(this.task));
			}
			else{
				// delete cache
				delete require.cache[module.path];
				// create a load task and a run task
				task = Task.serie([this.createLoadTask(module), new Task(module.run, module)]);				
				// make it the current task
				this.task = task;
				task.then(this.onmodulererun.bind(this, module), this.onerror);
			}
		}, this);

		return task;
	}
});

var IterableLoadFileTasks = proto.extend(IterableTasks, {
	createLoadTask: function(file){
		return new Task(file.load, file);
	},

	createTask: function(file){
		var task = this.createLoadTask(file);

		this.FileObserver.prototype.observe(file.path, function(){
			// file changed while this task is the last task runned (still loading or error while loading)
			if( task.isRunning() || task.isFailed() ){
				task.rerun();
			}
			// an other task is running
			else if( this.task.isRunning() ){
				this.task.pause();
				delete require.cache[file.path];
				task = this.createLoadTask();
				task.then(this.task.resume.bind(this.task));
			}
			else{
				// delete cache
				delete require.cache[file.path];
				// create a new load task followed by a run task
				task = Task.serie([this.createLoadTask(file), new Task(file.run, file)]);
				this.task = task;
				task.then(this.onfilererun.bind(this, file), this.onerror);
			}
		}, this);

		return task;
	}
});

var IterableRecursiveLoadFileTasks = proto.extend(IterableTasks, {
	createTask: function(module){
		return Task.serie(new IterableLoadFileTasks(module.tests));
	}
});

var proto = require('proto');
var TestPrototype = require('../TestPrototype');
var TestSerie = proto.extend(TestPrototype, {
	name: 'Anonymous testSerie',
	Test: require('../Test'),
	type: 'serie',
	tests: null,
	index: 0,
	current: null,
	progressEvent: null,
	loaded: false,

	constructor: function(tests){
		this.tests = tests || [];
	},	

	get count(){
		var i = 0, j = this.tests.length, count = 0, test;

		for(;i<j;i++){
			test = this.tests[i];
			if( TestSerie.isPrototypeOf(test) ){
				count+= test.count;
			}
			else{
				count++;
			}
		}

		return count;
	},

	get length(){
		return this.tests.length;
	},

	forEach: function(fn, bind){
		return this.tests.forEach(fn, bind);
	},

	createTest: function(){
		var test;

		if( this.Test.isPrototypeOf(arguments[0]) ) {
			test = arguments[0];
		}
		else{
			test = this.Test.new.apply(this.Test, arguments);
			test.parent = this;
		}

		return test;
	},

	createChild: function(){
		return this.createTest.apply(this, arguments);
	},

	add: function(){
		var test = this.createTest.apply(this, arguments);
		this.tests.push(test);
		return this;
	},

	setup: function(){
		this.index = 0;
		this.current = null;
	},

	teardown: function(){
		// something to do?
	},

	clean: function(){
		if( this.current ){
			this.current.stop();
		}
		TestPrototype.prototype.clean.call(this);
	},

	initProgressEvent: function(){
		this.progressEvent = {
			currentTarget: this,
			target: null,
			loaded: 0,
			total: this.tests.length
		};
	},

	progress: function(){
		this.progressEvent.loaded++;
		this.progressEvent.target = this.current;
		this.emit('progress', this.progressEvent);
	},

	next: function(){
		if( this.index >= this.tests.length ){
			return null;
		}
		else{
			this.current = this.tests[this.index];
			
			this.current.onerror = function(e){
				this.fail(e);
			}.bind(this);
			this.current.onend = function(e){
				this.nextTest();
			}.bind(this);

			this.index++;
			return this.current;
		}
	},

	nextTest: function(){
		this.progress();

		if( this.next() ){
			this.current.start();
		}
		// all test passed with success or no test to run
		else{
			this.pass();
		}
	},

	run: function(){
		if( this.next() ){
			this.initProgressEvent();
			this.current.start();
		}
		else{
			this.pass();
		}
	}
});

module.exports = TestSerie;

var Test = require('Test');

var FileTest = proto.extend(TestSerie, {
	Test: Test,
	path: null,	

	constructor: function(){
		this.path = path;
		TestSerie.call(this);
	},

	get module(){
		return this.parent ? this.parent.module : null;
	},

	load: function(fn, bind){
		var error, exports;

		try{
			exports = require(this.path);

			this.tests = Object.keys(exports).map(function(key){
				return this.createChild(key, exports[key]);
			}, this);
		}
		catch(e){
			error = e;
		}

		fn.call(bind, error);
	}
});

var ModuleTest = proto.extend(TestSerie, {
	FileCollector: require('./FileTestCollector'),
	Test: FileTest,
	type: 'module',
	path: null,
	module: null,

	constructor: function(path){
		this.path = path;
		TestSerie.call(this);
	},

	collect: function(fn, bind){
		this.FileCollector.collect(this.path, function(error, paths){
			if( !error ){
				this.tests = paths.map(function(path){
					return this.createChild(path);
				});
			}

			fn.call(bind, error);			
		}, this);			
	},

	load: function(fn, bind){
		var error, module;

		try{			
			module = this.util.requireModule(this.path);
			this.module = module;
		}
		catch(e){
			error = e;
		}

		fn.call(bind, error);
	}
});

var TestCollector = proto.create({
	util: require('module-util'),
	startDate: null,
	endDate: null,

	collect: function(path, fn, bind){
		this.startDate = new Date();
		this.util.collectModulePaths(path, function(error, modulePaths, badPaths){
			this.endDate = new Date();
			this.error = error;
			this.result = modulePaths;

			/*
			// faudrais faire kkchose avec badPaths
			if( badPaths.length ){
				// test files cannot be considered as bad modules
				badPaths = badPaths.filter(this.Collector.filterFolder, this.Collector);
				//if( badSignaturePaths.length ) this.test.emit('badSignature', badSignaturePaths);
			}
			*/

			fn.call(bind, error, modulePaths, this.startDate - this.endDate, this);
		}, this);
	}	
});

var TestRunner = proto.create({
	FileObserver: require('FileObserver'),

	phase: null, // null, 'collect', 'load', 'setup', 'run'
	state: 'created', // 'created', 'collecting', 'preparing', 'loading', 'running', 'ended'
	test: null,
	collector: null,

	onerror: function(){},
	oncollect: function(){},
	onmodulechange: function(){},
	onfilechange: function(){},
	onloadprogress: function(){},
	onload: function(){},
	ontestprogress: function(){},
	onend: function(){},

	collectError: function(e){
		this.onerror(e);
	},

	loadError: function(e){
		this.onerror(e);
	},

	loadProgress: function(e){
		this.onloadprogress(e);
	},

	/*
	load: function(){
		this.onload(new Date() - this.loadStartDate);
		this.start(this.test);
	},
	*/

	collectFiles: function(){
		return Task.serie(new IterableCollectFileTasks(this.modules));
	},

	loadModules: function(){
		return Task.serie(new IterableLoadModuleTasks(this.modules)).then(function(){
			this.modules = this.modules.filter(function(module){
				return module.tests.length === 0;
			}, this);
		});
	},

	loadFiles: function(){
		return Task.serie(new IterableRecursiveLoadFileTasks(this.modules));
	},

	runTests: function(){
		return Task.serie(new IterableRecursiveRunTestTasks(this.modules));
	},

	run: function(path){
		this.path = path;
		this.collector = TestCollector.new();
		this.state = 'collecting';

		this.collector.collect(path, function(error, paths, duration){
			if( error ) return this.collectError(error);

			this.oncollect(duration);

			this.modules = paths.map(function(path){
				return ModuleTest.new(path);
			});

			var iterable = {
				runner: this,
				phases: ['collectFiles', 'loadModules', 'loadFiles', 'runTests'],
				index: 0,

				next: function(){
					if( this.index >= this.phases.length ){
						return {done: true, value: undefined};
					}

					return {done: false, value: this.runner[this.phases[this.index]]()};
				},

				'@@iterator': function(){
					return this;
				}
			};

			this.task = Task.serie(iterable);
			this.task.then(this.end.bind(this), this.error.bind(this));
			this.task.run();
		}, this);
	}
});