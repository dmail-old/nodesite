/*

TODO : en cas d'erreur Promise.chain() ne pourras jamais être résolue
hors en cas d'erreur je veux pouvoir reprend où j'en étais, réfléchir si tout ceci est possible

Ce que je veux c'est :

lancer un processus qui consiste à collecter, observer, charger, éxécuter des fichiers

à tout moment je veux pouvoir mettre ce process en pause
puis reprendre ce process où il en était (et même être capable de revenir en arrière)

pour l'utilisation que j'en ai ici :
- besoin de pouvoir recharger un fichier lorsqu'il est modifié pendant la phase "charger"
	déjà chargé -> à recharger
	pas encore chargé -> NOOP
	en cours de chargement -> ignorer le résultat et recharger
- besoin de pouvoir réexecuter un fichier lorsqu'il est modifié pendant la phase "éxécuter"
	déjà éxécuté -> à relancer
	pas encore éxecuté -> NOOP
	en cours d'éxécution -> ignorer le résultat et éxécuter à nouveau
- besoin de pouvoir recharger/rééxecuter un fichier (ou un groupe) lorsqu'il est modifié après la phase "exécuter"
- pas besoin de mettre en pause la phase "collecter"
- besoin de mettre en pause la phase "charger" en cas d'erreur
- besoin de mettre en pause la phase "éxécuter" en cas d'erreur

avec les promise je ne peux pas mettre en pause la phase "charger"
puisque en cas d'erreur la promesse Promise.chain(this.modules, 'load')
aura échouée, on ne peut pas la relancer où on en était
il faut donc que promise.chain puisse être mis en pause, en tout ca qu'on puisse repndrendre même après
une erreur

*/

var Promise = require('Promise');

var proto = require('proto');
var TestPrototype = require('../TestPrototype');
var TestSerie = proto.extend(TestPrototype, {
	name: 'Anonymous testSerie',
	Test: require('../Test'),
	type: 'serie',
	tests: null,
	index: 0,
	current: null,
	progressEvent: null,
	loaded: false,

	constructor: function(tests){
		this.tests = tests || [];
	},	

	get count(){
		var i = 0, j = this.tests.length, count = 0, test;

		for(;i<j;i++){
			test = this.tests[i];
			if( TestSerie.isPrototypeOf(test) ){
				count+= test.count;
			}
			else{
				count++;
			}
		}

		return count;
	},

	get length(){
		return this.tests.length;
	},

	forEach: function(fn, bind){
		return this.tests.forEach(fn, bind);
	},

	createTest: function(){
		var test;

		if( this.Test.isPrototypeOf(arguments[0]) ) {
			test = arguments[0];
		}
		else{
			test = this.Test.new.apply(this.Test, arguments);
			test.parent = this;
		}

		return test;
	},

	createChild: function(){
		return this.createTest.apply(this, arguments);
	},

	add: function(){
		var test = this.createTest.apply(this, arguments);
		this.tests.push(test);
		return this;
	},

	setup: function(){
		this.index = 0;
		this.current = null;
	},

	teardown: function(){
		// something to do?
	},

	clean: function(){
		if( this.current ){
			this.current.stop();
		}
		TestPrototype.prototype.clean.call(this);
	},

	initProgressEvent: function(){
		this.progressEvent = {
			currentTarget: this,
			target: null,
			loaded: 0,
			total: this.tests.length
		};
	},

	progress: function(){
		this.progressEvent.loaded++;
		this.progressEvent.target = this.current;
		this.emit('progress', this.progressEvent);
	},

	next: function(){
		if( this.index >= this.tests.length ){
			return null;
		}
		else{
			this.current = this.tests[this.index];
			
			this.current.onerror = function(e){
				this.fail(e);
			}.bind(this);
			this.current.onend = function(e){
				this.nextTest();
			}.bind(this);

			this.index++;
			return this.current;
		}
	},

	nextTest: function(){
		this.progress();

		if( this.next() ){
			this.current.start();
		}
		// all test passed with success or no test to run
		else{
			this.pass();
		}
	},

	run: function(){
		if( this.next() ){
			this.initProgressEvent();
			this.current.start();
		}
		else{
			this.pass();
		}
	}
});

module.exports = TestSerie;

var Test = require('Test');

var FileTest = proto.extend(TestSerie, {
	Test: Test,
	path: null,	

	constructor: function(){
		this.path = path;
		TestSerie.call(this);
	},

	get module(){
		return this.parent ? this.parent.module : null;
	},

	load: function(){
		if( this.loadPromise === null ){
			this.loadPromise = new Promise(function(resolve, reject){
				resolve(require(this.path));
			}.bind(this));
		}
		return this.loadPromise;
	},

	populate: function(){
		return this.load().then(function(value){
			this.tests = Object.keys(value).map(function(key){
				return this.createChild(key, value[key]);
			}, this);
		}.bind(this));
	}
});

var ModuleTest = proto.extend(TestSerie, {
	FileCollector: require('./FileTestCollector'),
	Test: FileTest,
	type: 'module',
	path: null,
	module: null,

	constructor: function(path){
		this.path = path;
		TestSerie.call(this);
	},

	collectFiles: function(){
		var self = this;

		return new Promise(function(resolve, reject){
			self.FileCollector.collect(self.path, function(error, paths){
				if( error ) reject(error);
				else resolve(paths);
			});
		}, this).then(function(paths){
			this.tests = paths.map(function(path){
				return this.createChild(path);
			});
		});	
	},

	load: function(){
		if( this.loadPromise === null ){
			this.loadPromise = new Promise(function(resolve, reject){
				resolve(this.util.requireModule(this.path));
			}.bind(this));
		}
		return this.loadPromise;
	},

	populate: function(){
		return this.load().then(function(value){
			this.module = value;
		}.bind(this));
	},

	populateFiles: function(){
		return Promise.chain(this.tests, 'populate');
	},

	run: function(){
		return Promise.chain(this.tests, 'run');
	}
});

var TestCollector = proto.create({
	util: require('module-util'),
	startDate: null,
	endDate: null,

	collect: function(path, fn, bind){
		this.startDate = new Date();
		this.util.collectModulePaths(path, function(error, modulePaths, badPaths){
			this.endDate = new Date();
			this.error = error;
			this.result = modulePaths;

			/*
			// faudrais faire kkchose avec badPaths
			if( badPaths.length ){
				// test files cannot be considered as bad modules
				badPaths = badPaths.filter(this.Collector.filterFolder, this.Collector);
				//if( badSignaturePaths.length ) this.test.emit('badSignature', badSignaturePaths);
			}
			*/

			fn.call(bind, error, modulePaths, this.startDate - this.endDate, this);
		}, this);
	}	
});

var TestRunner = proto.create({
	FileObserver: require('FileObserver'),

	phase: null, // null, 'collect', 'load', 'setup', 'run'
	state: 'created', // 'created', 'collecting', 'preparing', 'loading', 'running', 'ended'
	test: null,
	collector: null,

	onerror: function(){},
	oncollect: function(){},
	onmodulechange: function(){},
	onfilechange: function(){},
	onloadprogress: function(){},
	onload: function(){},
	ontestprogress: function(){},
	onend: function(){},

	collectError: function(e){
		this.onerror(e);
	},

	loadError: function(e){
		this.onerror(e);
	},

	loadProgress: function(e){
		this.onloadprogress(e);
	},

	/*
	load: function(){
		this.onload(new Date() - this.loadStartDate);
		this.start(this.test);
	},
	*/

	collect: function(){
		return Promise.chain(this.modules, 'collectFiles');
	},

	populate: function(){
		this.modules = this.modules.filter(function(module){
			// test.path lead to the module main file (index.js), dependencies are ignored
			// to be exaustive we should detect dependencies changes too
			this.FileObserver.prototype.observe(module.path, function(){
				if( this.state === 'loading' ){
					// en cours de load, on reprend le chargement
					// ou une erreur était survenue, on retente
					if( module.loadPromise ){
						if( module.loadPromise.isPending() || module.loadPromise.isRejected() ){
							module.loadPromise.rerun();
						}
					}
				}				
				else if( this.state === 'running' || this.state === 'ended' ){
					// trouve le moduleTestPromise
					var moduleRunPromise;				

					if( this.state === 'running' ){
						moduleRunPromise.prevent(); // prevent promise résolution
					}

					delete require.cache[module.path];				
					module.populate().then(function(){ // recharge le module
						moduleRunPromise.rerun(); // relance les tests
					});
				}
			}, this);

			return module.tests.length === 0;
		}, this);

		return Promise.chain(this.modules, 'populate');
	},

	populateFiles: function(){
		this.modules.forEach(function(module){
			module.forEach(function(file){
				this.FileObserver.prototype.observe(file.path, function(){
					// en cours de load, on reprend le chargement
					// oou une erreur était survenue, on retente
					if( file.loadPromise.isPending() || file.loadPromise.isRejected() ){
						file.loadPromise.rerun();
					}
					else{
						// trouve le moduleTestResolver
						var fileRunPromise;				

						if( this.state === 'running' ){
							fileRunPromise.prevent(); // prevent promise résolution
						}

						delete require.cache[file.path];				
						file.populate().then(function(){ // recharge le module
							fileRunPromise.rerun(); // relance les tests
						});
					}
				}, this);
			}, this);
		}, this);

		return Promise.chain(this.modules, 'populateFiles');
	},

	exec: function(){
		return Promise.chain(this.modules, 'run');
	},

	run: function(path){
		this.path = path;
		this.collector = TestCollector.new();
		this.state = 'collecting';

		this.collector.collect(path, function(error, paths, duration){
			if( error ) return this.collectError(error);

			this.oncollect(duration);

			this.modules = paths.map(function(path){
				ModuleTest.new(path);
			});

			Promise.chain(['collect', 'populate', 'populateFiles', 'exec'], this).then(this.onend, this.onerror);

		}, this);
	}
});