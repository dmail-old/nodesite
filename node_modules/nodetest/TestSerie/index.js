/*

maybe add a skip(reason) method a skip the test under some conditions (reason is optionnal)
and a method skipIf(condition, reason)

reste à redémarrer loadtask lorsque modifié pendant qu'il s'éxécute (narriveras jamais en pratique)
à capter les fichiers/modules ayant été changé et dans ce cas interrupt les tests en cours, ou pas plutot mettre ça
quelque part pour que lorsque les tests sont terminé on regardé si y'a des choses à relancer
si aucun test en cours on relance juste ce qui a été changé, juste un fileTest ou juste un moduleTest

assert pourrait créer des Promise (ou Task)
et les accumuler et ne les tester qu'une fois qu'on apelle test.done()*

il n'y a pas d'apel imbriqué, les assertions doivent se faire direct
ou alors

on par du principe que test.equal etc est un raccourci pour
if( a != b ) test.reject();

du coup je me vois bien écrire

moduleA.js
module.exports = {
	name: 'foo'
};

// a basic test looks like
exports['foo module is named foo'] = function(foo){
	if( foo.name !== 'foo' ) throw new Error('foo name is not foo');	
};

// the second argument will help you to do assertions
exports['2+2 = 4'] = function(foo, test){
	test.equal(foo.name, 'foo');
};

exports['test stuff'] = function(test){
	test.equal('a', 'a');

	// just create a promise
	test.promise(function(resolve, reject){
		
	});

	test.willBe(function(){
		require('fs').readFile('test.js', test.current.complete);
	}, 'hello world');
};


*/

var Task = require('Task');
var proto = require('proto');

var Assertion = proto.create({
	name: null,
	args: null,
	methods: {
		'ok': function(a){
			return Boolean(a);
		},

		'equal': function(a, b){
			return a == b;
		},

		'strictEqual': function(a, b){
			return a === b;
		},

		'typeOf': function(a, b){
			return typeof a === b;
		},

		'protoOf': function(a, b){
			return Object.getPrototypeOf(a) === b;
		},

		'error': function(a, b){
			try{
				a();
			}
			catch(e){
				if( b ){
					if( typeof b == 'string' ){
						return e.type.toLowerCase() === b.toLowerCase();
					}
					else if( typeof b == 'function' ){
						return e instanceof b;
					}
				}				
				return true;
			}
			return false;
		},

		// retourne une promesse qui échoue si la valeur résolue n'est pas celle attendue
		'willBe': function(promise, value){
			if( typeof promise === 'function' ){
				promise = new Task(promise);
			}

			var assertion = this;
			
			return promise.then(function(val){
				if( !assertion.equal(value, val) ){
					throw assertion.createError();
				}
			});
		},

		// retourne une promesse qui réussit si elle résusit et échoue sinon (la preomesse elle-même)
		'willResolve': function(promise){
			if( typeof promise === 'function' ){
				promise = new Task(promise);
			}

			return promise;
		},

		// retourne une promesse qui échoue si elle réussit et inversement
		'willReject': function(promise){
			if( typeof promise === 'function' ){
				promise = new Task(promise);
			}

			var assertion = this;

			return promise.then(
				function(){
					throw assertion.createError();
				},
				function(){
					return true;
				}
			);
		}
	},

	constructor: function(name, args){
		this.name = name;
		this.args = args;
	},

	createError: function(type, args){
		var error = new Error('failed assertion');
		error.name = 'AssertionError';
		error.type = this.name;
		error.args = this.args;
		return error;
	},

	exec: function(resolve, reject){
		var ret = this.methods[this.name].apply(this, this.args);

		if( typeof ret === 'boolean' ){
			if( ret ){
				resolve();
			}
			else{
				reject(this.createError());
			}
		}
		else{
			ret.then(resolve, reject);
		}
	},

	test: function(){
		return new Task(this.exec, this);
	}
});

var Test = proto.create({
	type: 'test',
	description: 'Anonymous test',
	fn: null,
	imports: null,
	timeout: 100,
	assertions: null,
	current: null, // the current assertion test Task

	constructor: function(fn, description){
		if( arguments.length > 0 ){
			this.fn = fn;
			this.description = String(description);
		}

		this.assertions = [];
	},

	assert: function(name, args){
		this.assertions.push(new Assertion(name, args));
	},

	// fill the assertions array
	load: function(imports){
		if( imports instanceof module.constructor ){
			this.imports = imports.exports;
		}
		else{
			this.imports = imports;
		}

		var task = new Task(function(){
			this.fn.call(this, this.imports, this);
			return this.assertions;
		}, this);

		return task;
	},

	// (execAssertions)
	execTests: function(){
		var task = Task.every(this.assertions, function(assertion){
			this.current = assertion.test();
			return this.current;
		}, this);
		
		task.setTimeout(this.timeout);		

		return task;
	},

	// load + exec
	test: function(module){
		return Task.reduce([
			function(){
				return this.load(module);
			},
			function(){
				return this.execTests();
			}
		], this);
	},

	toString: function(){
		return '[object Test ' + this.description + ']';
	}
});

Object.keys(Assertion.prototype.methods).forEach(function(key){
	Test.prototype[key] = function(){
		return this.assert(key, arguments);
	};
});

var FileTest = proto.create({
	FileObserver: require('FileObserver'),
	tests: null,

	constructor: function(path, changeReaction){
		this.path = path;
		this.tests = [];

		if( changeReaction ){
			this.observe(function(){
				changeReaction.call(this);
			}, this);
		}	
	},

	observe: function(fn, bind){
		this.FileObserver.prototype.observe(this.path, fn, bind);
	},

	createTest: function(testFn, description){
		return new Test(testFn, description);
	},

	load: function(){
		var path = this.path;

		var task = new Task(function(resolve, reject){
			resolve(require(path));
		});

		task.reset = function(){
			delete require.cache[path];
		};

		task = task.then(function(exports){
			this.tests = Object.keys(exports).map(function(key){
				return this.createTest(exports[key], key);
			}, this);
		}.bind(this));	

		return task;
	},

	execTests: function(module){
		return Task.every(this.tests, function(test){
			return test.test(module);
		}).then(function(tests){
			return {duration: this.duration, count: tests.length};
		});
	},

	test: function(module){
		return Task.reduce([
			function(){
				return this.load();
			},
			function(){
				return this.execTests(module);
			}
		], this);
	}
});

var ModuleTest = proto.create({	
	FileObserver: require('FileObserver'),
	module: null,
	fileTests: null,

	constructor: function(path, changeReaction, fileChangeReaction){
		this.path = path;
		this.fileTests = [];

		if( changeReaction ){
			this.observe(function(){
				changeReaction(this);
			}, this);
		}

		this.fileChangeReaction = fileChangeReaction;
	},


	observe: function(fn, bind){
		// test.path lead to the module main file (index.js), dependencies are ignored
		// to be exaustive we should detect dependencies changes too
		this.FileObserver.prototype.observe(this.path, fn, bind);
	},

	createFileTest: function(path){
		return new this.FileTest(path, this.fileChangeReaction);
	},

	fileChangeReaction: function(fileTest){},

	scan: function(path){
		return new Task(function(resolve, reject){
			this.FileCollector.collect(path, function(error, paths){
				if( error ) reject(error);
				else resolve(paths);
			});
		}, this);
	},

	loadFiles: function(){
		return Task.reduce([
			function(path){
				return this.scan(path);
			},
			function(filePaths){
				return filePaths.map(this.createFileTest, this);
			},
			function(fileTests){
				return Task.every(fileTests, function(fileTest){
					return fileTests.load();
				});
			},
			function(fileTests){
				return fileTests.filter(function(fileTest){
					return fileTest.tests.length === 0;
				});
			},
			function(fileTests){
				this.fileTests = fileTests;
			}
		], this, this.path);
	},

	loadModule: function(){
		var path = this.path;
		var task = new Task(function(resolve){
			resolve(this.util.requireModule(path));
		}, this);
		task.reset = function(){
			delete require.cache[path];
		};

		task = task.then(function(module){
			this.module = module;
		}.bind(this));

		return task;
	},
	
	load: function(){
		return Task.reduce([
			function(){
				return this.loadFiles();
			},
			function(){
				return this.loadModule();
			}
		], this);
	},

	execTests: function(){
		var task = Task.every(this.fileTests, function(fileTest){
			return fileTest.test(this.module);
		}, this);

		return task;
	},

	test: function(){
		return Task.reduce([
			function(){
				return this.load();
			},
			function(){
				return this.execTests(); 
			}
		], this);
	}	
});

var FolderTest = proto.create({
	FileObserver: require('FileObserver'),
	FileCollector: require('./FileTestCollector'),
	ModuleTest: ModuleTest,
	watch: false,
	moduleChangeReaction: null,
	fileChangeReaction: null,

	constructor: function(path, options){
		this.path = path;
	},

	createModuleTest: function(path){
		return new this.ModuleTest(path, this.moduleChangeReaction, this.fileChangeReaction);
	},

	collect: function(){
		return new Task(function(resolve, reject){
			// il faut retourner une liste de path déjà ordonnée
			this.util.collectModulePaths(path, function(error, modulePaths, badPaths){
				/*
				// faudrais faire kkchose avec badPaths
				if( badPaths.length ){
					// test files cannot be considered as bad modules
					badPaths = badPaths.filter(this.Collector.filterFolder, this.Collector);
					//if( badSignaturePaths.length ) this.test.emit('badSignature', badSignaturePaths);
				}
				*/

				if( error ) reject(error);
				else resolve(modulePaths);
			}, this);
		}, this);
	},

	test: function(){
		var tasks = [
			// find modules
			function(folderPath){
				return this.collect(folderPath);
			},
			// create modules
			function(modulePaths){
				return modulePaths.map(this.createModuleTest, this);
			},
			// load module tests, and filter thoose without tests
			function(modules){
				return Task.every(modules, function(module){
					return module.loadFiles();
				}, this);
			},
			// filter useless modules
			function(modules){
				return modules.filter(function(module){
					return module.fileTests.length === 0;
				});
			},
			// load modules
			function(modules){
				return Task.every(modules, function(module){
					return module.loadModule();
				});
			},
			// sort modules
			function(modules){
				return modules.sort(function(moduleA, moduleB){
					return moduleA.module.dependencyLevel, moduleB.module.dependencyLevel;
				});
			},
			// test modules
			function(modules){
				return Task.every(modules, function(module){
					return module.execTests();
				});
			}
		];

		var task = Task.reduce(tasks, this, this.path);

		return task;
	}
});

var TestRunner = proto.create({
	formatTask: function(task){
		task.time();
		task = task.then(function(array){
			return {duration: task.duration, count: array.length};
		});
		return task;
	},

	testFile: function(filePath, module, options){
		if( !module ){
			// trouve modulePath grace à filePath
			module = '';
		}

		var loadTask;
		if( typeof module === 'string' ){
			loadTask = new ModuleTest(module).load();
		}
		else{
			loadTask = Task.resolve(module);
		}

		return this.formatTask(loadTask.then(function(module){
			return new FileTest(filePath).test(module);
		}));
	},

	testModule: function(modulePath, options){
		return this.formatTask(new ModuleTest(modulePath).test());
	},

	testFolder: function(folderPath, options){
		return this.formatTask(new FolderTest(folderPath).test());
	}
});