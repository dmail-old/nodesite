// create a promised version of the fs

require('Promise');
require('array.prototype.find');
var proto = require('proto');

var FakeNode = proto.create({

});

var FakeStat = proto.create({
	dev: 2114,
	ino: 48064969,
	mode: 33188,
	nlink: 1,
	uid: 85,
	gid: 100,
	rdev: 0,
	size: 527,
	blksize: 4096,
	blocks: 8,
	atime: Mon, 10 Oct 2011 23:24:11 GMT,
	mtime: Mon, 10 Oct 2011 23:24:11 GMT,
	ctime: Mon, 10 Oct 2011 23:24:11 GMT,
	birthtime: Mon, 10 Oct 2011 23:24:11 GMT

	constructor: function(){

	},

	isFile: function(){

	},

	isDirectory: function(){

	},

	isBlockDevice: function(){

	},

	isCharacterDevice: function(){

	},

	isSymbolicLink: function(){

	},

	isFIFO: function(){

	},

	isSocket: function(){

	}
});

// les versions sync sont comme les versions non sync puisque tout est sync en fait

var FakeFileSystem = proto.create({
	constructor: function(tree){
		this.nodes = [];
	},

	getNode: function(path){
		return this.nodes.find(function(node){
			return node.path === path;
		});
	},

	exists: function(path){
		return this.getNode(path) ? true : false;
	},

	rename: function(oldPath, newPath){
		var node = this.getNodeOrNotFound(oldPath);
		node.path = newPath;
	}
});

[
	'rename',
	'ftruncate',
	'truncate',
	'chown',
	'fchown',
	'lchown',
	'chmod',
	'fchmod',
	'lchmod',
	'stat',
	'lstat',
	'fstat',
	'link',
	'symlink',
	'readlink',
	'realpath',
	'unlink',
	'rmdir',
	'mkdir',
	'readdir',
	'close',
	'open',
	'utimes',
	'futimes',
	'write',
	'read',
	'readFile',
	'writeFile',
	'appendFile',
	'exists',
	'access',
].forEach(function(name){
	var method = FakeFileSystem.prototype[name];

	FakeFileSystem.prototype[name] = function(){
		var self = this, args = arguments;

		return new Promise(function(resolve){
			resolve(method.apply(self, args));
		});
	};
	FakeFileSystem.prototype[name + 'Sync'] = FakeFileSystem.prototype[name];
});