/*

Les autres test unitaires ignore les tests qui échouent et lancer les autres
Moi je choisit de m'arrêter au test qui fail

En vérité unitTest n'est pas rejected lorsque une AssertionError survient pendant un test
cela permet de différencier les erreur prévues des erreurs


*/

var debug = require('debug');

var LineTemplate = '{lineNumber} {lineSource}';
var LineSeparator = '\n';
var LineStyles = {
	lineNumber: 'grey',
	lineSource: 'grey',
	currentLineNumber: 'white',
	currentLineSource: 'white',
	currentLine: 'bg-yellow'
};
var ConsoleTemplate = require('LogStream/Log/ConsoleTemplate');

var LineTemplate = new ConsoleTemplate(LineTemplate);
LineTemplate.registerStyles(LineStyles);

var LogStream = require('LogStream');

function createErrorSourceLog(file, lineNumber){
	lineNumber = lineNumber - 1;

	// cannot read file out of the working directory
	if( file.indexOf(require('path').sep) === -1 ){
		return null;
	}

	var lines = require('fs').readFileSync(file, 'utf8').split(/\r?\n/);
	var contextDepth = 2;
	var minLine = Math.max(lineNumber - contextDepth, 0);
	var maxLine = Math.min(lineNumber + contextDepth, lines.length);

	lines = lines.slice(minLine, maxLine);

	var source = LineTemplate.repeat(lines, LineSeparator, function(line, index, log, array){
		if( minLine + index == lineNumber ){
			log.globalStyle = 'currentLine';
			log.registerStyle('lineNumber', 'currentLineNumber');
			log.registerStyle('lineSource', 'currentLineSource');
		}

		return {
			lineNumber: minLine + index + 1,
			lineSource: line
		};
	});

	return source;
}

function handleFailure(logger, error){
	if( error.name == 'AssertionError' ){
		var stack = error.stack;

		/*
		if( error.type == 'equal' ){
			stack = stack.replace(/^.*?\n/, error.args[0] + ' not equal to ' + error.args[1] + '\n');
		}
		*/

		var source = createErrorSourceLog(error.file, error.line);

		if( error.id ){
			console.log('Error in the test "', error.id, '"');
		}

		if( source == null ){
			logger.error('{stack}\n{source}', {
				stack: stack,
				source: 'node native code (certainly Promise)'
			});
		}
		else{
			logger.error('{stack}\n{path}\n{source}', {
				stack: stack,
				path: error.file,
				source: source
			});
		}
	}
	else{
		logger.error(error.stack);
	}
}

var proto = require('proto');

var TestResult = proto.create({
	constructor: function(reporter){
		this.reporter = reporter;
		this.pending = true;
		this.promise = this.reporter.test.test();
		this.promise.then(this.resolve.bind(this), this.reject.bind(this)).catch(function(error){
			console.error('internal error while testing', error.stack);
		});
	},

	resolve: function(value){
		if( !this.cancelled ){
			this.pending = false;
			this.reporter.onresolve(value);
		}
	},

	reject: function(value){
		if( !this.cancelled ){
			debug('rejected test with', value);
			this.pending = false;
			this.reporter.onreject(value);
		}
	},

	cancel: function(){
		this.cancelled = true;
	}
});

var TestReporter = proto.create({
	Table: require('TableTemplate'),

	constructor: function(test, listener, bind, watch){
		this.test = test;

		if( typeof listener == 'function' ){
			this.listener = listener;
			this.bind = bind;
		}
		else{
			var logger;
			if( LogStream.isPrototypeOf(listener) ){
				logger = listener;
			}
			else{
				logger = new LogStream();
			}

			watch = bind;
			this.logger = logger;
			this.listener = function(error){
				var meta = this.test.meta;

				if( this.test.type === 'folder' ){
					this.handleFolderResult(meta);
				}
				else if( this.test.type === 'module' ){
					this.handleModuleResult(meta);
				}
				else if( this.test.type === 'file' ){
					this.handleFileResult(meta);
				}
				else{
					this.handleTestResult(meta);
				}				

				if( error ){
					handleFailure(this.logger, error);
				}
			};
			this.bind = this;
		}

		if( watch ) this.enableFileWatch();
		this.start();
	},

	handleFolderResult: function(meta){
		var folderTest = this.test;
		var message = 'Test results of {path} ({duration}ms {count} modules)\n{results}';
		var table = this.Table.create();

		table.addRow(['state', 'module', 'tests', 'duration']);
		
		table.addRows(folderTest.moduleTests.map(function(moduleTest){
			return [
				moduleTest.state,
				moduleTest.path,
				moduleTest.testFiles.reduce(function(previous, testFile){
					return previous + testFile.tests.length;
				}, 0),
				moduleTest.testFiles.reduce(function(previous, testFile){
					return previous + testFile.tests.reduce(function(prev, test){
						return prev + test.duration;
					}, 0);
				}, 0)
			];
		}));

		table.column('state').conditionalFormat(function(state){
			return state == 'passed' ? 'green' : state === 'failed' ? 'red' : 'grey';
		});
		
		table.column('module').format(function(path){
			return path.slice(Math.max(path.lastIndexOf('node_modules') + 'node_modules'.length + 1, folderTest.path.length));
		});
		// avoid module path taking too much space 
		table.column('module').setStyle('maxWidth', 0.4);
		table.column('duration').format(function(value){
			return value + 'ms';
		});
		table.row(0).fix().setClass('header');

		this.logger.info(message, {
			path: folderTest.path,
			duration: folderTest.duration,
			count: folderTest.moduleTests.length,
			results: table.toString()
		});
	},

	handleModuleResult: function(){
		var moduleTest = this.test;
		// if meta.fileMetas.length === 0 return this.handleFileResult(meta.fileMetas[0]);
		var message = 'Module test results {path} ({duration}ms {count} files)\n{results}';
		var table = this.Table.create();

		table.addRow(['state', 'file', 'tests', 'duration']);
		table.addRows(moduleTest.testFiles.map(function(testFile){
			return [
				testFile.state,
				testFile.path,
				testFile.tests.length,
				testFile.duration
			];
		}));
		table.column(0).format(function(path){
			return path.slice(moduleTest.path.length);
		});
		table.row(0).setClass('header').fix();

		this.logger.info(message, {
			path: moduleTest.path,
			duration: moduleTest.duration,
			count: moduleTest.testFiles.length,
			results: table.toString()
		});
	},

	handleFileResult: function(meta){
		var fileTest = this.test;
		var message = 'File test results {path} ({duration}ms {count} tests)\n{results}';
		var table = new this.Table();

		table.addRow(['state', 'test', 'assertions', 'duration']);
		table.addRows(fileTest.tests.map(function(test){
			return [
				test.state,
				test.description,
				test.assertions.length,
				test.duration
			];
		}));
		table.column(0).format(function(path){
			return path.slice(fileTest.path.length);
		});
		table.row(0).setClass('header').fix();

		this.logger.info(message, {
			path: fileTest.path,
			duration: fileTest.duration,
			count: fileTest.tests.length,
			results: table.toString()
		});
	},

	handleTestResult: function(meta){
		var test = this.test;
		var message = 'Test {description} passed in ({duration}ms {count} assertions)';

		this.logger.info(message, {
			description: test.description,
			duration: test.duration,
			count: test.assertionCount
		});
	},

	// EBUSY peut se produire ici aussi, il faudrait la même logique que dans nodeprocess
	moduleChangeReaction: function(moduleTest){
		console.log(moduleTest.path + ' module modified');
		require('module-util').uncache(moduleTest.path);
		//delete require.cache[moduleTest.path];
		delete moduleTest.util.cache[moduleTest.path];
		this.restart();
	},

	fileChangeReaction: function(testFile){
		console.log(testFile.path + ' file modified');
		require('module-util').uncache(testFile.path);
		//delete require.cache[testFile.path];
		this.restart();
	},

	enableFileWatch: function(){
		if( this.test.type === 'folder' ){
			this.test.moduleChangeReaction = this.moduleChangeReaction.bind(this);
			this.test.fileChangeReaction = this.fileChangeReaction.bind(this);
		}
		else if( this.test.type === 'module' ){
			this.test.changeReaction = this.moduleChangeReaction.bind(this);
			this.test.fileChangeReaction = this.fileChangeReaction.bind(this);
		}
		else if( this.test.type === 'file' ){
			this.test.changeReaction = this.fileChangeReaction.bind(this);
		}
	},

	onresolve: function(meta){
		this.listener.call(this.bind, null, meta);
	},

	onreject: function(error){
		if( !error ) error = new Error('rejected task without error');
		this.listener.call(this.bind, error);
	},

	start: function(){
		this.result = new TestResult(this);
	},

	restart: function(){
		this.result.cancel();

		// avoid to recall restart when file is modified
		this.test.moduleChangeReaction = null;
		this.test.fileChangeReaction = null;
		this.test.changeReaction = null;
		// reset test metas and other stuff
		this.test.reset();

		this.start();
	}
});

var runner = require('./TestRunner');
var nodetest = {
	testFolder: function(path, fn, bind, watch){
		path = require('path').resolve(process.cwd(), path);
		return new TestReporter(runner.testFolder(path), fn, bind, watch);
	},

	testModule: function(path, fn, bind, watch){
		path = require.resolve(path);
		return new TestReporter(runner.testModule(path), fn, bind, watch);
	},

	testFile: function(path, module, fn, bind){

	},

	test: function(test, module, fn, bind){

	}
};

module.exports = nodetest;