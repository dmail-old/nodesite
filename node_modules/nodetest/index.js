/*
var nodetest = require('nodetest');

il faudrais n'observer que les modules ayant des fichier tests normalement
(commen les modules peuvent dépendre les uns des autres, par forcément)

lorsqu'un module est modifié et qu'on restart faudrais presque delete tout require.cache
parce que sinon on récup des versions en cache

*/

var LineTemplate = '{lineNumber} {lineSource}';
var LineSeparator = '\n';
var LineStyles = {
	lineNumber: 'grey',
	lineSource: 'grey',
	currentLineNumber: 'white',
	currentLineSource: 'white',
	currentLine: 'bg-yellow'
};
var ConsoleTemplate = require('LogStream/Log/ConsoleTemplate');

var LineTemplate = new ConsoleTemplate(LineTemplate);
LineTemplate.registerStyles(LineStyles);

var LogStream = require('LogStream');

function createErrorSourceLog(file, lineNumber){
	lineNumber = lineNumber - 1;

	// cannot read file out of the working directory
	if( file.indexOf(require('path').sep) === -1 ){
		return 'node native code';
	}

	var lines = require('fs').readFileSync(file, 'utf8').split(/\r?\n/);
	var contextDepth = 2;
	var minLine = Math.max(lineNumber - contextDepth, 0);
	var maxLine = Math.min(lineNumber + contextDepth, lines.length);
	
	lines = lines.slice(minLine, maxLine);

	var source = LineTemplate.repeat(lines, LineSeparator, function(line, index, log, array){
		if( minLine + index == lineNumber ){
			log.globalStyle = 'currentLine';
			log.registerStyle('lineNumber', 'currentLineNumber');
			log.registerStyle('lineSource', 'currentLineSource');
		}

		return {
			lineNumber: minLine + index + 1,
			lineSource: line
		};
	});

	return source;
}

function handleFailure(logger, error){
	if( error.name == 'AssertionError' ){
		if( error.type == 'equal' ){
			error.message = error.args[0] + ' not equal to ' + error.args[1];
		}

		var source = createErrorSourceLog(error.file, error.line);

		logger.error('{stack}\n{path}\n{source}', {
			message: error.message,
			stack: error.stack,
			path: error.file,
			source: source
		});
	}
	else{
		logger.error(error.stack);
	}
}

var proto = require('proto');
var TestReporter = proto.create({
	constructor: function(test, listener, bind, watch){
		this.test = test;
		this.task = null;

		if( typeof listener == 'function' ){
			if( watch ) this.enableFileWatch();
			this.listener = listener;
			this.bind = bind;
		}
		else{
			var logger;
			if( LogStream.isPrototypeOf(listener) ){
				logger = listener;
			}
			else{
				logger = new LogStream();
			}			

			if( !bind ) this.enableFileWatch();

			this.logger = logger;			
			this.listener = function(error, meta){
				if( error ){
					handleFailure(this.logger, error);
				}
				else{
					// changer le message selon le type de test
					this.logger.info(
						'{count} modules tested in {duration}ms ({loadDuration}ms loading, {execDuration}ms testing)', 
						{
							count: meta.moduleMetas.length,
							duration: meta.duration,
							loadDuration: meta.loadDuration,
							execDuration: meta.execDuration
						}
					);
				}
			};
			this.bind = this;
		}

		this.start();
	},

	moduleChangeReaction: function(moduleTest){
		console.log(moduleTest.path + ' module modified');
		delete require.cache[moduleTest.path];
		this.restart();
	},

	fileChangeReaction: function(testFile){
		console.log(testFile.path + ' file modified');
		delete require.cache[testFile.path];
		this.restart();
	},

	enableFileWatch: function(){
		if( this.test.type === 'folder' ){
			this.test.moduleChangeReaction = this.moduleChangeReaction.bind(this);
			this.test.fileChangeReaction = this.fileChangeReaction.bind(this);
		}
		else if( this.test.type === 'module' ){
			this.test.changeReaction = this.moduleChangeReaction.bind(this);
			this.test.fileChangeReaction = this.fileChangeReaction.bind(this);
		}
		else if( this.test.type === 'file' ){
			this.test.changeReaction = this.fileChangeReaction.bind(this);
		}
	},

	onresolve: function(meta){
		this.listener.call(this.bind, null, meta);
	},

	onreject: function(error){
		if( !error ) error = new Error('rejected task without error');
		this.listener.call(this.bind, error);
	},

	start: function(){
		this.task = this.test.test();
		this.task.then(this.onresolve.bind(this), this.onreject.bind(this));
	},

	restart: function(){
		if( this.task.isPending() ) this.task.cancel();
		
		// avoid to recall restart when file is modified
		this.test.moduleChangeReaction = null;
		this.test.fileChangeReaction = null;
		this.test.changeReaction = null;
		// reset test metas and other stuff
		this.test.reset();

		this.start();
	}
});

var runner = require('./TestRunner');
var nodetest = {
	testFolder: function(path, fn, bind, watch){
		path = require('path').resolve(path, process.cwd());
		return new TestReporter(runner.testFolder(path), fn, bind, watch);
	},

	testModule: function(path, fn, bind, watch){
		path = require.resolve(path);
		return new TestReporter(runner.testModule(path), fn, bind, watch);
	},

	testFile: function(path, module, fn, bind){

	},

	test: function(test, module, fn, bind){

	}
};

module.exports = nodetest;