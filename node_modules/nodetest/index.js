/*
var nodetest = require('nodetest');

node_modules/
	Iterator/
		index.js
		Iterator.js <- n'est pas considéré comme un module à tester

Comme on le voit ci-dessus Iterator.js n'est pas un ModuleTest, et c'est normal il n'a aucun test
qui lui est spécifiquement destiné
soit il faudrais considérer Iterator-test.js comme un test associé
soit il faudrait ques test/iterator.js lui soit destiné
soit on l'ignore mais par contre  lorsqu'il est modifié il faudrais tout restart
puisque index.js dépend de Iterator.js (potentiellement il faudrais le vérifier)

on a besoin de redémarrer lorsqu'un enfant du module est modifié
je pense qu'il faudrais considérer Iterator.js comme un module
il faut modifier FileCollector pour qu'il regarde si le module est le module principal du dossier
ou tout simplement collecter Iterator-test.js ou Iterator.test ou Iterator-test/ tout fichier ici
et voilààà

*/

var LineTemplate = '{lineNumber} {lineSource}';
var LineSeparator = '\n';
var LineStyles = {
	lineNumber: 'grey',
	lineSource: 'grey',
	currentLineNumber: 'white',
	currentLineSource: 'white',
	currentLine: 'bg-yellow'
};
var ConsoleTemplate = require('LogStream/Log/ConsoleTemplate');

var LineTemplate = new ConsoleTemplate(LineTemplate);
LineTemplate.registerStyles(LineStyles);

var LogStream = require('LogStream');

function createErrorSourceLog(file, lineNumber){
	lineNumber = lineNumber - 1;

	// cannot read file out of the working directory
	if( file.indexOf(require('path').sep) === -1 ){
		return 'node native code';
	}

	var lines = require('fs').readFileSync(file, 'utf8').split(/\r?\n/);
	var contextDepth = 2;
	var minLine = Math.max(lineNumber - contextDepth, 0);
	var maxLine = Math.min(lineNumber + contextDepth, lines.length);
	
	lines = lines.slice(minLine, maxLine);

	var source = LineTemplate.repeat(lines, LineSeparator, function(line, index, log, array){
		if( minLine + index == lineNumber ){
			log.globalStyle = 'currentLine';
			log.registerStyle('lineNumber', 'currentLineNumber');
			log.registerStyle('lineSource', 'currentLineSource');
		}

		return {
			lineNumber: minLine + index + 1,
			lineSource: line
		};
	});

	return source;
}

function handleFailure(logger, error){
	if( error.name == 'AssertionError' ){
		if( error.type == 'equal' ){
			error.message = error.args[0] + ' not equal to ' + error.args[1];
		}

		var source = createErrorSourceLog(error.file, error.line);

		logger.error('{stack}\n{path}\n{source}', {
			message: error.message,
			stack: error.stack,
			path: error.file,
			source: source
		});
	}
	else{
		logger.error(error.stack);
	}
}

var proto = require('proto');
var TestReporter = proto.create({
	constructor: function(test, listener, bind, watch){
		this.test = test;
		this.task = null;

		if( typeof listener == 'function' ){
			if( watch ) this.enableFileWatch();
			this.listener = listener;
			this.bind = bind;
		}
		else{
			var logger;
			if( LogStream.isPrototypeOf(listener) ){
				logger = listener;
			}
			else{
				logger = new LogStream();
			}			

			if( !bind ) this.enableFileWatch();

			this.logger = logger;			
			this.listener = function(error, meta){
				if( error ){
					handleFailure(this.logger, error);
				}
				else{
					var message = '{count} modules tested in {duration}ms';
					message+= ' (find: {findDuration}, load: {loadDuration}, require: {requireDuration}, test: {execDuration})';

					// changer le message selon le type de test
					this.logger.info(
						message, 
						{
							count: meta.moduleMetas.length,
							duration: meta.duration,
							findDuration: meta.findDuration,
							loadDuration: meta.loadDuration,
							requireDuration: meta.requireDuration,
							execDuration: meta.execDuration
						}
					);
				}
			};
			this.bind = this;
		}

		this.start();
	},

	moduleChangeReaction: function(moduleTest){
		console.log(moduleTest.path + ' module modified');
		// require('module-util').uncache(moduleTest.path);
		delete require.cache[moduleTest.path];
		this.restart();
	},

	fileChangeReaction: function(testFile){
		console.log(testFile.path + ' file modified');
		delete require.cache[testFile.path];
		this.restart();
	},

	enableFileWatch: function(){
		if( this.test.type === 'folder' ){
			this.test.moduleChangeReaction = this.moduleChangeReaction.bind(this);
			this.test.fileChangeReaction = this.fileChangeReaction.bind(this);
		}
		else if( this.test.type === 'module' ){
			this.test.changeReaction = this.moduleChangeReaction.bind(this);
			this.test.fileChangeReaction = this.fileChangeReaction.bind(this);
		}
		else if( this.test.type === 'file' ){
			this.test.changeReaction = this.fileChangeReaction.bind(this);
		}
	},

	onresolve: function(meta){
		this.listener.call(this.bind, null, meta);
	},

	onreject: function(error){
		if( !error ) error = new Error('rejected task without error');
		this.listener.call(this.bind, error);
	},

	start: function(){
		this.task = this.test.test();
		this.task.then(this.onresolve.bind(this), this.onreject.bind(this));
	},

	restart: function(){
		if( this.task.isPending() ) this.task.cancel();
		
		// avoid to recall restart when file is modified
		this.test.moduleChangeReaction = null;
		this.test.fileChangeReaction = null;
		this.test.changeReaction = null;
		// reset test metas and other stuff
		this.test.reset();

		this.start();
	}
});

var runner = require('./TestRunner');
var nodetest = {
	testFolder: function(path, fn, bind, watch){
		path = require('path').resolve(process.cwd(), path);
		return new TestReporter(runner.testFolder(path), fn, bind, watch);
	},

	testModule: function(path, fn, bind, watch){
		path = require.resolve(path);
		return new TestReporter(runner.testModule(path), fn, bind, watch);
	},

	testFile: function(path, module, fn, bind){

	},

	test: function(test, module, fn, bind){

	}
};

module.exports = nodetest;