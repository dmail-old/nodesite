/*

Lorsqu'il n'y a pas de test Ã  faire, ne pas affiche le tableau

*/

require('Profile');
var debug = require('debug');

var LineTemplate = '{lineNumber} {lineSource}';
var LineSeparator = '\n';
var LineStyles = {
	lineNumber: 'grey',
	lineSource: 'grey',
	currentLineNumber: 'white',
	currentLineSource: 'white',
	currentLine: 'bg-yellow'
};
var ConsoleTemplate = require('LogStream/Log/ConsoleTemplate');

var LineTemplate = new ConsoleTemplate(LineTemplate);
LineTemplate.registerStyles(LineStyles);

var LogStream = require('LogStream');

function createErrorSourceLog(file, lineNumber){
	lineNumber = lineNumber - 1;

	// cannot read file out of the working directory
	if( file.indexOf(require('path').sep) === -1 ){
		return 'node native code (certainly Promise)';
	}

	var lines = require('fs').readFileSync(file, 'utf8').split(/\r?\n/);
	var contextDepth = 2;
	var minLine = Math.max(lineNumber - contextDepth, 0);
	var maxLine = Math.min(lineNumber + contextDepth, lines.length);

	lines = lines.slice(minLine, maxLine);

	var source = LineTemplate.repeat(lines, LineSeparator, function(line, index, log, array){
		if( minLine + index == lineNumber ){
			log.globalStyle = 'currentLine';
			log.registerStyle('lineNumber', 'currentLineNumber');
			log.registerStyle('lineSource', 'currentLineSource');
		}

		return {
			lineNumber: minLine + index + 1,
			lineSource: line
		};
	});

	return source;
}

function handleFailure(logger, error){
	if( error.name == 'AssertionError' ){
		var stack = error.stack;

		if( error.type == 'equal' ){
			stack = stack.replace(/^.*?\n/, error.args[0] + ' not equal to ' + error.args[1] + '\n');
		}

		var source = createErrorSourceLog(error.file, error.line);

		logger.error('{stack}\n{path}\n{source}', {
			stack: stack,
			path: error.file,
			source: source
		});
	}
	else{
		logger.error(error.stack);
	}
}

var proto = require('proto');

var TestResult = proto.create({
	constructor: function(reporter){
		this.reporter = reporter;
		this.pending = true;
		this.promise = this.reporter.test.test();
		this.promise.then(this.resolve.bind(this), this.reject.bind(this));
	},

	resolve: function(value){
		if( !this.cancelled ){
			this.pending = false;
			this.reporter.onresolve(value);
		}
	},

	reject: function(value){
		if( !this.cancelled ){
			debug('rejected test with', value);
			this.pending = false;
			this.reporter.onreject(value);
		}
	},

	cancel: function(){
		this.cancelled = true;
	}
});

var TestReporter = proto.create({
	profile: !true,
	Table: require('TableTemplate'),

	constructor: function(test, listener, bind, watch){
		this.test = test;

		if( typeof listener == 'function' ){
			this.listener = listener;
			this.bind = bind;
		}
		else{
			var logger;
			if( LogStream.isPrototypeOf(listener) ){
				logger = listener;
			}
			else{
				logger = new LogStream();
			}

			watch = bind;
			this.logger = logger;
			this.listener = function(error, meta){
				if( error ){
					handleFailure(this.logger, error);
				}
				else{
					if( this.profile ) console.profileEnd();
					if( this.test.type === 'folder' ){
						this.handleFolderResult(meta);
					}
					else if( this.test.type === 'module' ){
						this.handleModuleResult(meta);
					}
					else if( this.test.type === 'file' ){
						this.handleFileResult(meta);
					}
					else{
						this.handleTestResult(meta);
					}
				}
			};
			this.bind = this;
		}

		if( watch ) this.enableFileWatch();
		this.start();
	},

	handleFolderResult: function(meta){
		var message = 'Test results of {path} ({duration}ms {count} modules)\n{results}';
		var table = new this.Table();

		table.addRow(['module', 'tests', 'duration']);
		table.addRows(meta.moduleMetas.map(function(meta){
			return [
				meta.path,
				meta.fileMetas.reduce(function(previous, meta){
					return previous + meta.testMetas.length;
				}, 0),
				meta.fileMetas.reduce(function(previous, fileMeta){
					return previous + fileMeta.testMetas.reduce(function(prev, testMeta){
						return prev + testMeta.duration;
					}, 0);
				}, 0)
			];
		}));

		table.column(0).format(function(path){
			return path.slice(meta.path.length);
		});
		table.column('duration').format(function(value){
			return value + 'ms';
		});
		table.row(0).fix().setClass('header');

		this.logger.info(message, {
			path: meta.path,
			duration: meta.duration,
			count: meta.moduleMetas.length,
			results: table.toString()
		});
	},

	handleModuleResult: function(meta){
		// if meta.fileMetas.length === 0 return this.handleFileResult(meta.fileMetas[0]);

		var message = 'Module test results {path} ({duration}ms {count} files)\n{results}';
		var table = new this.Table();

		table.addRow(['file', 'tests', 'duration']);
		table.addRows(meta.fileMetas.map(function(meta){
			return [
				meta.path,
				meta.testMetas.length,
				meta.duration
			];
		}));
		table.setColumnFormat(0, function(path){
			return path.slice(meta.path.length);
		});
		table.setRowClass(0, 'header');

		this.logger.info(message, {
			path: meta.path,
			duration: meta.duration,
			count: meta.fileMetas.length,
			results: table.toString()
		});
	},

	handleFileResult: function(meta){
		var message = 'File test results {path} ({duration}ms {count} tests)\n{results}';
		var table = new this.Table();

		table.addRow(['test', 'assertions', 'duration']);
		table.addRows(meta.testMetas.map(function(meta){
			return [
				meta.description,
				meta.assertionCount,
				meta.duration
			];
		}));
		table.setColumnFormat(0, function(path){
			return path.slice(meta.path.length);
		});
		table.setRowClass(0, 'header');

		this.logger.info(message, {
			path: meta.path,
			duration: meta.duration,
			count: meta.testMetas.length,
			results: table.toString()
		});
	},

	handleTestResult: function(meta){
		var message = 'Test {description} passed in ({duration}ms {count} assertions)';

		this.logger.info(message, {
			description: meta.description,
			duration: meta.duration,
			count: meta.assertionCount
		});
	},

	moduleChangeReaction: function(moduleTest){
		console.log(moduleTest.path + ' module modified');
		// require('module-util').uncache(moduleTest.path);
		delete require.cache[moduleTest.path];
		delete moduleTest.util.cache[moduleTest.path];
		this.restart();
	},

	fileChangeReaction: function(testFile){
		console.log(testFile.path + ' file modified');
		delete require.cache[testFile.path];
		this.restart();
	},

	enableFileWatch: function(){
		if( this.test.type === 'folder' ){
			this.test.moduleChangeReaction = this.moduleChangeReaction.bind(this);
			this.test.fileChangeReaction = this.fileChangeReaction.bind(this);
		}
		else if( this.test.type === 'module' ){
			this.test.changeReaction = this.moduleChangeReaction.bind(this);
			this.test.fileChangeReaction = this.fileChangeReaction.bind(this);
		}
		else if( this.test.type === 'file' ){
			this.test.changeReaction = this.fileChangeReaction.bind(this);
		}
	},

	onresolve: function(meta){
		this.listener.call(this.bind, null, meta);
	},

	onreject: function(error){
		if( !error ) error = new Error('rejected task without error');
		this.listener.call(this.bind, error);
	},

	start: function(){
		if( this.profile ) console.profile();
		this.result = new TestResult(this);
	},

	restart: function(){
		this.result.cancel();

		// avoid to recall restart when file is modified
		this.test.moduleChangeReaction = null;
		this.test.fileChangeReaction = null;
		this.test.changeReaction = null;
		// reset test metas and other stuff
		this.test.reset();

		this.start();
	}
});

var runner = require('./TestRunner');
var nodetest = {
	testFolder: function(path, fn, bind, watch){
		path = require('path').resolve(process.cwd(), path);
		return new TestReporter(runner.testFolder(path), fn, bind, watch);
	},

	testModule: function(path, fn, bind, watch){
		path = require.resolve(path);
		return new TestReporter(runner.testModule(path), fn, bind, watch);
	},

	testFile: function(path, module, fn, bind){

	},

	test: function(test, module, fn, bind){

	}
};

module.exports = nodetest;