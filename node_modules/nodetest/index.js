/*
var nodetest = require('nodetest');

nodetest.testModule('es6'); // log in the console
nodetest.testModule('es6', logger); // log using logger
nodetest.testModule('es6', function(error, duration){
	// do something with error / duration
});
nodetest.testModuleRecursive('es6');

*/

var LineTemplate = '{lineNumber} {lineSource}';
var LineSeparator = '\n';
var LineStyles = {
	lineNumber: 'grey',
	lineSource: 'grey',
	currentLineNumber: 'white',
	currentLineSource: 'white',
	currentLine: 'bg-yellow'
};
var ConsoleTemplate = require('LogStream/Log/ConsoleTemplate');
var stackTrace = require('stackTrace');

var LineTemplate = new ConsoleTemplate(LineTemplate);
LineTemplate.registerStyles(LineStyles);

var LogStream = require('LogStream');

function createSourceLogFromCall(call){
	var file = call.getFileName();
	var line = call.getLineNumber() -1;

	// cannot read file out of the working directory
	if( file.indexOf(path.sep) === -1 ){
		return 'node native code';
	}

	var lines = require('fs').readFileSync(file, 'utf8').split(/\r?\n/);
	var contextDepth = 5;
	var minLine = Math.max(line - contextDepth, 0);
	var maxLine = Math.min(line + contextDepth, lines.length);
	
	lines = lines.slice(minLine, maxLine);

	var source = LineTemplate.repeat(lines, LineSeparator, function(index, lines, log){
		if( minLine + index == line ){
			log.globalStyle = 'currentLine';
			log.registerStyle('lineNumber', 'currentLineNumber');
			log.registerStyle('lineSource', 'currentLineSource');
		}

		return {
			lineNumber: minLine + index + 1,
			lineSource: lines[index]
		};
	});

	return source;
}

function handleFailure(logger, error){
	if( !error.stack ) return logger.error(error.stack); // max stack error
	
	var source, traces, call, path = error.fileName;

	traces = stackTrace.parse(error);

	if( !traces ) return logger.error(error.stack);

	call = stackTrace.findCallByFile(traces, path);

	if( !call ) return logger.error(error.stack);

	source = createSourceLogFromCall(call);

	if( error.name == 'AssertionError' ){
		if( error.type == 'equal' ){
			error.message = error.args[0] + ' not equal to ' + error.args[1];
		}
	}

	logger.error('{stack}\n{path}\n{source}', {
		message: error.message,
		stack: error.stack,
		path: path,
		source: source
	});
}

var nodetest = {
	TestLoader: require('./TestLoader'),
	ModuleTestSerie: require('./ModuleTestSerie'),
	fn: null,
	bind: null,

	createRecursiveModuleTest: function(path){
		var test = this.ModuleTestSerie.new(path);
		return test;
	},

	createTestRunner: function(test, args){
		var runner = this.TestRunner.new();

		if( false && args[1] === true ){
			runner.observeModuleFiles = true;
			runner.observeTestFiles = true;
		}

		if( typeof args[0] === 'function'){
			var fn = args[0], bind = args[1];

			runner.onerror = function(e){
				fn.call(bind, e);
			};
			runner.onend = function(){
				fn.call(bind);
			};
		}
		else{
			var logger;
			if( args[0] == null ){
				logger = new LogStream();
				logger.registerStyles({
					path: 'magenta'
				});
			}
			else if( LogStream.isPrototypeOf(args[0]) ){
				logger = args[0];
			}
			else{
				throw new TypeError('logStream or null expected');
			}

			runner.onerror = function(e){
				handleFailure(logger, e);
			};
			runner.oncollect = function(duration){
				logger.info('{count} module found for tests in {duration}', {
					count: this.test.length,
					loadDuration: duration
				});
			};
			runner.onload = function(duration){
				logger.info('{count} tests loaded in {loadDuration}', {
					count: this.test.count,
					loadDuration: duration
				});
			};
			runner.onmodulechange = function(module){
				logger.info('{path} module modified', module.path);
			};
			runner.onfilechange = function(file){
				logger.info('{path} file modified', module.path);
			};
			runner.onend = function(e){
				var message;

				if( test.type === 'moduleSerie' ){
					message = '{count} module tested into {path} in {duration} ms';					
				}
				else if( test.type === 'module' ){
					message = '{count} tests passed for {path} module in {duration} ms';
				}
				else{ // file type
					message = '{count} tests passed for {path} testfile in {duration} ms';
				}

				logger.info(message, test);
			};			
		}
	},

	testModuleRecursive: function(path){
		var test = this.createRecursiveModuleTest(path);
		var runner = this.createTestRunner(test, Array.prototype.slice.call(arguments, 1));
		runner.run();
	}
};

module.exports = nodetest;