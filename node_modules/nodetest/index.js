/*
var nodetest = require('nodetest');

il faut restaurer le fait que assertionError affiche la source d'où provient l'erreur

*/

var LineTemplate = '{lineNumber} {lineSource}';
var LineSeparator = '\n';
var LineStyles = {
	lineNumber: 'grey',
	lineSource: 'grey',
	currentLineNumber: 'white',
	currentLineSource: 'white',
	currentLine: 'bg-yellow'
};
var ConsoleTemplate = require('LogStream/Log/ConsoleTemplate');

var LineTemplate = new ConsoleTemplate(LineTemplate);
LineTemplate.registerStyles(LineStyles);

var LogStream = require('LogStream');

function createErrorSourceLog(file, lineNumber){
	lineNumber = lineNumber - 1;

	// cannot read file out of the working directory
	if( file.indexOf(require('path').sep) === -1 ){
		return 'node native code';
	}

	var lines = require('fs').readFileSync(file, 'utf8').split(/\r?\n/);
	var contextDepth = 5;
	var minLine = Math.max(lineNumber - contextDepth, 0);
	var maxLine = Math.min(lineNumber + contextDepth, lines.length);
	
	lines = lines.slice(minLine, maxLine);

	var source = LineTemplate.repeat(lines, LineSeparator, function(line, index, log, array){
		if( minLine + index == lineNumber ){
			log.globalStyle = 'currentLine';
			log.registerStyle('lineNumber', 'currentLineNumber');
			log.registerStyle('lineSource', 'currentLineSource');
		}

		return {
			lineNumber: minLine + index + 1,
			lineSource: line
		};
	});

	return source;
}

function handleFailure(logger, error){
	if( error.name == 'AssertionError' ){
		if( error.type == 'equal' ){
			error.message = error.args[0] + ' not equal to ' + error.args[1];
		}

		var source = createErrorSourceLog(error.file, error.line);

		logger.error('{stack}\n{path}\n{source}', {
			message: error.message,
			stack: error.stack,
			path: error.file,
			source: source
		});
	}
	else{
		logger.error(error.stack);
	}
}

function thenCall(task, fn, bind){
	return task.then(
		function(result){
			fn.call(bind, null, result);
		},
		function(error){
			if( !error ) error = new Error('rejected task without error');
			fn.call(bind, error);
		}
	);
}

function thenLog(task, logger){
	return task.then(
		function(result){
			var message = '{count} module tested in {duration} ms';
			logger.info(message, result);				
		},
		function(error){
			handleFailure(logger, error);
		}
	);
}

/*
testFolder lancé dans le même process

module changed -> relance les tests du folder
file changed -> relance les tests ce fichier

testModule lancé dans le même process

module changed -> relance les tests pour ce module
file changed -> relance les tests pour ce fichier

testFolder lancé comme childProcess
module changed -> 

ok dans tout les cas ça ne change rien mais
faut faire ça

*/

var runner = require('./TestRunner');
var nodetest = {
	testFolder: function(path, fn, bind){
		path = require('path').resolve(path, process.cwd());
		var task = runner.testFolder(path);

		if( typeof fn === 'function' ){
			thenCall(task, fn, bind);
		}
		else if( LogStream.isPrototypeOf(fn) ){
			thenLog(task, fn);
		}
		// log to the console
		else{
			thenLog(task, new LogStream());
		}

		return task;
	},

	testModule: function(path, fn, bind){
		path = require.resolve(path);
		var task = runner.testModule(path);

		if( typeof fn === 'function' ){
			thenCall(task, fn, bind);
		}
		else if( LogStream.isPrototypeOf(fn) ){
			thenLog(task, fn);
		}
		else{
			thenLog(task, new LogStream());
		}

		return task;
	}
};

module.exports = nodetest;