/*

*/

/*
process.on('uncaughtException', function(e){
	console.log('\n', e.stack, '\n');
	require('fs').appendFileSync('./error.log', e.stack + '\n');
});

setTimeout(function(){}, 1000 * 60 * 10);
*/

var path = require('path');
var appPath = path.resolve(process.cwd(), process.argv[2]/*path.normalize(process.argv[2])*/);
var ModuleTestSerie = require('./ModuleTestSerie');
var appTest = ModuleTestSerie.new(appPath);

var LineLogTemplate = '{lineNumber} {lineSource}';
var LineLogSeparator = '\n';
var LineLogStyles = {
	lineNumber: 'grey',
	currentLineNumber: 'white',
	currentLineSource: 'white',
	currentLine: 'bg-yellow'
};

var LogStream = require('LogStream');
var logger = LogStream.new();
var Log = LogStream.Log;

logger.Log.registerStyles({
	path: 'magenta'
});

var LineLog = Log.new(LineLogTemplate, null).registerStyles(LineLogStyles);
var stackTrace = require('stackTrace');

function createSourceLogFromCall(call){
	var file = call.getFileName();
	var line = call.getLineNumber() -1;
	var lines = require('fs').readFileSync(file, 'utf8').split(/\r?\n/);
	var contextDepth = 7;
	var minLine = Math.max(line - contextDepth, 0);
	var maxLine = Math.min(line + contextDepth, lines.length);
	
	lines = lines.slice(minLine, maxLine);

	var source = LineLog.repeat(lines, LineLogSeparator, function(log, index, lines){
		log.exec({
			lineNumber: minLine + index,
			lineSource: lines[index]
		});		

		if( minLine + index == line ){
			log.globalStyle = 'currentLine';
			log.registerStyle('lineNumber', 'currentLineNumber');
		}

		return log;
	});

	return source;
}

function handleFailure(error){
	var source, traces;

	if( error.name == 'AssertionError' ){
		if( error.type == 'equal' ){
			error.message = error.args[0] + ' not equal to ' + error.args[1];
		}

		traces = stackTrace.parse(error);
		var call = stackTrace.findCallByFile(traces, error.fileTest.path);
		source = createSourceLogFromCall(call);

		logger.error('{message} in {path}\n{source}', {
			message: error.message,
			path: error.fileTest.path,
			source: source
		});
	}
	else if( true ){
		traces = stackTrace.parse(error);
		if( traces.length === 0 ){
			throw error;
		}

		source = createSourceLogFromCall(stackTrace.parse(error)[0]);

		logger.error('{test}\n\n{stack}\n\n{source}', {
			test: error.test.name,
			stack: error.stack,
			source: source
		});
	}
	else{
		logger.error('{stack}', error.stack);	
	}
}

function handleResult(e){
	if( e ){
		handleFailure(e);
	}
	else{
		logger.info('All tests passed in {duration} ms', this);
	}
}

// lorsque les fichiers sont modifiés, les tests sont relancés
if( !true ){
	appTest.observe(function(test){
		if( test.type == 'file' ){
			logger.info('{path} test modified', test.path);
		}
		else{
			logger.info('{path} module modified', test.path);
		}

		test.reload();
		test.restart(handleResult, test);
	});
}

appTest.load(function(e){
	if( e ){
		logger.error('Tests loading failed \n {stack}', e);
	}
	else{
		logger.info('tests loaded in {loadDuration} ms', appTest);
		appTest.start(handleResult, appTest);
	}	
});