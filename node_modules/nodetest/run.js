/*

Idealement, ceci est un stream qui écrit soit que les tests se passent bien
soit qu'une erreur survient

on devrait donc attendre un writableStream et pouvoir le passer comme argument

TODO On observe les tests que lorsqu'ils ont réussi, si un test contient une erreur et est modifié
les tests ne sont pas relancés !

*/

var path = require('path');
var appPath = path.resolve(process.cwd(), process.argv[2]/*path.normalize(process.argv[2])*/);

require('net').createServer().listen(); //process.stdin.resume(); // keep process alive

var LineTemplate = '{lineNumber} {lineSource}';
var LineSeparator = '\n';
var LineStyles = {
	lineNumber: 'grey',
	lineSource: 'grey',
	currentLineNumber: 'white',
	currentLineSource: 'white',
	currentLine: 'bg-yellow'
};
var ConsoleTemplate = require('LogStream/Log/ConsoleTemplate');
var stackTrace = require('stackTrace');

var LineTemplate = new ConsoleTemplate(LineTemplate);
LineTemplate.registerStyles(LineStyles);

var LogStream = require('LogStream');

var logger = new LogStream();

logger.registerStyles({
	path: 'magenta'
});

function createSourceLogFromCall(call){
	var file = call.getFileName();
	var line = call.getLineNumber() -1;

	// cannot read file out of the working directory
	if( file.indexOf(path.sep) === -1 ){
		return 'node native code';
	}

	var lines = require('fs').readFileSync(file, 'utf8').split(/\r?\n/);
	var contextDepth = 5;
	var minLine = Math.max(line - contextDepth, 0);
	var maxLine = Math.min(line + contextDepth, lines.length);
	
	lines = lines.slice(minLine, maxLine);

	var source = LineTemplate.repeat(lines, LineSeparator, function(index, lines, log){
		if( minLine + index == line ){
			log.globalStyle = 'currentLine';
			log.registerStyle('lineNumber', 'currentLineNumber');
			log.registerStyle('lineSource', 'currentLineSource');
		}

		return {
			lineNumber: minLine + index + 1,
			lineSource: lines[index]
		};
	});

	return source;
}

function handleFailure(error){
	if( !error.stack ) return logger.error(error.stack); // max stack error
	
	var source, traces, call, path = error.test.parent.path;

	traces = stackTrace.parse(error);

	if( !traces ) return logger.error(error.stack);

	call = stackTrace.findCallByFile(traces, path);

	if( !call ) return logger.error(error.stack);

	source = createSourceLogFromCall(call);

	if( error.name == 'AssertionError' ){
		if( error.type == 'equal' ){
			error.message = error.args[0] + ' not equal to ' + error.args[1];
		}
	}

	logger.error('{stack}\n{path}\n{source}', {
		message: error.message,
		stack: error.stack,
		path: path,
		source: source
	});
}

function handleResult(e){
	if( e ){
		handleFailure(e);
	}
	else{
		logger.info('{count} tests passed for {moduleCount} modules in {duration} ms', {
			count: this.test.count,
			moduleCount: this.test.length,
			duration: this.test.duration
		});
	}
}

function handleRestartResult(e){
	if( e ){
		handleFailure(e);
	}
	else{
		logger.info('{count} tests passed for {module} in {duration} ms', {
			count: this.count,
			module: this.type == 'file' ? this.parent.path : this.path,
			duration: this.duration
		});
	}
}

var runner = {
	ModuleTestSerie: require('./ModuleTestSerie'),
	fn: null,
	bind: null,

	load: function(path, fn, bind){
		this.path = path;
		this.fn = fn;
		this.bind = bind;
		this.test = this.ModuleTestSerie.new(this.path);
		this.test.load(function(error, duration){
			fn.call(bind, error, duration);
		});
	},

	observeModuleFiles: function(){
		// lorsqu'un module est modifié, on le recharge (pas depuis le cache)
		// si le chargement échoue on log l'erreur et on attend une autre modif
		// si le chargement est ok on le met à jour
		// si des tests sont en cours on attends la fin des tests pour les relancer
		// sinon on relance direct

		var moduleTest;

		moduleTest.restartAsap(function(done){
			logger.info('{path} module modified', moduleTest.path);
			// pas besoin de faire moduleTest.load() car les tests n'ont pas besoin d'être recréé
			delete require.cache[moduleTest.path];
			require(moduleTest.path);
			moduleTest.module = require.cache[moduleTest.path];
			done();
		});
	},

	observerTestFiles: function(){
		// lorsqu'un test est modifié, même chose que pour un module à peu de chose près

		var fileTest;

		fileTest.restartAsap(function(done){
			logger.info('{path} test modified', fileTest.path);
			delete require.cache[fileTest.path];
			fileTest.load();
			done();
		});
	}
};

runner.load(appPath, function(e){
	if( e ){
		logger.error('nodetest load failed \n {stack}', e.stack);
	}
	else{
		logger.info('{count} tests loaded for {moduleCount} modules in {duration} ms', {
			count: runner.test.count,
			moduleCount: runner.test.length,
			duration: runner.test.loadDuration
		});
		
		if( !true ){
			runner.observeModuleFiles();
			runner.observerTestFiles();
		}

		runner.test.start(handleResult, runner);
	}	
});