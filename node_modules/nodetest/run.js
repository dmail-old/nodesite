/*

Idealement, ceci est un stream qui écrit soit que les tests se passent bien
soit qu'une erreur survient

on devrait donc attendre un writableStream et pouvoir le passer comme argument

*/

var path = require('path');
var appPath = path.resolve(process.cwd(), process.argv[2]/*path.normalize(process.argv[2])*/);
var ModuleTestSerie = require('./ModuleTestSerie');
var appTest = ModuleTestSerie.new(appPath);

require('net').createServer().listen(); //process.stdin.resume(); // keep process alive

var LineLogTemplate = '{lineNumber} {lineSource}';
var LineLogSeparator = '\n';
var LineLogStyles = {
	lineNumber: 'grey',
	lineSource: 'grey',
	currentLineNumber: 'white',
	currentLineSource: 'white',
	currentLine: 'bg-yellow'
};

var LogStream = require('LogStream');
var logger = LogStream.new();
var Log = LogStream.Log;

logger.Log.registerStyles({
	path: 'magenta'
});

var LineLog = Log.new(LineLogTemplate, null).registerStyles(LineLogStyles);
var stackTrace = require('stackTrace');

function createSourceLogFromCall(call){
	var file = call.getFileName();
	var line = call.getLineNumber() -1;

	// cannot read file out of the working directory
	if( file.indexOf(path.sep) === -1 ){
		return 'node native code';
	}

	var lines = require('fs').readFileSync(file, 'utf8').split(/\r?\n/);
	var contextDepth = 5;
	var minLine = Math.max(line - contextDepth, 0);
	var maxLine = Math.min(line + contextDepth, lines.length);
	
	lines = lines.slice(minLine, maxLine);

	var source = LineLog.repeat(lines, LineLogSeparator, function(log, index, lines){
		log.exec({
			lineNumber: minLine + index + 1,
			lineSource: lines[index]
		});

		if( minLine + index == line ){
			log.globalStyle = 'currentLine';
			log.registerStyle('lineNumber', 'currentLineNumber');
			log.registerStyle('lineSource', 'currentLineSource');
		}

		return log;
	});

	return source;
}

function handleFailure(error){
	if( !error.stack ) throw error; // max stack error
	
	var source, traces, call, path = error.test.parent.path;

	traces = stackTrace.parse(error);

	if( !traces ) throw error;

	call = stackTrace.findCallByFile(traces, path);

	if( !call ) throw error;

	source = createSourceLogFromCall(call);

	if( error.name == 'AssertionError' ){
		if( error.type == 'equal' ){
			error.message = error.args[0] + ' not equal to ' + error.args[1];
		}
	}

	logger.error('{stack}\n{path}\n{source}', {
		message: error.message,
		stack: error.stack,
		path: path,
		source: source
	});
}

function handleResult(e){
	if( e ){
		handleFailure(e);
	}
	else{
		logger.info('{count} tests passed for {moduleCount} modules in {duration} ms', {
			count: this.count,
			moduleCount: this.tests.length,
			duration: this.duration
		});
	}
}

function handleRestartResult(e){
	if( e ){
		handleFailure(e);
	}
	else{
		logger.info('{count} tests passed for {module} in {duration} ms', {
			count: this.count,
			module: this.type == 'file' ? this.parent.path : this.path,
			duration: this.duration
		});
	}
}

appTest.load(function(e, ms){
	if( e ){
		logger.error('nodetest load failed \n {stack}', e);
	}
	else{
		logger.info('{count} tests loaded for {moduleCount} modules in {duration} ms', {
			count: appTest.count,
			moduleCount: appTest.tests.length,
			duration: appTest.loadDuration
		});
		
		if( true ){
			// this listener is called when a module/test file is modified and the test wasn't running
			appTest.observe(function(test){
				if( test.running ){
					test.changed = true;
				}
				else{
					if( test.type == 'file' ){
						logger.info('{path} test modified', test.path);
					}
					else{
						logger.info('{path} module modified', test.path);
					}

					test.load();
					test.start(handleRestartResult, test);
				}
			});
		}

		appTest.start(handleResult, appTest);
	}	
});