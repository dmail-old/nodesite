/*

*/

/*
process.on('uncaughtException', function(e){
	console.log('\n', e.stack, '\n');
	require('fs').appendFileSync('./error.log', e.stack + '\n');
});
*/

var path = require('path');
var appPath = path.resolve(process.cwd(), process.argv[2]/*path.normalize(process.argv[2])*/);
var ModuleTestSerie = require('./ModuleTestSerie');
var appTest = ModuleTestSerie.new(appPath);

require('net').createServer().listen(); //process.stdin.resume(); // keep process alive

var LineLogTemplate = '{lineNumber} {lineSource}';
var LineLogSeparator = '\n';
var LineLogStyles = {
	lineNumber: 'grey',
	lineSource: 'grey',
	currentLineNumber: 'white',
	currentLineSource: 'white',
	currentLine: 'bg-yellow'
};

var LogStream = require('LogStream');
var logger = LogStream.new();
var Log = LogStream.Log;

logger.Log.registerStyles({
	path: 'magenta'
});

var LineLog = Log.new(LineLogTemplate, null).registerStyles(LineLogStyles);
var stackTrace = require('stackTrace');

function createSourceLogFromCall(call){
	var file = call.getFileName();
	var line = call.getLineNumber() -1;

	// cannot read file out of the working directory
	if( file.indexOf(path.sep) === -1 ){
		return 'node native code';
	}

	var lines = require('fs').readFileSync(file, 'utf8').split(/\r?\n/);
	var contextDepth = 5;
	var minLine = Math.max(line - contextDepth, 0);
	var maxLine = Math.min(line + contextDepth, lines.length);
	
	lines = lines.slice(minLine, maxLine);

	var source = LineLog.repeat(lines, LineLogSeparator, function(log, index, lines){
		log.exec({
			lineNumber: minLine + index,
			lineSource: lines[index]
		});		

		if( minLine + index == line ){
			log.globalStyle = 'currentLine';
			log.registerStyle('lineNumber', 'currentLineNumber');
			log.registerStyle('lineSource', 'currentLineSource');
		}

		return log;
	});

	return source;
}

function handleFailure(error){
	var source, traces, call;

	if( error.name == 'AssertionError' ){
		if( error.type == 'equal' ){
			error.message = error.args[0] + ' not equal to ' + error.args[1];
		}

		traces = stackTrace.parse(error);
		call = stackTrace.findCallByFile(traces, error.fileTest.path);
		source = createSourceLogFromCall(call);

		logger.error('{message} in {path}\n{source}', {
			message: error.message,
			path: error.fileTest.path,
			source: source
		});
	}
	else if( true ){
		traces = stackTrace.parse(error);
		if( traces.length === 0 ){
			throw error;
		}

		call = traces[0];

		if( !call[0] || !call[0].getFileName() ){
			call = stackTrace.findCallByFile(traces, error.fileTest.path);
			if( !call ) throw error;
		}

		source = createSourceLogFromCall(call);

		logger.error('{stack}\n{path}:{line}\n{source}', {			
			message: error.message,
			path: call.getFileName(),
			line: call.getLineNumber()-1,
			source: source,
			stack: error.stack
		});
	}
	else{
		logger.error('{stack}', error.stack);	
	}
}

function handleResult(e){
	if( e ){
		handleFailure(e);
	}
	else{
		logger.info('All tests passed in {duration} ms', this);
	}
}

appTest.load(function(e, ms){
	if( e ){
		logger.error('nodetest load failed \n {stack}', e);
	}
	else{
		logger.info('nodetest loaded in {duration} ms', {duration: ms});
		
		if( true ){
			// this listener is called when a module/test file is modified and the test wasn't running
			appTest.observe(function(test){
				if( test.running ){
					test.changed = true;
				}
				else{
					if( test.type == 'file' ){
						logger.info('{path} test modified', test.path);
					}
					else{
						logger.info('{path} module modified', test.path);
					}

					test.load();
					test.start(handleResult, test);
				}
			});
		}

		appTest.start(handleResult, appTest);
	}	
});