/*

maybe add a skip(reason) method a skip the test under some conditions (reason is optionnal)
and a method skipIf(condition, reason)

le test peut être relancé
donc la fonction qu'on apelle à la fin 

*/

var proto = require('proto');

var TestPrototype = proto.create({
	type: 'test',
	name: 'Anonymous test',
	running: false,
	test: null,
	timeout: null,
	startDate: null,
	endDate: null,	
	failed: false,
	lastError: null,
	parent: null,
	restartPending: null,

	constructor: function(test){
		if( arguments.length === 0 ) throw new TypeError('test expected');
		if( typeof test != 'function' ) throw new TypeError('test must be a function');

		this.test = test;
	},

	onerror: function(e){ throw e; },
	onprogress: function(){},
	onend: function(){},
	
	emit: function(name, event){
		if( typeof this['on' + name] === 'function' ) this['on' + name](event);
	},

	// called before calling the test
	setup: function(){
		// noop
	},

	// called when the test has been called
	teardown: function(){
		// noop
	},

	// called to clean stuff when we want to rerun the tests while it was running
	clean: function(){
		if( this.timer != null ){
			clearTimeout(this.timer);
			this.timer = null;
		}
	},

	run: function(){
		return this.test.call(this, this);
	},

	start: function(){
		if( this.running ){
			this.stop();
		}

		this.lastError = null;
		this.running = true;
		this.failed = false;
		this.startDate = new Date();

		try{
			this.setup();
		}
		catch(e){
			return this.fail(e); // during setup (todo: l'indiquer dans lerreur)
		}

		try{
			this.run();
		}
		catch(e){
			return this.fail(e); // during run
		}

		if( typeof this.timeout == 'number' ){
			this.timer = setTimeout(this.onTimeOut.bind(this), this.timeout);
		}

		try{
			this.teardown();
		}
		catch(e){
			return this.fail(e); // during teardown
		}
	},

	// test results are ignored
	stop: function(){
		if( this.running ){
			this.running = false;
			this.clean();
		}
	},

	respond: function(){
		if( this.running === false ){
			if( this.restartPending ){
				this.restartPending.call(this, function(){
					this.start();
				}.bind(this));
			}
			else if( this.failed ){
				this.emit('error', this.lastError);
			}
			else{
				this.emit('end');
			}
		}
	},

	resolve: function(error){
		if( this.running ){
			if( error ){
				this.failed = true;				
				this.lastError = error;
			}

			this.running = false;
			this.endDate = new Date();
			this.clean();
			process.nextTick(this.respond.bind(this));
			//setImmediate(this.respond.bind(this));
		}
	},

	fail: function(error){
		this.resolve(error);
	},

	pass: function(){
		this.resolve();
	},

	createTimeOutError: function(){
		var error = new Error('Test '+ this.name +' is too slow');
		error.code = 'TEST_TIMEOUT';
		return error;
	},

	onTimeOut: function(){
		this.timer = null;
		this.fail(this.createTimeOutError());
	},

	get duration(){
		return this.endDate - this.startDate;
	},

	restartAsap: function(fn){
		if( this.running ){
			this.restartPending = fn;
		}
		else{
			fn.call(this, this.start.bind(this));
		}
	},

	toString: function(){
		return '[object Test]';
	}
});

module.exports = TestPrototype;