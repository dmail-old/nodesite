/*

comment manager moduleChangeReaction et fileChangeReaction?
voir comment différencier les tâche qui échouent des tâche qui réussissent
parce que dans réaction j'ai start et end
je devrait ptet avoir start, resolve (on resolution), reject (onrejection), done (appelé tout le temps)

*/

var proto = require('proto');
var debug = require('debug');
var moduleUtil = require('module-util');
var ModuleTest = require('./moduleTest');

require('promise/map');
require('promise/reduce');
require('promise/mapReduce');

var Task = proto.extend({
	reaction: null,
	canReact: !false,
	name: null,
	state: null,
	startValue: null,
	endValue: null,

	constructor: function(name, exec){
		this.name = name;
		this.exec = exec;
		this.state = 'created';
	},

	react: function(method, value){
		if( this.canReact && this.reaction && method in this.reaction ){
			this.reaction[method].call(this, value);
		}
	},

	start: function(startValue){
		this.startDate = new Date();
		this.startValue = startValue;
		this.react('start', startValue);

		return Promise.resolve(this.exec.call(this, startValue)).then(
			function(endValue){
				this.state = 'passed';
				this.endValue = endValue;
				this.end(endValue);
				return endValue;
			}.bind(this),
			function(endValue){
				this.state = 'failed';
				this.endValue = endValue;
				this.end(endValue);
				return Promise.reject(endValue);
			}.bind(this)
		);
	},

	end: function(endValue){
		this.duration = new Date() - this.startDate;
		this.react('end', endValue);
	},

	progress: function(value){
		this.react('progress', value)
	}
});

var TaskManager = proto.extend.call(Task, {
	reactions: {},
	current: null,

	constructor: function(tasks){
		this.tasks = tasks;
	},

	exec: function(initialValue){
		var manager = this;

		manager.value = initialValue;

		return this.tasks.reduce(function(previous, task){
			return previous.then(function(value){
				//console.log('launching task', task.name);
				manager.task = task;
				manager.value = value;
				task.reaction = manager.reactions[task.name];
				return task.start(value);
			});
		}, Promise.resolve(initialValue));
	}
});

var ModuleCollector = require('module-util/collector');

var FolderTest = proto.extend.call(TaskManager, {
	type: 'folder',
	reactions: {},
	
	constructor: function(path){
		this.path = path;
		this.reset();
	},

	reset: function(){

	},

	exec: function(){
		return TaskManager.exec.call(this, this.path);
	}
});

var tasks = [
	// find modules
	function findModulePaths(path){
		var task = this, collector = ModuleCollector.create(path);
		collector.onmodule = function(path){
			task.progress(path);
		};
		return collector.createPromise();
	},
	// exclude test that sounds like modules byt are not
	function filterTestFiles(modulePaths){
		return modulePaths.filter(function(modulePath){
			return !ModuleTest.FileCollector.isTestFile(modulePath);
		}, this);
	},
	// create module object
	function createModules(modulePaths){
		return modulePaths.map(function(modulePath){
			return ModuleTest.create(modulePath, this.moduleChangeReaction, this.fileChangeReaction);
		}, this);
	},
	// create module tests
	function loadModuleTests(moduleTests){
		var task = this;

		return Promise.mapReduce(moduleTests, function(moduleTest){
			return moduleTest.loadTests().then(function(value){
				task.progress(value);
				return value;
			});
		}).then(function(){
			return moduleTests;
		});
	},
	// filter module without tests
	function filterModules(moduleTests){
		return moduleTests.filter(function(moduleTest){
			return moduleTest.hasTest();
		});
	},
	// require the module
	function loadModules(moduleTests){
		var task = this;

		return Promise.map(moduleTests, function(moduleTest){
			return moduleTest.load().then(function(value){
				task.progress(value);
				return value;
			});
		}).then(function(){
			return moduleTests;
		})
	},
	// sort module by dependency
	function sortModules(moduleTests){
		return moduleTests.sort(function(a, b){
			return moduleUtil.getDependencyLevel(a.module) - moduleUtil.getDependencyLevel(b.module);
		});
	},
	// exec module tests
	function execTests(moduleTests){
		var task = this;

		return Promise.mapReduce(moduleTests, function(moduleTest){
			return moduleTest.execTests().then(function(value){
				task.progress(value);
				return value;
			});
		});
	}
];

FolderTest.tasks = tasks.map(function(task){
	task = Task.create(task.name, task);
	return task;
});

module.exports = FolderTest;