var proto = require('proto');
var debug = require('debug');
var moduleUtil = require('module-util');
var ModuleTest = require('./moduleTest');

require('promise/map');
require('promise/reduce');
require('promise/mapReduce');

var Task = proto.extend({
	reaction: null,
	name: null,

	constructor: function(name, exec){
		this.name = name;
		this.exec = exec;
	},

	start: function(){
		this.startDate = new Date();
		if( this.reaction && this.reaction.start ) this.reaction.start.call(this);

		return this.exec.call(this.bind, this).then(
			function(value){
				this.state = 'passed';
				this.end();
				return value;
			}.bind(this),
			function(value){
				this.state = 'failed';
				this.end();
				return value;
			}.bind(this)
		);
	},

	end: function(){
		this.duration = new Date() - this.startDate;
		if( this.reaction && this.reaction.end ) this.reaction.end.call(this.bind);
	},

	progress: function(){
		if( this.reaction && this.reaction.progress ) this.reaction.progress.apply(this.bind, arguments);
	}
});

var TaskManager = proto.extend.call(Task, {
	reactions: {},

	constructor: function(tasks){
		this.tasks = tasks;
	},

	exec: function(){
		return Promise.reduce(this.tasks);
	}
});

var FolderTest = proto.extend({
	type: 'folder',
	util: moduleUtil,
	ModuleCollector: require('module-util/collector'),
	ModuleTest: ModuleTest,
	moduleChangeReaction: null,
	fileChangeReaction: null,
	moduleTests: [],

	constructor: function(path){
		this.path = path;
		this.reset();
	},

	reset: function(){
		this.state = 'created';
		this.moduleTests = [];
		this.duration = 0;
	},

	toJSON: function(){
		return {
			state: this.state,
			path: this.path,
			moduleTests: this.moduleTests,
			duration: this.duration
		};
	},

	createModuleTest: function(path){
		return this.ModuleTest.create(path, this.moduleChangeReaction, this.fileChangeReaction);
	},

	exec: function(){
		return TaskManager.create(this.tasks).start();
	}
});

var tasks = [
	// find modules
	function findModulePaths(){
		var task = this.current, collector = this.ModuleCollector.create(this.path);
		collector.onmodule = function(path){
			task.progress(path);
		};
		return collector.createPromise();
	},
	// exclude test that sounds like modules byt are not
	function filterTestModules(modulePaths){
		return modulePaths.filter(function(modulePath){
			return !ModuleTest.FileCollector.isTestFile(modulePath);
		}, this);
	},
	// create module object
	function createModules(modulePaths){
		return this.moduleTests = modulePaths.map(this.createModuleTest, this);
	},
	// create module tests
	function loadModuleTests(){
		var task = this.current;

		return Promise.mapReduce(this.moduleTests, function(moduleTest){
			return moduleTest.loadTests().then(function(){
				task.progress(moduleTest.tests);
			});
		});
	},
	// filter module without tests
	function filterModules(){
		return this.moduleTests = this.moduleTests.filter(function(moduleTest){
			return moduleTest.hasTest();
		});
	},
	// require the module
	function loadModules(){
		return Promise.mapReduce(this.moduleTests, function(moduleTest){
			return moduleTest.load();
		});
	},
	// sort module by dependency
	function sortModules(){
		return this.moduleTests = this.moduleTests.sort(function(a, b){
			return this.util.getDependencyLevel(a.module) - this.util.getDependencyLevel(b.module);
		}.bind(this));
	},
	// exec module tests
	function execTests(){
		return Promise.map(this.moduleTests, function(moduleTest){
			return moduleTest.execTests();
		});
	}
];

// un task manager doit connaitre sa tâche en cours
// doit pouvoir réagir à task.start/end/progress

FolderTest.tasks = tasks.map(function(task){
	task = Task.create(task.name, task);
	return task;
});

module.exports = FolderTest;