/*

comment manager moduleChangeReaction et fileChangeReaction?
voir comment différencier les tâche qui échouent des tâche qui réussissent
parce que dans réaction j'ai start et end
je devrait ptet avoir start, resolve (on resolution), reject (onrejection), done (appelé tout le temps)

sinon task c'est un wrapper au promise mais pas une sorte de promise

*/

var proto = require('proto');
var debug = require('debug');
var moduleUtil = require('module-util');
var ModuleTest = require('./moduleTest');

require('promise/map');
require('promise/reduce');
require('promise/mapReduce');

var Task = require('task');
require('task/reduce');
var ModuleCollector = require('module-util/collector');

var FolderTest = proto.extend({
	type: 'folder',
	reactions: {},

	constructor: function(path){
		this.path = path;
		this.reset();
	},

	reset: function(){

	},

	exec: function(){
		this.task = Task.reduce(this.tasks, this.path, this.reactions);
		return this.task.start();
	}
});

FolderTest.tasks = [
	// find modules
	function findModulePaths(path){
		var task = this, collector = ModuleCollector.create(path);
		collector.onmodule = function(path){
			task.progress(path);
		};
		return collector.createPromise();
	},
	// exclude test that sounds like modules byt are not
	function filterTestFiles(modulePaths){
		return modulePaths.filter(function(modulePath){
			return !ModuleTest.FileCollector.isTestFile(modulePath);
		}, this);
	},
	// create module object
	function createModules(modulePaths){
		return modulePaths.map(function(modulePath){
			return ModuleTest.create(modulePath, this.moduleChangeReaction, this.fileChangeReaction);
		}, this);
	},
	// create module tests
	function loadModuleTests(moduleTests){
		var task = this;

		var testLoaders = moduleTests.map(function(moduleTest){
			return moduleTest.loadTests.bind(moduleTest);
		});

		/*
		return Task.reduce(testLoaders, null, this.reaction).promise.then(function(){
			return moduleTests;
		});
*/

		/*
		return Promise.mapReduce(testLoaders, function(executor, index, executors, previous){
			if( index ){
				this.progress(previous);
			}
			this.task = Task.create(executor, previous, this.reactions ? this.reactions[executor.name] : null);
			return this.task.promise;
		}, this, moduleTests);
*/
		return Promise.mapReduce(moduleTests, function(moduleTest){
			return moduleTest.loadTests().then(function(value){
				task.progress(value);
				return value;
			});
		}).then(function(){
			return moduleTests;
		});
	},
	// filter module without tests
	function filterModules(moduleTests){
		return moduleTests.filter(function(moduleTest){
			return moduleTest.hasTest();
		});
	},
	// require the module
	function loadModules(moduleTests){
		var task = this;

		return Promise.map(moduleTests, function(moduleTest){
			return moduleTest.load().then(function(value){
				task.progress(value);
				return value;
			});
		}).then(function(){
			return moduleTests;
		});
	},
	// sort module by dependency
	function sortModules(moduleTests){
		return moduleTests.sort(function(a, b){
			return moduleUtil.getDependencyLevel(a.module) - moduleUtil.getDependencyLevel(b.module);
		});
	},
	// exec module tests
	function execTests(moduleTests){
		var task = this;

		return Promise.mapReduce(moduleTests, function(moduleTest){
			return moduleTest.execTests().then(function(value){
				task.progress(value);
				return value;
			});
		});
	}
];

module.exports = FolderTest;