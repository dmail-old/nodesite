/*

name: Object.cloning
https://gist.github.com/NV/1396086

*/

var References = function(){
	this.objects = [];
	this.values = [];
	this.index = 0;
};

References.prototype = {
	constructor: References,

	has: function(object){
		this.index = this.objects.indexOf(object);
		return this.index != -1;
	},

	add: function(object, value){
		this.objects.push(object);
		this.values.push(value);
	}
};

var exports = {
	enumerator: Object.keys,
	extensibility: false,

	// clone the value only if it's not a reference to a previously cloned object
	cloneValue: function(value, references){
		if( references && references.has(value) ){
			value = references.values[references.index];
		}
		else{
			value = this.cloneProperties(value, references);
		}
		return value;
	},

	assignPropertyClone: function(name, object, references){
		this[name] = exports.cloneValue(object[name], references);
	},

	cloneProperties: function(object, references){
		var target = object;

		if( typeof object === 'object' && object !== null ){
			if( typeof object.clone === 'function' ){
				target = object.clone();
			}
			else{
				if( Object.prototype.toString.call(object) === '[object Array]' ){
					// new Array(object) would work too, a copied array would be returned
					// but elements inside still have to be cloned
					target = new Array(object.length);
				}
				else{
					target = Object.create(Object.getPrototypeOf(object));
				}

				references = references || new References();
				references.add(object, target);

				var names = this.enumerator(object), i = names.length;
				while(i--){
					this.definePropertyClone.call(target, names[i], object, references);
				}

				// only if es5
				if( this.extensibility ){
					if( !Object.isExtensible(object) ) Object.preventExtensions(target);
					if( Object.isSealed(object) ) Object.seal(target);
					if( Object.isFrozen(object) ) Object.freeze(target);
				}
			}
		}

		return target;
	},

	clonePrimitive: function(){
		return this;
	},

	cloneNative: function(){
		return new this.constructor(this.valueOf());
	}
};

exports.definePropertyClone = exports.assignPropertyClone;
exports.cloneProperties = exports.cloneProperties.bind(exports);
Object.clone = exports.cloneProperties;

// primitive
String.prototype.clone = exports.clonePrimitive;
Number.prototype.clone = exports.clonePrimitive;
Boolean.prototype.clone = exports.clonePrimitive;
// native
RegExp.prototype.clone = exports.cloneNative;
Date.prototype.clone = exports.cloneNative;
//make non enumerable
var property = require('property');
[String, Number, Boolean, RegExp, Date].forEach(function(constructor){
	property.implement(constructor, 'clone', constructor.prototype.clone);
});

// es5
if( 'getOwnPropertyDescriptor' in Object ){
	Object.define(exports, {
		extensibility: true,
		enumerator: Object.getOwnPropertyNames,
		
		definePropertyClone: function(name, object, references){
			var descriptor = Object.getOwnPropertyDescriptor(object, name);

			if( 'value' in descriptor ){
				descriptor.value = exports.cloneValue(descriptor.value, references);
			}
			
			Object.defineProperty(this, name, descriptor);
		}
	});
}

module.exports = exports;
