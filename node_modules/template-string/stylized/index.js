/*

StylizedTemplate.registerFormat('background-yellow', {background: 'yellow'});
StylizedTemplate.registerFormat('red', {color: 'red'});
StylizedTemplate.registerFormat('green', {color: 'green'});

var template = StylizedTemplate.new('Hello {name}, age: {age} !').registerStyles(['green', 'red']);

template.render({name: 'damien', age: 10});

var template = StylizedTemplate.new('Hello {name} !').registerStyles({name: 'green'});
template.globalStyle = 'background-yellow';
template.render({name: 'damien', age: 10});

*/

var StringTemplate = require('template-string');
var proto = require('proto');

var StylizedTemplate = proto.extend.call(StringTemplate, {
	formats: {},
	styles: {},
	globalStyle: null,
	prefix: null,
	suffix: null,
	mergePropertyNames: StringTemplate.mergePropertyNames.concat(
		'formats', 'styles', 'globalStyle', 'prefix', 'suffix'
	),

	constructor: function(string){
		this.formats = Object.create(this.formats || null);
		this.styles = Object.create(this.styles || null);

		StylizedTemplate.super.constructor.call(this, string);
	},

	subsetObjectOwnKeys: function(object){
		var keys = Object.keys(object), i = 0, j = keys.length, key, result;

		if( j ){
			result = {};
			for(;i<j;i++){
				key= keys[i];
				result[key] = object[key];
			}
		}

		return result;
	},

	// format are used to represent a list of styles (string)
	registerFormat: function(name, styles){
		if( typeof styles == 'string' ) styles = [styles];

		this.formats[name] = styles;
	},

	// style are used to bind a format to an expression
	registerStyle: function(name, format){
		if( typeof format != 'string' ){
			this.registerFormat(name, format);
		}

		this.styles[name] = format;
	},

	registerFormats: function(formats){
		if( formats ){
			for(var format in formats){
				this.registerFormat(format, formats[format]);
			}
		}
	},

	registerStyles: function(styles){
		var key;

		if( styles instanceof Array ){
			var expressions = this.expressions;
			for(key in styles){
				this.registerStyle(expressions[key], arguments[key]);
			}
		}
		else if( styles ){
			for(key in styles){
				this.registerStyle(key, styles[key]);
			}
		}

		return this;
	},

	writeStyle: function(string, format){
		throw new Error('unimplemented method');
	},

	stylizeValue: function(value, styleName){

		// use stylizedString representation
		if( typeof value == 'object' && typeof value['toStylizedString'] == 'function' ){
			value = value.toStylizedString();
		}
		if( styleName in this.styles ){
			value = String(value);
			value = this.writeStyle(value, this.styles[styleName]);
		}

		return value;
	},

	stylizeValueAt: function(value, index){
		return this.stylizeValue(value, this.expressions[index]);
	},

	stylizeValues: function(values){
		var i = 0, j = values.length, stylizedValues = new Array(j);

		for(;i<j;i++){
			stylizedValues[i] = this.stylizeValueAt(values[i], i);
		}

		return stylizedValues;
	},

	toString: function(){
		var string;

		string = StylizedTemplate.super.toString.call(this);
		if( this.prefix ) string = this.prefix + string;
		if( this.suffix ) string+= this.suffix;

		return string;
	},

	toStylizedString: function(){
		var string;

		string = this.Renderer.renderAsString(this.strings, this.stylizeValues(this.values));
		if( this.prefix ) string = this.prefix + string;
		if( this.suffix ) string+= this.suffix;
		string = this.stylizeValue(string, this.globalStyle);

		return string;
	},

	toJSON: function(){
		var obj = StylizedTemplate.super.toJSON.call(this);

		obj.prefix = this.prefix;
		obj.formats = this.formats;
		obj.styles = this.styles;
		obj.suffix = this.suffix;

		return obj;
	}
});

module.exports = StylizedTemplate;