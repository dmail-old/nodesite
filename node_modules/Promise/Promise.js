var proto = require('proto');
var Promise = proto.create({
	state: 'pending',
	value: null,
	executor: null, // function(resolve, reject){},
	children: null,

	constructor: function(executor){
		if( arguments.length === 0 && !this.executor ){
			throw new Error('missing executor function');
		}
		if( typeof executor != 'function' ){
			throw new TypeError('function expected as executor');
		}

		if( arguments.length > 0 ){
			this.executor = executor;
		}

		this.state = 'pending';
		this.resolver = this.resolve.bind(this);
		this.rejecter = this.reject.bind(this);

		try{
			this.executor(this.resolver, this.rejecter);
		}
		catch(e){
			this.reject(e);
		}
	},

	then: function(onresolve, onreject){
		var promise = new ChildPromise(this, onresolve, onreject);

		if( this.state === 'rejected' && !this.hasChild() ){
			clearImmediate(this.unhandled);
			this.unhandled = null;
		}

		this.addChild(promise);

		if( this.state !== 'pending' ){
			setImmediate(function(){
				this.handleChild(promise);
			}.bind(this));
		}

		return promise;
	},

	catch: function(onreject){
		return this.then(null, onreject);
	},

	addChild: function(promise){
		this.children = this.children || [];
		this.children.push(promise);
	},

	hasChild: function(){
		return this.children && this.children.length;
	},

	handleChild: function(child){
		child.handle();
	},

	// called when the promise is settled
	clean: function(){
		var i, j, children = this.children;

		if( children ){
			i = 0;
			j = children.length;
			for(;i<j;i++){
				this.handleChild(children[i]);
			}
		}
	},

	onFulFilled: function(value){
		this.clean();
	},

	onRejected: function(value){
		this.clean();

		// has no handler
		if( !this.hasChild() ){
			this.unhandled = setImmediate(function(){
				this.unhandled = null;
				if( !this.hasChild() ){
					if( process.listeners('unhandledRejection').length === 0 ){
						console.log('possibly unhandled rejection',
							value instanceof Error ? value.stack : value, 'for promise', this);
					}
					process.emit('unhandledRejection', value, this);
				}
			}.bind(this));
		}
	},

	// returns true if thenable have been handled by resolve or reject
	checkThenable: function(thenable, resolve, reject){
		if( thenable === this ){
			reject(new TypeError('A promise cannot be resolved with itself'));
			return true;
		}

		if( thenable && (typeof thenable === 'object' || typeof thenable === 'function') ){
			var then;
			try{
				then = thenable.then;
			}
			catch(e){
				reject(e);
				return true;
			}

			if( typeof then === 'function' ){
				try{
					then.call(thenable, resolve, reject);
				}
				catch(e){
					reject(e);
				}
				return true;
			}
		}

		return false;
	},

	resolve: function(value){
		if( this.state === 'pending' ){
			if( !this.resolving ){
				this.resolving = function(value){
					if( !this.checkThenable(value, this.resolving, this.rejecter) ){
						this.state = 'fulfilled';
						this.value = value;
						this.onFulFilled(value);
					}
				}.bind(this);
				this.resolving(value);
			}
		}
	},

	reject: function(value){
		if( this.state === 'pending' ){
			this.state = 'rejected';
			this.value = value;
			this.onRejected(value);
		}
	},

	toString: function(){
		return '[object Promise]';
	}
});

/*
if( Object.defineProperty ){
	Object.keys(Promise.prototype).forEach(function(name){
		Object.defineProperty(Promise.prototype, name, {
			configurable: true,
			enumerable: false,
			writable: true,
			value: Promise.prototype[name]
		});
	});
}
*/

// PromiseReaction, the reaction waiting for a Promise to complete
// could be called a Deffered
var ChildPromise = proto.extend(Promise, {
	parent: null,
	onresolve: null,
	onreject: null,

	constructor: function(parent, onresolve, onreject){
		this.parent = parent;
		this.onresolve = onresolve;
		this.onreject = onreject;
		Promise.call(this, this.executor);
	},

	executor: function(){
		// noop
	},

	handle: function(){
		var parent, isResolved, fn, value, ret, error;

		parent = this.parent;
		value = parent.value;
		isResolved = parent.state === 'fulfilled';
		fn = isResolved ? this.onresolve : this.onreject;

		if( fn != null ){
			try{
				ret = fn(value);
			}
			catch(e){
				error = e;
			}

			if( error ){
				isResolved = false;
				value = error;
			}
			else{
				isResolved = true;
				value = ret;
			}
		}

		if( isResolved ){
			this.resolve(value);
		}
		else{
			this.reject(value);
		}
	}
});

Promise.ChildPromise = ChildPromise;

Promise.resolve = function(value){
	return new Promise(function resolveExecutor(resolve){
		resolve(value);
	});
};

Promise.reject = function(value){
	return new Promise(function rejectExecutor(resolve, reject){
		reject(value);
	});
};


var forOf = require('forOf');
Promise.all = function(iterable){
	return new Promise(function(resolve, reject){
		function res(value, index){
			if( Promise.prototype.checkThenable(value, function(value){ res(value, index); }, reject) ){
				return;
			}
			values[index] = value;
			length--;
			if( length === 0 ) resolve(values);
		}

		var index = 0, length = 0, values = [];

		forOf(iterable, function(value){
			length++;
			res(value, index);
			index++;
		});

		if( index != length && length === 0 ) resolve(values);
	});
};

module.exports = Promise;
require('Object.polyfill')('global', 'Promise', Promise);