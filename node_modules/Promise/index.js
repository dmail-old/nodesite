/*
*/
var proto = require('proto');

var Executor = proto.create({
	done: false,

	constructor: function(fn, onFulfilled, onRejected){
		this.fn = fn;
		this.onFulfilled = onFulfilled;
		this.onRejected = onRejected;

		try{
			this.fn(this.resolve.bind(this), this.reject.bind(this));
		}
		catch(e){
			this.reject(e);
		}
	},

	resolve: function(value){
		if( !this.done ){
			this.done = true;
			this.onFulfilled(value);
		}
	},

	reject: function(value){
		if( !this.done ){
			this.done = true;
			this.onRejected(value);
		}
	}
});

var Handler = proto.create({
	constructor: function(onFulfilled, onRejected, resolve, reject){
		this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
		this.onRejected = typeof onRejected === 'function' ? onRejected : null;
		this.resolve = resolve;
		this.reject = reject;
	}
});

var Promise = proto.create({
	state: null,
	value: null,
	fn: null,
	buffer: null,

	constructor: function(fn){
		if( typeof this !== 'object' ) throw new TypeError('Promises must be constructed via new');
		if( typeof fn !== 'function' ) throw new TypeError('not a function');
		this.state = null;
		this.value = null;
		this.fn = fn;
		this.buffer = [];

		this.execute(this.fn, this.resolve.bind(this), this.reject.bind(this));
	},

	isPending: function(){
		return this.state === null;
	},

	isRejected: function(){
		return this.state === false;
	},

	isSettled: function(){
		return this.state !== null;
	},

	isFulFilled: function(){
		return this.state === true;
	},

	execute: function(executor, resolve, reject){
		this.executor = Executor.new(executor, resolve, reject);
	},

	finale: function(){
		var i = 0, j = this.buffer.length;
		for(;i<j;i++){
			this.resolveHandler(this.buffer[i]);
		}
		this.buffer = null;
	},

	resolve: function(value){
		try{
			if( value === this) throw new TypeError('A promise cannot be resolved with itself.');
			if( value && (typeof value === 'object' || typeof value === 'function') ){
				var then = value.then;
				if( typeof then === 'function' ){
					this.execute(then.bind(value), this.resolve.bind(this), this.reject.bind(this));
					return;
				}
			}
			this.state = true;
			this.value = value;
			this.finale();
		}
		catch(e){
			this.reject(e);
		}
	},

	reject: function(reason){
		this.state = false;
		this.value = reason;
		this.finale();
	},

	resolveHandler: function(handler){
		var isFulFilled = this.isFulFilled() , fn = isFulFilled ? handler.onFulfilled : handler.onRejected;

		if( fn === null ){
			if( isFulFilled() ){
				handler.resolve(this.value);
			}
			else{
				handler.reject(this.value);
			}
			return;
		}
		else{
			var ret;

			try{
				ret = fn(this.value);
			}
			catch(e){
				handler.reject(e);
				return;
			}

			handler.resolve(ret);
		}
	},

	handle: function(handler){
		if( this.isPending() ){
			this.buffer.push(handler);
		}
		else{
			// should be async
			this.resolveHandler(handler);
		}
	},

	then: function(onFulfilled, onRejected){
		var me = this;
		return new Promise(function(resolve, reject){
			me.handle(new Handler(onFulfilled, onRejected, resolve, reject));
		});
	},

	catch: function(onRejected){
		return this.then(null, onRejected);
	},

	/*
	prevent: function(){
		if( !this.isPending() ){
			throw new Error('cannot prevent a resolved promise');
		}
		this.executor.done = true; // set done = true on the executor to ignore the result
	},

	rerun: function(){
		this.prevent();
		this.execute(this.fn, this.resolve.bind(this), this.reject.bind(this));
	}
	*/
});

Promise.resolve = function(value){
	if( value && typeof value === 'object' && value.constructor === Promise ){
		return value;
	}
	return new Promise(function(resolve){
		resolve(value);
	});
};

Promise.reject = function(value){
	return new Promise(function(resolve, reject){
		reject(value);
	});
};

var forOf = require('es6').forOf;

Promise.all = function(iterable){
	return new Promise(function(resolve, reject){		
		function res(value, index){
			try{
				if( value && (typeof value === 'object' || typeof value === 'function') ){
					var then = value.then;
					if (typeof then === 'function'){
						then.call(value, function(value){ res(value, index); }, reject);
						return;
					}
				}
				values[index] = value;
				length--;
				if( index != length && length === 0 ) resolve(values);
			}
			catch(e){
				reject(e);
			}
		}

		var index = 0, length = 0, values = [];

		forOf(iterable, function(value){
			length++;
			res(value, index);
			index++;
		});

		if( length === 0 ) resolve(values);
	});
};

Promise.race = function(iterable){
	return new Promise(function(resolve, reject){
		forOf(iterable, function(promise){
			promise.then(resolve, reject);
		});
	});
};

/*
Array can be an array of object in case methodName is called on each object
Array can be an array of methodName in case the methods are called on methodName

a promise is expected and when it's resolved the next array item is called

on pourrait aussi crée un itérateur spécifique qu iretournerais des promesses au fur est à mesure
qu'il est parcouru (ce sera surement la version finale)
*/

Promise.chain = function(array, methodName){
	return new Promise(function(resolve, reject){
		var i = 0, j = array.length, item, promise, values = [];

		function next(){
			if( i >= j ) return resolve(values);
			i++;

			item = array[i];
			if( typeof item === 'string' ){
				promise = methodName[item]();
			}
			else{
				promise = item[methodName]();
			}

			promise.then(function(value){
				values.push(value);
				next();
			}, reject);
		}

		next();
	});
};

module.exports = Promise;