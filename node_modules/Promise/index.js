var P = require('./Promise');
var forOf = require('forOf');

// helper to implement reduce, every & map
function iterate(iterable, thenMap, thenMapBind, collectFn, collectBind, initialValue){
	var promise, index = 0;

	promise = Promise.resolve(initialValue);

	if( thenMap && typeof thenMap != 'function' ) throw new TypeError('thenMap must be a function');

	forOf(iterable, function(value){
		index++;
		if( thenMap ){
			value = thenMap.call(thenMapBind, value, index, iterable);
		}
		// retourne le résultat de thenFn sur iterable (peut être thenable)
		promise = promise.then(value);
		// récupère le résultat si on en a besoin
		if( collectFn ){
			promise.then(collectFn.bind(collectBind), function(){
				// we add an empty function to listen for promise rejection
				// else the promise rejection is considered unhandled
			});
		}
	});

	return promise;
}

function reducer(value){
	return value.bind(this);
}

function collector(value){
	this.push(value);
	return value;
}

// each iterable value is considered as a then() call
Promise.reduce = function(iterable, bind, initialValue){
	return iterate(iterable, reducer, bind, null, null, initialValue);
};

// same as reduce but collect the resolved values and return them
Promise.serie = function(iterable, bind, initialValue){
	var values = [];
	return iterate(iterable, reducer, bind, collector, values, initialValue).then(function serieResolution(){
		return values;
	});
};

// each iterable value is mapped and considered as a then() call and return an array of resolved values
Promise.map = function(iterable, map, bind){
	var values = [];
	return iterate(iterable, function(value, index, iterable){
		return map.bind(bind, value, index, iterable);
	}, null, collector, values).then(function mapResolution(){
		return values;
	});
};

// same as map but values are not collected
Promise.mapReduce = function(iterable, map, bind){
	return iterate(iterable, function(value, index, iterable){
		return map.bind(bind, value, index, iterable);
	});
};

Promise.from = function(fn, bind){
	return new Promise(function fromExecutor(resolve, reject){
		fn.call(bind, function(error, result){
			if( error ) reject(error);
			else resolve(result);
		});
	});
};

module.exports = P;