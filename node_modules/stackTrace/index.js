// https://github.com/felixge/node-stack-trace/blob/master/lib/stack-trace.js

require('array/prototype/findIndex');

var StackTrace = {
	fileSystem: require('fs'),

	slice: function(stack, notInFile){
		stack = stack.slice(stack.findIndex(function(callSite){
			return callSite.getFileName() != notInFile;
		}));
		return stack;
	},

	getStack: function(error){
		var stack;

		if( Error.prepareStackTrace ){ // since v8 upgrade, doesn't work anymore
			var oldLimit = Error.stackTraceLimit, oldPrepare = Error.prepareStackTrace;

			//Error.stackTraceLimit = Infinity;
			Error.prepareStackTrace = function(obj, rawStack){
				stack = rawStack;
				return rawStack;
			};
			Error.captureStackTrace(error);

			//stack = error.stack;
			//Error.stackTraceLimit = oldLimit;
			Error.prepareStackTrace = oldPrepare;

			// call caputeStackTrace again, this way error.stack is back to the stackTrace string
			Error.captureStackTrace(error);
		}
		else{
			stack = this.parse(error);
		}

		return stack;
	},

	get: function(notInFile){
		var stack = this.getStack(new Error());
		stack = stack.slice(1); // remove StackTrace.get()
		if( notInFile ){
			stack = this.slice(stack, notInFile);
		}
		return stack;
	},

	fromError: function(error, notInFile){
		var stack = this.getStack(error);
		if( notInFile ){
			stack = this.slice(stack, notInFile);
		}
		return stack;
	},

	_createParsedCallSite: function(properties){
		var methods = {}, property;

		for(property in properties){
			var prefix = 'get';
			if( property === 'native' ){
				prefix = 'is';
			}
			var method = prefix + property.substr(0, 1).toUpperCase() + property.substr(1);

			(function(property){
				methods[method] = function(){
					return properties[property];
				};
			})(property);
		}

		var callSite = Object.create(methods);
		for(property in properties){
			callSite[property] = properties[property];
		}

		return callSite;
	},

	parse: function(error){
		if( typeof error.stack === 'object' ){
			return error.stack;
		}
		if( !error.stack ){
			return [];
		}

		var lines = error.stack.split('\n').slice(1);

		return lines.map(function(line){
			if( line.match(/^\s*[-]{4,}$/) ){
				return this._createParsedCallSite({
					fileName: line,
					lineNumber: null,
					functionName: null,
					typeName: null,
					methodName: null,
					columnNumber: null,
					'native': null,
				});
			}

			var lineMatch = line.match(/at (?:(.+)\s+)?\(?(?:(.+?):(\d+):(\d+)|([^)]+))\)?/);
			if( !lineMatch ){
				return;
			}

			var object = null;
			var method = null;
			var functionName = null;
			var typeName = null;
			var methodName = null;
			var isNative = (lineMatch[5] === 'native');

			if( lineMatch[1] ){
				var methodMatch = lineMatch[1].match(/([^\.]+)(?:\.(.+))?/);
				object = methodMatch[1];
				method = methodMatch[2];
				functionName = lineMatch[1];
				typeName = 'Object';
			}

			if( method ){
				typeName = object;
				methodName = method;
			}

			if( method === '<anonymous>' ){
				methodName = null;
				functionName = '';
			}

			var properties = {
				fileName: lineMatch[2] || null,
				lineNumber: parseInt(lineMatch[3], 10) || null,
				functionName: functionName,
				typeName: typeName,
				methodName: methodName,
				columnNumber: parseInt(lineMatch[4], 10) || null,
				'native': isNative,
			};

			return this._createParsedCallSite(properties);
		}, this).filter(function(callSite){
			return Boolean(callSite);
		});
	},

	stringify: function(error){
		var string;

		if( typeof error.stack === 'string' ){
			string = error.stack;
		}
		// error.stack is an object
		else{
			string = error.name + ': ' + error.message;

			if( typeof error.stack === 'object' ){
				var stack = error.stack.map(function(callSite){
					var functionName = callSite.getFunctionName();
					var meta = callSite.getFileName() + ':' + callSite.getLineNumber() + ':' + callSite.getColumnNumber();

					if( functionName ){
						return 'at ' + functionName + '(' + meta + ')';
					}
					return 'at' + meta;
				});

				if( stack.length ) string+= '\n' + stack.join('\n\t');
			}
		}

		return string;
	},

	readFileLines: function(){
		var content = this.fileSystem.readFileSync(path, 'utf8');
		return content.split(/\n|\r\n\r/);
	},

	readFileLine: function(path, line){
		return this.readFileLines(path)[line];
	},

	readCallSource: function(call){
		return this.readFileLine(call.getFileName(), call.getLineNumber() - 1);
	},

	readSource: function(belowFn){
		var stackTrace = this.get(belowFn);
		var source = stackTrace[stackTrace.length - 1];
		var file = source.getFileName();
		var line = source.getFileNumber();
		return this.readFileLine(file, line - 1);
	},

	findCallByFile: function(traces, fileName){
		var i = 0, j = traces.length, trace;

		for(;i<j;i++){
			trace = traces[i];
			if( trace.getFileName() == fileName ){
				return trace;
			}
		}

		return null;
	},

	readErrorSource: function(error){
		/*
	en s'inspirant de https://github.com/medikoo/path2/blob/master/windows/common.js
	on peut savoir si la source de l'erreur est dans mes fichier ou externe
	il faut savoir que la plupart du temps des erreurs sont provoquées ailleurs que là
	ou elles sont cré donc pas forcément une bonne idée d'affiche que le contexte
	cependant en conjonction avec la trace c'est au top
		*/

		/*
		var stackTrace = require('stackTrace');
		var error = test.lastError;

		var calls = stackTrace.parse(error);
		var call = calls[0];

		logger.styles.source = {background: 'grey', color: 'white', font: 'bold'};

		logger.error('{name} \n {message} \n in {fileName}:{lineNumber} \n {source}',
			test.name,
			error.toString(),
			call.getFileName(),
			call.getLineNumber(),
			stackTrace.readCallSource(call)
		);
*/

		var calls = this.parse(error);
		var call = calls[0];
		return this.readCall(call);
	}
};

module.exports = StackTrace;