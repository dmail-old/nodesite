// https://github.com/felixge/node-stack-trace/blob/master/lib/stack-trace.js

var StackTrace = {
	fileSystem: require('fs'),

	get: function(belowFn){
		var oldLimit = Error.stackTraceLimit;
		Error.stackTraceLimit = Infinity;

		var dummyObject = {};

		var oldPrepare = Error.prepareStackTrace;
		Error.prepareStackTrace = function(dummyObject, stack){ return stack; };
		Error.captureStackTrace(dummyObject, belowFn || StackTrace.get);

		var stack = dummyObject.stack;		
		Error.prepareStackTrace = oldPrepare;
		Error.stackTraceLimit = oldLimit;

		return stack;
	},

	readFileLine: function(path, line){
		var content = this.fileSystem.readFileSync(path, 'utf8');
		return content.split(/\n|\r\n\r/)[line];
	},

	readCallSource: function(call){
		return this.readFileLine(call.getFileName(), call.getLineNumber() - 1);
	},

	readSource: function(belowFn){
		var stackTrace = this.get(belowFn);
		var source = stackTrace[stackTrace.length - 1];
		var file = source.getFileName();
		var line = source.getFileNumber();
		return this.readFileLine(file, line - 1);
	},

	findFile: function(traces, fileName){
		var i = 0, j = traces.length, trace;

		for(;i<j;i++){
			trace = traces[i];
			if( trace.getFileName() == fileName ){
				return trace;
			}
		}

		return null;
	},
	
	parse: function(err){
		if( !err.stack ){
			return [];
		}

		var self = this;
		var lines = err.stack.split('\n').slice(1);

		return lines.map(function(line){
			if( line.match(/^\s*[-]{4,}$/) ){
				return self._createParsedCallSite({
					fileName: line,
					lineNumber: null,
					functionName: null,
					typeName: null,
					methodName: null,
					columnNumber: null,
					'native': null,
				});
			}

			var lineMatch = line.match(/at (?:(.+)\s+)?\(?(?:(.+?):(\d+):(\d+)|([^)]+))\)?/);
			if( !lineMatch ){
				return;
			}

			var object = null;
			var method = null;
			var functionName = null;
			var typeName = null;
			var methodName = null;
			var isNative = (lineMatch[5] === 'native');

			if( lineMatch[1] ){
				var methodMatch = lineMatch[1].match(/([^\.]+)(?:\.(.+))?/);
				object = methodMatch[1];
				method = methodMatch[2];
				functionName = lineMatch[1];
				typeName = 'Object';
			}

			if( method ){
				typeName = object;
				methodName = method;
			}

			if( method === '<anonymous>' ){
				methodName = null;
				functionName = '';
			}

			var properties = {
				fileName: lineMatch[2] || null,
				lineNumber: parseInt(lineMatch[3], 10) || null,
				functionName: functionName,
				typeName: typeName,
				methodName: methodName,
				columnNumber: parseInt(lineMatch[4], 10) || null,
				'native': isNative,
			};

			return self._createParsedCallSite(properties);
		}).filter(function(callSite){
			return Boolean(callSite);
		});
	},

	_createParsedCallSite: function(properties) {
		var methods = {}, property;

		for(property in properties){
			var prefix = 'get';
			if( property === 'native' ){
				prefix = 'is';
			}
			var method = prefix + property.substr(0, 1).toUpperCase() + property.substr(1);

			(function(property){
				methods[method] = function(){
					return properties[property];
				};
			})(property);
		}

		var callSite = Object.create(methods);
		for(property in properties ){
			callSite[property] = properties[property];
		}

		return callSite;
	},

	readErrorSource: function(error){
		var calls = this.parse(error);
		var call = calls[0];
		return this.readCall(call);
	}
};

module.exports = StackTrace;