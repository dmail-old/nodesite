/*
we doesn't support \n
https://github.com/Automattic/cli-table/blob/master/lib/index.

setCellAsComputedFromColumn()
setCellAsTotalOfColumn()

*/

require('String.prototype.pad');
require('String.prototype.truncate');
require('String.prototype.repeat');
require('Math.extra');

var forOf = require('forOf');
var proto = require('proto');

/*
will set a width to all cells

- table.layout
- else cell.style.width
- else cell.contentWidth
*/

var CellWidthManager = proto.create({
	minWidth: 3,

	constructor: function(tableTemplate){
		this.table = tableTemplate;
		this.type = tableTemplate.layout;

		this.columnCount = tableTemplate.cells.length ? tableTemplate.cells[0].length : 0;
		this.offsetWidth = this.getOffsetWidth();
		this.availableWidth = this.getAvailableWidth();
		this.width = this.getWidth(tableTemplate.style.width);

		this.computeWidths();
	},

	getOffsetWidth: function(){
		// we decrease of 1px else the line-height is doubled in the console
		return process.stdout.columns - 1;
	},

	getAvailableWidth: function(){
		var table = this.table, cumulativeInnerBorderSize, availableWidth;

		if( this.columnCount ){
			cumulativeInnerBorderSize = (this.columnCount - 1) * table.innerBorderSize;
		}
		else{
			cumulativeInnerBorderSize = 0;
		}

		availableWidth = this.offsetWidth - table.borderLeftSize - table.borderRightSize - cumulativeInnerBorderSize;

		return availableWidth;
	},

	isPercentage: function(value){
		return typeof value === 'string' && value.slice(-1) === '%';
	},

	percent: function(percent, value){
		percent = parseInt(percent.slice(0, -1), 10);
		return Math.floor((percent / 100) * value);
	},

	getWidth: function(widthStyle){
		var width;

		if( typeof widthStyle === 'string' ){
			if( widthStyle === 'auto' ){
				width = this.availableWidth;
			}
			if( this.isPercentage(widthStyle) ){
				width = this.percent(widthStyle, this.availableWidth);
			}
		}
		else if( typeof widthStyle === 'number' ){
			width = widthStyle;
		}

		return width;
	},

	fixedWidth: function(){
		var width = this.width;
		var columnCount = this.columnCount;
		var cellWidth = width / columnCount;
		var modulo = width % columnCount;

		forOf(this.table, function(cell){
			cell.style = this.table.cellStyle;
			cell.width = cellWidth;
		}, this);

		if( modulo !== 0 ){
			forOf(this.table.column(columnCount - 1), function(cell){
				cell.width-= modulo;
			});
		}
	},

	getCellWidth: function(cell){
		cell.style = this.table.cellStyle;

		var width;

		if( cell.style.width === 'auto' ){
			width = cell.value.length;
		}
		else if( typeof cell.style.width === 'number' ){
			width = cell.style.width;
		}
		else if( this.isPercentage(cell.style.width) ){
			width = this.percent(cell.style.width, this.availableWidth);
		}

		width+= cell.style.paddingLeft;
		width+= cell.style.paddingRight;

		if( typeof cell.style.minWidth === 'number' ) width = Math.max(cell.style.minWidth, width);
		if( typeof cell.style.maxWidth === 'number' ) width = Math.min(cell.style.maxWidth, width);

		return width;
	},

	autoWidth: function(){
		var columnCount = this.columnCount;
		var i = 0, j = columnCount;
		var columns = [];
		var column;
		var totalCellWidth = 0;
		var totalAverageCellWidth = 0;
		var diff;
		var tableWidth = this.width;
		var remainingOverflow;
		var widths;
		var dimensions;

		for(;i<j;i++){
			column = this.table.column(i);

			widths = [];
			forOf(column, function(cell){
				widths.push(this.getCellWidth(cell));
			}, this);

			dimensions = {
				widths: widths,
				maxCellWidth: Math.max.apply(null, widths),
				averageCellWidth: Math.sum.apply(null, widths) / widths.length,
				width: Math.max.apply(null, widths)
			};

			column.meta('dimensions', dimensions);
			
			totalCellWidth+= dimensions.width;
			// standard deviation would be useful in case some cell have very long texts
			totalAverageCellWidth+= dimensions.averageCellWidth;

			columns.push(column);
		}

		diff = totalCellWidth - tableWidth;

		// the columns are too large because of cells
		if( diff > 0 ){
			remainingOverflow = diff;
			var decreaseAmount;
			var coef;
			var largestDimensions = null;
			var maxCellWidth;
			var width;

			columns.forEach(function(column){
				dimensions = column.meta('dimensions');
				coef = dimensions.averageCellWidth / totalAverageCellWidth;
				decreaseAmount = Math.floor(diff * coef);
				maxCellWidth = dimensions.maxCellWidth;
				width = maxCellWidth - decreaseAmount;

				if( width < this.minWidth ){
					decreaseAmount = this.minWidth - maxCellWidth;
					width = this.minWidth;
				}

				remainingOverflow-= decreaseAmount;
				dimensions.width = width;

				if( !largestDimensions || width > largestDimensions.width ){
					largestDimensions = dimensions;
				}
			}, this);

			// remove remainingoverflow from the largest column
			// (when Math.floor() for decreaseAmount lead to keep some width)
			if( remainingOverflow !== 0 && largestDimensions ){
				largestDimensions.width-= remainingOverflow;
			}
		}
		// the colmuns are too small, we increase their size proportionnaly
		else if( diff < 0 ){
			remainingOverflow = diff;
			var increaseAmount = Math.floor(Math.abs(diff+1) / columns.length);

			columns.forEach(function(column){
				remainingOverflow+= increaseAmount;
				column.meta('dimensions').width+= increaseAmount;
			});

			if( remainingOverflow !== 0 ){
				columns[columns.length-1].meta('dimensions').width-= remainingOverflow + 1;
			}
		}

		columns.forEach(function(column){
			column.set('width', column.meta('dimensions').width);
		});
	},

	computeWidths: function(){
		/*
		// en gros lorsqu'il y a trop de colonne faudrait slice() les colonnes
		// et dans la dernière colonne indiquer que la suite du tableau n'est pas affiché
		if( this.table.columnCount() * this.minWidth > this.availableWidth  ){
	
		}
		*/

		if( this.columnCount ){
			if( this.type === 'fixed' ){
				this.fixedWidth();
			}
			else if( this.type === 'auto' ){
				this.autoWidth();
			}
		}
	}
});

var Table = require('Table');
var TableTemplate = proto.extend(Table, {
	ansi: require('ansi'),
	chars: {
		'top': '─',
		'topMid': '┬',
		'topLeft': '┌',
		'topRight': '┐',
		'bottom': '─',
		'bottomMid': '┴',
		'bottomLeft': '└',
		'bottomRight': '┘',
		'left': '│',
		'leftMid': '├',
		'mid': '─',
		'midMid': '┼',
		'right': '│',
		'rightMid': '┤',
		'middle': '│'
	},
	className: 'head',
	layout: 'auto',  // 'auto' | 'fixed' (proportionnal)
	style: {
		width: '100%', // 'auto' | '0-100%' | Number
		textOverflow: 'ellipsis',
		head: 'header',
		border: 'border',
	},
	cellStyle: {
		/*
		height: 'auto'
		verticalAlign: 'center'
		*/
		width: 'auto',
		paddingLeft: 1,
		paddingRight: 1,
		textAlign: 'left',
		minWidth: 3,
		maxWidth: null//28,
	},

	constructor: function(){
		Table.apply(this, arguments);

		var chars = this.chars;

		if( !chars.topLeft ) chars.topLeft = chars.top;
		if( !chars.topRight ) chars.topRight = chars.top;
		if( !chars.bottomLeft ) chars.bottomLeft = chars.bottom;
		if( !chars.bottomRight ) chars.bottomRight = chars.bottom;

		if( this.className === 'compact' ){
			this.borderLeftSize = 0;
			this.borderRightSize = 0;
		}
		else{
			this.borderLeftSize = this.chars.left.length;
			this.borderRightSize = this.chars.right.length;
		}
		this.innerBorderSize = this.chars.left.length;
	},

	getBorder: function(name){
		if( this.style.border ) return this.ansi.format(this.chars[name], this.style.border);
		return this.chars[name];
	},

	drawLine: function(char, left, right, mid){
		var line = '';
		var border = this.getBorder(char);
		var row = this.cells[0];

		row.forEach(function(cell, index, array){
			line+= border.repeat(cell.width);
			if( index != array.length - 1 ) line+= this.getBorder(mid);
		}, this);

		if( this.className != 'compact' ){
			line = this.getBorder(left) + line + this.getBorder(right);
		}

		return line;
	},

	drawSepLine: function(){
		return this.drawLine('mid', 'leftMid', 'rightMid', 'midMid');
	},

	drawTopLine: function(){
		return this.drawLine('top', 'topLeft', 'topRight', 'topMid');
	},

	drawBottomLine: function(){
		return this.drawLine('bottom', 'bottomLeft', 'bottomRight', 'bottomMid');
	},

	drawCell: function(x, y){
		var cell = this.cells[y][x];

		var width = cell.width;
		var textAlign = cell.style.textAlign;
		var contentWidth = cell.value.length;
		var content;

		width-= cell.style.paddingLeft;
		width-= cell.style.paddingRight;

		if( contentWidth === width ){
			content = cell.value;
		}
		else if( contentWidth > width ){
			content = cell.value.truncate(width, cell.style.textOverflow == 'ellipsis' ? '…' : cell.style.textOverflow);
		}
		else{
			if( textAlign === 'left' ){
				content = cell.value.padRight(width - 1, ' ');
			}
			else if( textAlign === 'right' ){
				content = cell.value.padLeft(width - 1, ' ');
			}
			else{
				content = cell.value.pad(width - 1, ' ');
			}
		}

		if( cell.className ){
			content = this.ansi.format(content, cell.className);
		}

		return [
			' '.repeat(cell.style.paddingLeft || 0),
			content,
			' '.repeat(cell.style.paddingRight || 0)
		].join('');
	},

	drawRow: function(y){
		var row = '', x = 0, width = this.cells[y].length;

		for(;x<width;x++){
			if( x !== 0 ) row+= this.getBorder('left');
			row+= this.drawCell(x, y);
		}
		if( this.className != 'compact' ){
			row = this.getBorder('left') + row + this.getBorder('right');
		}

		return row;
	},

	drawTable: function(){
		var table = '', y = 0, height = this.cells.length;

		for(;y<height;y++){
			table+= this.drawRow(y);
			if( y != height - 1 ){
				table+= '\n';
				if( y === 0 || this.className === 'human' ){
					table+= this.drawSepLine();
					table+= '\n';
				}
			}
		}

		return table;
	},

	toString: function(){
		this.prepare();
		this.manager = new CellWidthManager(this);

		var parts = [];
		if( this.className != 'compact' ) parts.push(this.drawTopLine());
		parts.push(this.drawTable());
		if( this.className != 'compact' ) parts.push(this.drawBottomLine());
		return parts.join('\n');
	}
});

TableTemplate.prototype.ansi.addFormat('border', 'grey');
TableTemplate.prototype.ansi.addFormat('header', 'cyan');

module.exports = TableTemplate;

/*
console.clear = function(){
	process.stdout.write('\u001B[2J\u001B[0;0f');
};
*/