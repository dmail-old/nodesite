/*
we doesn't support \n
https://github.com/Automattic/cli-table/blob/master/lib/index.

setCellAsComputedFromColumn()
setCellAsTotalOfColumn()

*/

require('string/prototype/pad');
require('string/prototype/truncate');
require('string/prototype/repeat');

var proto = require('proto');

/*
will set a width to all cells

- table.layout
- else cell.style.width
- else cell.contentWidth

il faut tenir compte de minWidth et maxWidth des cellules (qui peuvent être en %)
il faut ne resize les colonnes qu'en fonction du minWidth et maxWidth récup
les colonnes non resizable ne doivent pas être touchées

*/

var TableLayout = require('./TableLayout');
var Table = require('Table');

var CellTemplate = proto.extend(Table.prototype.Cell, {
	style: {
		/*
		height: 'auto'
		verticalAlign: 'center'
		*/
		minWidth: 0, // 'auto' | percent | number
		maxWidth: Infinity, // 'auto' | percent | number
		width: 'auto',
		paddingLeft: 1,
		paddingRight: 1,
		textAlign: 'left'
	},

	constructor: function(){
		Table.prototype.Cell.apply(this, arguments);
		this.style = Object.create(this.style);
	}
});

var CellRangeTemplate = proto.extend(Table.prototype.CellRange, {
	constructor: function(){
		Table.prototype.CellRange.apply(this, arguments);
		//this.style = Object.create(this.style);
	},

	setClass: function(className){
		return this.set('className', className);
	},

	setWidth: function(width){
		this.forEach(function(cell){
			cell.style.width = width;
		});
		return this;
	}
});

var TableTemplate = proto.extend(Table, {
	Cell: CellTemplate,
	CellRange: CellRangeTemplate,
	ansi: require('ansi'),
	chars: {
		'top': '─',
		'topMid': '┬',
		'topLeft': '┌',
		'topRight': '┐',
		'bottom': '─',
		'bottomMid': '┴',
		'bottomLeft': '└',
		'bottomRight': '┘',
		'left': '│',
		'leftMid': '├',
		'mid': '─',
		'midMid': '┼',
		'right': '│',
		'rightMid': '┤',
		'middle': '│'
	},
	className: 'head',
	layout: 'auto',  // 'auto' | 'fixed' (proportionnal)
	style: {
		width: 'auto', // 'auto' | '0-100%' | Number
		textOverflow: 'ellipsis',
		head: 'header',
		border: 'border',
	},

	constructor: function(cells){
		Table.call(this, cells);

		var chars = this.chars;

		if( !chars.topLeft ) chars.topLeft = chars.top;
		if( !chars.topRight ) chars.topRight = chars.top;
		if( !chars.bottomLeft ) chars.bottomLeft = chars.bottom;
		if( !chars.bottomRight ) chars.bottomRight = chars.bottom;

		if( this.className === 'compact' ){
			this.borderLeftSize = 0;
			this.borderRightSize = 0;
		}
		else{
			this.borderLeftSize = this.chars.left.length;
			this.borderRightSize = this.chars.right.length;
		}
		this.innerBorderSize = this.chars.left.length;
	},

	getBorder: function(name){
		if( this.style.border ) return this.ansi.format(this.chars[name], this.style.border);
		return this.chars[name];
	},

	drawLine: function(char, left, right, mid){
		var line = '';
		var border = this.getBorder(char);
		var row = this.cells[0];

		row.forEach(function(cell, index, array){
			line+= border.repeat(cell.width);
			if( index != array.length - 1 ) line+= this.getBorder(mid);
		}, this);

		if( this.className != 'compact' ){
			line = this.getBorder(left) + line + this.getBorder(right);
		}

		return line;
	},

	drawSepLine: function(){
		return this.drawLine('mid', 'leftMid', 'rightMid', 'midMid');
	},

	drawTopLine: function(){
		return this.drawLine('top', 'topLeft', 'topRight', 'topMid');
	},

	drawBottomLine: function(){
		return this.drawLine('bottom', 'bottomLeft', 'bottomRight', 'bottomMid');
	},

	drawCell: function(x, y){
		var cell = this.cells[y][x];

		var width = cell.width;
		var textAlign = cell.style.textAlign;
		var contentWidth = cell.value.length;
		var content;

		width-= cell.style.paddingLeft;
		width-= cell.style.paddingRight;

		if( contentWidth === width ){
			content = cell.value;
		}
		else if( contentWidth > width ){
			content = cell.value.truncate(width, cell.style.textOverflow == 'ellipsis' ? '…' : cell.style.textOverflow);
		}
		else{
			if( textAlign === 'left' ){
				content = cell.value.padRight(width - 1, ' ');
			}
			else if( textAlign === 'right' ){
				content = cell.value.padLeft(width - 1, ' ');
			}
			else{
				content = cell.value.pad(width - 1, ' ');
			}
		}

		if( cell.className ){
			content = this.ansi.format(content, cell.className);
		}

		return [
			' '.repeat(cell.style.paddingLeft || 0),
			content,
			' '.repeat(cell.style.paddingRight || 0)
		].join('');
	},

	drawRow: function(y){
		var row = '', x = 0, width = this.cells[y].length;

		for(;x<width;x++){
			if( x !== 0 ) row+= this.getBorder('left');
			row+= this.drawCell(x, y);
		}
		if( this.className != 'compact' ){
			row = this.getBorder('left') + row + this.getBorder('right');
		}

		return row;
	},

	drawTable: function(){
		var table = '', y = 0, height = this.cells.length;

		for(;y<height;y++){
			table+= this.drawRow(y);
			if( y != height - 1 ){
				table+= '\n';
				if( y === 0 && this.className != 'compact' && this.cells[0].fixed === true ){
					table+= this.drawSepLine();
					table+= '\n';
				}
			}
		}

		return table;
	},

	defineClass: function(className, styles){
		this.ansi.addFormat(className, styles);
	},

	toString: function(){
		if( this.cells.length ){
			this.compile();
			var layout = new TableLayout(this);
			layout.computeWidths();

			var parts = [];

			if( this.className != 'compact' ) parts.push(this.drawTopLine());
			parts.push(this.drawTable());
			if( this.className != 'compact' ) parts.push(this.drawBottomLine());
			return parts.join('\n');
		}
		return 'no cell in the table';
	}
});

TableTemplate.prototype.defineClass('border', 'grey');
TableTemplate.prototype.defineClass('header', 'cyan');

module.exports = TableTemplate;

/*
console.clear = function(){
	process.stdout.write('\u001B[2J\u001B[0;0f');
};
*/