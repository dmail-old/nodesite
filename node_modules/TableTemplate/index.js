/*

pouvoir styliser le header, les bords
we doesn't support \n

https://github.com/Automattic/cli-table/blob/master/lib/index.js

une options pour dire en gros que la colonna fait la largeur mais ne s'adapte pas
'autoAbsolute'

pouvoir spécifier une unité à la colonne
unit: 'px,ms,%'

*/

require('core/string');
require('core/array');

var options = {
	chars: {
		'top': '─',
		'topMid': '┬',
		'topLeft': '┌',
		'topRight': '┐',
		'bottom': '─',
		'bottomMid': '┴',
		'bottomLeft': '└',
		'bottomRight': '┘',
		'left': '│',
		'leftMid': '├',
		'mid': '─',
		'midMid': '┼',
		'right': '│',
		'rightMid': '┤',
		'middle': '│'
	},
	truncate: '…',
	width: '100%',
	layout: 'auto', // 'auto, fixed, [10, 'auto', 'fixed']'
	columnMinWidth: 3,
	colmunMaxWidth: 28,
	className: 'head',
	style: {
		'padding-left': 1,
		'padding-right': 1,
		'text-align': 'left',
		head: 'header',
		border: 'border'
	}
};

var proto = require('proto');
var chars = options.chars;

var Table = proto.create({
	ansi: require('ansi'),
	hasHeaders: true,

	constructor: function(){
		this.rows = arguments.length ? Array.prototype.slice.call(arguments) : [];

		if( !chars.topLeft ) chars.topLeft = chars.top;
		if( !chars.topRight ) chars.topRight = chars.top;
		if( !chars.bottomLeft ) chars.bottomLeft = chars.bottom;
		if( !chars.bottomRight ) chars.bottomRight = chars.bottom;
	},

	addRow: function(row){
		this.rows.push(row);
	},

	addRows: function(rows){
		this.rows.push.apply(this.rows, rows);
	},

	countColumn: function(){
		return this.rows[0].length;
	},

	countRow: function(){
		return this.rows.length;
	},

	getBorder: function(name){
		if( options.style.border ) return this.ansi.format(chars[name], options.style.border);
		return chars[name];
	},

	drawLine: function(char, left, right, mid){
		var line = '';
		var border = this.getBorder(char);

		if( options.className != 'compact' ) line+= this.getBorder(left);
		this.widths.forEach(function(width, index, array){
			line+= border.repeat(width);
			if( index != array.length - 1 ) line+= this.getBorder(mid);
		}, this);
		if( options.className != 'compact' ) line+= this.getBorder(right);

		return line;
	},

	drawSepLine: function(){
		return this.drawLine('mid', 'leftMid', 'rightMid', 'midMid');
	},

	drawTopLine: function(){
		return this.drawLine('top', 'topLeft', 'topRight', 'topMid');
	},

	drawBottomLine: function(){
		return this.drawLine('bottom', 'bottomLeft', 'bottomRight', 'bottomMid');
	},

	drawCell: function(content, width, rowIndex){
		width-= options.style['padding-left'];
		width-= options.style['padding-right'];

		content = content.replace(/\n/g, '\\n');

		var cell;

		if( content.length === width ){
			cell = content;
		}
		else if( content.length > width ){
			cell = content.truncate(width, chars.truncate);
		}
		else{
			if( options.style['text-align'] === 'left' ){
				cell = content.padRight(width - 1, ' ');
			}
			else if( options.style['text-align'] === 'right' ){
				cell = content.padLeft(width - 1, ' ');
			}
			else{
				cell = content.pad(width - 1, ' ');
			}
		}

		if( typeof rowIndex === 'number' && rowIndex === 0 && this.hasHeaders ){
			cell = this.ansi.format(cell, options.style.head);
		}
		
		return [
			' '.repeat(options.style['padding-left'] || 0),
			cell,
			' '.repeat(options.style['padding-right'] || 0)
		].join('');
	},

	drawRow: function(cells, rowIndex){
		var row = '';

		if( options.className != 'compact' ) row+= this.getBorder('left');
		this.widths.forEach(function(width, index, array){
			if( index !== 0 ) row+= this.getBorder('left');
			row+= this.drawCell(String(cells[index]), width, rowIndex);
		}, this);
		if( options.className != 'compact' ) row+= this.getBorder('right');

		return row;
	},

	drawTable: function(){
		var table = '';

		this.rows.forEach(function(row, index, array){
			table+= this.drawRow(row, index);
			if( index != array.length - 1 ){
				table+= '\n';
				if( index === 0 || options.className === 'human' ){
					table+= this.drawSepLine();
					table+= '\n';
				}				
			}
		}, this);

		return table;
	},

	getAvailableWidth: function(){
		var availableWidth = process.stdout.columns;
		var columnCount = this.countColumn();

		if( options.className != 'compact' ) availableWidth-= chars.left.length;
		if( columnCount ){
			availableWidth-= (columnCount - 1) * chars.left.length;
		}
		if( options.className != 'compact' ) availableWidth-= chars.right.length;
		availableWidth--; // we decrease of 1px else the line-height is doubled in the console

		return availableWidth;
	},

	getContentWidth: function(content){
		var width, length;

		length = String(content).length;

		width = length;
		width+= options.style['padding-left'];
		width+= options.style['padding-right'];

		if( typeof this.columnMinWidth === 'number' ) width = Math.max(this.columnMinWidth, length);
		if( typeof this.columnMaxWidth === 'number' ) width = Math.min(this.columnMaxWidth, length);

		return width;
	},

	computeWidths: function(){
		var table = this;
		var columns;
		var column;
		var availableWidth = this.getAvailableWidth();
		var columnCount = this.countColumn();
		var i;
		var desiredWidths;
		var totalDesiredWidth;
		var widths;
		var layout = options.layout;

		var Column = proto.create({
			constructor: function(index, desiredWidth){
				this.index = index;
				this.desiredWidth = desiredWidth;
				this.cellWidths = this.getCellWidths();
				this.idealWidth = this.cellWidths.max();
				this.averageCellWidth = this.idealWidth / this.cellWidths.length;		
				this.computedDesiredWidth = this.computeWidth();
			},

			isAuto: function(){
				return this.desiredWidth === 'auto';
			},

			averageCellWidth: function(){
				return this.cellWidths.average();
			},

			getCellWidths: function(){
				var widths = table.rows.map(function(cells){
					return table.getContentWidth(cells[this.index]);
				}, this);
				return widths;
			},

			computeWidth: function(){
				var desired = this.desiredWidth, width;

				if( typeof desired === 'string' ){
					if( desired === 'auto' ){
						width = this.idealWidth;
					}
					else if( desired === 'fixed' ){
						width = Math.floor(table.availableWidth / columnCount);
						// la dernière colonne est un peu plus large si le % ne tombe pas juste
						// genre 100 avec 3 colonnes feras 33, 33, 34
						if( this.index === columnCount - 1 ){
							width+= table.availableWidth % columnCount;
						}
					}
					else if( desired.slice(-1) === '%' ){
						var percent = parseInt(desired.slice(0, -1), 10);
						width = Math.floor((percent / 100) * table.availableWidth);
					}
					else{
						width = parseInt(desired, 10);
					}
				}
				else{
					width = desired;
				}

				return width;
			}
		});

		if( layout === 'auto' ){
			desiredWidths = new Array(columnCount).fill('auto');
		}
		else if( layout === 'fixed' ){
			desiredWidths = new Array(columnCount).fill('fixed');
		}
		else if( layout instanceof Array ){
			desiredWidths = layout;
		}

		table.availableWidth = availableWidth;
		i = columnCount;
		columns = new Array(i);
		totalDesiredWidth = 0;
		while(i--){
			column = new Column(i, desiredWidths[i]);
			totalDesiredWidth+= column.computedDesiredWidth;
			columns[i] = column;
		}

		var diff = totalDesiredWidth - availableWidth;	

		// le fait de diminuer/augmenter de manière équitable n'est pas bon, il faut faire un pourcentage
		// de la différence entre ce qui est demandé et ce qui est possible
		/*
		en tout je veux faire 100 mais j'ai que 70
		-> la colonne qui veut faire 80 est diminuer de 80% de 30
		-> la colonne qui veut faire 20 est diminuer de 20% de 30
		-> le reste est enlevé à la colonne la plus grande
		tenir copte de la largeur moyenne!

		pareil dans l'autre sens
		*/

		// the columns are too large
		if( diff > 0 ){
			var autoColumns = columns.filter(function(column){ return column.isAuto(); });
			// standard deviation would be useful in case some cell have very long texts
			var autoColumnsAverageSum = columns.map(function(column){ return column.averageCellWidth; }).sum();

			autoColumns.forEach(function(column){
				column.widthCoef = column.averageCellWidth / autoColumnsAverageSum;
			});

			var remainingOverflow = diff;
			var largestColumn = null;

			autoColumns.forEach(function(column, index){
				var decreaseAmount;
				decreaseAmount = Math.floor(diff * column.widthCoef);

				if( column.computedDesiredWidth - decreaseAmount < options.columnMinWidth ){
					decreaseAmount = options.columnMinWidth - column.computedDesiredWidth;
				}

				remainingOverflow-= decreaseAmount;
				column.computedDesiredWidth-= decreaseAmount;
				if( !largestColumn || column.computedDesiredWidth > largestColumn.computedDesiredWidth ){
					largestColumn = column;
				}
			});

			// remove remainingoverflow from the larger column (when Math.floor() lead to keep some width)
			if( remainingOverflow !== 0 && largestColumn ){
				largestColumn.computedDesiredWidth-= remainingOverflow;
			}
		}
		// the colmuns are too small
		else if( diff < 0 ){
			
		}
		
		widths = columns.map(function(column){
			return column.computedDesiredWidth;
		});
		
		return widths;
	},

	toString: function(){
		this.widths = this.computeWidths();
		var parts = [];
		if( options.className != 'compact' ) parts.push(this.drawTopLine());
		parts.push(this.drawTable());
		if( options.className != 'compact' ) parts.push(this.drawBottomLine());
		return parts.join('\n');
	}
});

Table.prototype.ansi.addFormat('border', 'grey');
Table.prototype.ansi.addFormat('header', 'cyan');

module.exports = Table;

/*

console.clear = function(){
	process.stdout.write('\u001B[2J\u001B[0;0f');
};

garder à l'esprit

process.stdout.on('resize')
process.stdout.columns // permet de connaitre la largeur de la fenêtre

autre manière
new Table(
	{id: 10, name: 'damien', email: 'dmail@gmail.com'},
	{id: 11, name: 'sandra', email, 'sandra@gmail.com'}
);
table.headers = 'auto';

new Table(
	{id: 10, email: 'damien@gmail.com', name: 'damien'}
)
table.headers = ['id', 'name', 'email'];
*/