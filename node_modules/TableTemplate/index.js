/*

pouvoir styliser le header, les bords
we doesn't support \n

https://github.com/Automattic/cli-table/blob/master/lib/index.js

une options pour dire en gros que la colonna fait la largeur mais ne s'adapte pas
'autoAbsolute'

On pourrait séparer en deux partie, un table dont on se sert pour définir comme remplir
(format, dependencies, compute, sort)
Et une tableu qui va ensuite juste calcule les bonne dimensions

*/

require('core/string');
require('core/array');

var proto = require('proto');

var Column = proto.create({
	order: null, // 1|-1 the table will be sorted by this column
	dependencies: null, // String|Number|Array this column depends of an other
	compute: null, // Function, a compute fonction called to get its content
	format: null, // Function
	width: 'auto',
	computedWidth: null,

	constructor: function(table, index, data){
		if( table.layout === 'fixed' ) this.width = 'fixed';
		else if( table.layout === 'auto' ) this.width = 'auto';

		if( typeof data === 'string' ){
			this.content = data;
		}
		else if( typeof data === 'object') {
			Object.assign(this, data);

			if( typeof this.dependencies === 'string' ) this.dependencies = [this.dependencies];
		}

		this.dependencyLevel = this.dependencies ? this.dependencies.length : 0;

		this.index = index;
	},

	computeWidth: function(){
		var width = this.width, computedWidth, columnCount = this.table.columnCount();

		if( typeof width === 'string' ){
			if( width === 'auto' ){
				computedWidth = this.idealWidth;
			}
			else if( width === 'fixed' ){
				computedWidth = Math.floor(this.table.availableWidth / columnCount);
				// la dernière colonne est un peu plus large si le % ne tombe pas juste
				// genre 100 avec 3 colonnes feras 33, 33, 34
				if( this.index === columnCount - 1 ){
					computedWidth+= this.table.availableWidth % columnCount;
				}
			}
			else if( width.slice(-1) === '%' ){
				var percent = parseInt(width.slice(0, -1), 10);
				computedWidth = Math.floor((percent / 100) * this.table.availableWidth);
			}
			else{
				computedWidth = parseInt(width, 10);
			}
		}
		else{
			computedWidth = width;
		}

		return computedWidth;
	},

	getCellWidths: function(){
		var widths = this.table.rows.map(function(cells){
			return this.table.getContentWidth(cells[this.index]);
		}, this);
		return widths;
	},

	measure: function(){
		this.cellWidths = this.getCellWidths();
		this.idealWidth = this.cellWidths.max();
		this.averageCellWidth = this.idealWidth / this.cellWidths.length;		
		this.computedWidth = this.computeWidth();
	},

	isAuto: function(){
		return this.width === 'auto';
	}	
});

var Table = proto.create({
	ansi: require('ansi'),
	Comparer: require('Array.sortBy').Comparer,
	Graph: require('DependencyResolver'),
	hasHeaders: true,
	chars: {
		'top': '─',
		'topMid': '┬',
		'topLeft': '┌',
		'topRight': '┐',
		'bottom': '─',
		'bottomMid': '┴',
		'bottomLeft': '└',
		'bottomRight': '┘',
		'left': '│',
		'leftMid': '├',
		'mid': '─',
		'midMid': '┼',
		'right': '│',
		'rightMid': '┤',
		'middle': '│'
	},
	sortBy: null, // [Number|String, 1|-1, ...]
	truncate: '…',
	width: '100%', // TODO à prendre en compte et accepter 'auto'
	layout: 'auto', // 'auto, fixed, [10, 'auto', 'fixed']'
	columnMinWidth: 3,
	colmunMaxWidth: 28,
	className: 'head',
	style: {
		'padding-left': 1,
		'padding-right': 1,
		'text-align': 'left',
		head: 'header',
		border: 'border'
	},

	constructor: function(){
		if( arguments.length ){
			this.setRows(Array.prototype.slice.call(arguments));
		}
		else{
			this.rows = [];
			this.columns = [];
		}

		var chars = this.chars;

		if( !chars.topLeft ) chars.topLeft = chars.top;
		if( !chars.topRight ) chars.topRight = chars.top;
		if( !chars.bottomLeft ) chars.bottomLeft = chars.bottom;
		if( !chars.bottomRight ) chars.bottomRight = chars.bottom;
	},

	createColumns: function(columns){
		this.columns = columns.map(function(columnHeader, i){
			return new Column(this, i, columnHeader);
		}, this);
	},

	setRows: function(rows){
		this.rows = rows;
		this.createColumns(rows[0]);
	},	

	setColumns: function(columns){
		this.createColumns(columns);
		this.rows.unshift(columns);
	},

	addRows: function(rows){
		this.rows.push.apply(this.rows, rows);
	},

	countColumn: function(){
		return this.columns.length;
	},

	countRow: function(){
		return this.rows.length;
	},

	sort: function(){
		var sortBy = this.sortBy, comparer = new this.Comparer(), i = 0, j = sortBy.length, arg, columnIndex;

		for(;i<j;i+=2){
			arg = sortBy[i];
			
			if( typeof arg === 'string' ){
				columnIndex = this.rows[0].indexOf(arg);
			}
			else if( typeof arg === 'number' ){
				columnIndex = arg;
			}

			comparer.addDistinction(function(row){
				return row[columnIndex];
			}, sortBy[i+1]);
		}

		if( this.hasHeaders ){
			this.rows = this.rows[0].concat(this.rows.slice(1).sort(comparer.compare));
		}
		else{
			this.rows = this.rows.sort(comparer.compare);
		}
	},

	getAvailableWidth: function(){
		var availableWidth = process.stdout.columns;		
		var columnCount = this.countColumn();

		availableWidth--; // we decrease of 1px else the line-height is doubled in the console

		if( columnCount ){
			availableWidth-= (columnCount - 1) * this.chars.left.length;
		}
		if( this.className != 'compact' ){
			availableWidth-= this.chars.left.length;
			availableWidth-= this.chars.right.length;	
		}

		return availableWidth;
	},

	getContentWidth: function(content){
		var width, length;

		length = String(content).length;

		width = length;
		width+= this.style['padding-left'];
		width+= this.style['padding-right'];

		if( typeof this.columnMinWidth === 'number' ) width = Math.max(this.columnMinWidth, length);
		if( typeof this.columnMaxWidth === 'number' ) width = Math.min(this.columnMaxWidth, length);

		return width;
	},

	computeWidths: function(){
		var table = this;
		var columns = this.columns;
		var column;
		var availableWidth = this.getAvailableWidth();
		var columnCount = this.countColumn();
		var i;
		var totalWidth;

		table.availableWidth = availableWidth;
		i = columnCount;
		totalWidth = 0;
		while(i--){
			column = columns[i];
			column.measure();
			totalWidth+= column.computedWidth;
		}

		var diff = totalWidth - availableWidth;	

		// le fait de diminuer/augmenter de manière équitable n'est pas bon, il faut faire un pourcentage
		// de la différence entre ce qui est demandé et ce qui est possible
		/*
		en tout je veux faire 100 mais j'ai que 70
		-> la colonne qui veut faire 80 est diminuer de 80% de 30
		-> la colonne qui veut faire 20 est diminuer de 20% de 30
		-> le reste est enlevé à la colonne la plus grande
		tenir copte de la largeur moyenne!

		pareil dans l'autre sens
		*/

		// the columns are too large
		if( diff > 0 ){
			var autoColumns = columns.filter(function(column){ return column.isAuto(); });
			// standard deviation would be useful in case some cell have very long texts
			var autoColumnsAverageSum = columns.map(function(column){ return column.averageCellWidth; }).sum();

			autoColumns.forEach(function(column){
				column.widthCoef = column.averageCellWidth / autoColumnsAverageSum;
			});

			var remainingOverflow = diff;
			var largestColumn = null;

			autoColumns.forEach(function(column, index){
				var decreaseAmount;
				decreaseAmount = Math.floor(diff * column.widthCoef);

				if( column.computedWidth - decreaseAmount < this.columnMinWidth ){
					decreaseAmount = this.columnMinWidth - column.computedWidth;
				}

				remainingOverflow-= decreaseAmount;
				column.computedWidth-= decreaseAmount;
				if( !largestColumn || column.computedWidth > largestColumn.computedWidth ){
					largestColumn = column;
				}
			});

			// remove remainingoverflow from the larger column (when Math.floor() lead to keep some width)
			if( remainingOverflow !== 0 && largestColumn ){
				largestColumn.computedWidth-= remainingOverflow;
			}
		}
		// the colmuns are too small
		else if( diff < 0 ){
			
		}
	},

	getBorder: function(name){
		if( this.style.border ) return this.ansi.format(this.chars[name], this.style.border);
		return this.chars[name];
	},

	drawLine: function(char, left, right, mid){
		var line = '';
		var border = this.getBorder(char);

		if( this.className != 'compact' ) line+= this.getBorder(left);
		this.columns.forEach(function(column, index, array){
			line+= border.repeat(column.computedWidth);
			if( index != array.length - 1 ) line+= this.getBorder(mid);
		}, this);
		if( this.className != 'compact' ) line+= this.getBorder(right);

		return line;
	},

	drawSepLine: function(){
		return this.drawLine('mid', 'leftMid', 'rightMid', 'midMid');
	},

	drawTopLine: function(){
		return this.drawLine('top', 'topLeft', 'topRight', 'topMid');
	},

	drawBottomLine: function(){
		return this.drawLine('bottom', 'bottomLeft', 'bottomRight', 'bottomMid');
	},

	drawCell: function(rowIndex, columnIndex){
		var content = String(this.rows[rowIndex][columnIndex]);
		var width = this.columns[columnIndex].computedWidth;

		width-= this.style['padding-left'];
		width-= this.style['padding-right'];

		content = content.replace(/\n/g, '\\n');

		var cell;

		if( content.length === width ){
			cell = content;
		}
		else if( content.length > width ){
			cell = content.truncate(width, this.chars.truncate);
		}
		else{
			if( this.style['text-align'] === 'left' ){
				cell = content.padRight(width - 1, ' ');
			}
			else if( this.style['text-align'] === 'right' ){
				cell = content.padLeft(width - 1, ' ');
			}
			else{
				cell = content.pad(width - 1, ' ');
			}
		}

		if( this.columns[rowIndex] ){
			cell = this.formats[rowIndex](cell);
		}
		if( rowIndex === 0 && this.hasHeaders ){
			cell = this.ansi.format(cell, this.style.head);
		}
		
		return [
			' '.repeat(this.style['padding-left'] || 0),
			cell,
			' '.repeat(this.style['padding-right'] || 0)
		].join('');
	},

	drawRow: function(rowIndex){
		var row = '', i = 0, j = this.countColumn();

		for(;i<j;i++){
			if( i !== 0 ) row+= this.getBorder('left');
			row+= this.drawCell(rowIndex, i);
		}
		if( this.className != 'compact' ){
			row = this.getBorder('left') + row + this.getBorder('right');
		}

		return row;
	},

	drawTable: function(){
		var table = '', i = 0, j = this.countRow();

		for(;i<j;i++){
			table+= this.drawRow(i);
			if( i != j - 1 ){
				table+= '\n';
				if( i === 0 || this.className === 'human' ){
					table+= this.drawSepLine();
					table+= '\n';
				}				
			}
		}

		return table;
	},

	getColumn: function(index){
		var type = typeof index;

		if( type === 'number' ){
			return this.columns[index];
		}
		if( type === 'string' ){
			var i = this.columns.length;
			while(i-- && this.columns[i].content !== index);
			return this.getColumn(i);
		}
		if( type === 'object'){
			return index;
		}
	},

	toString: function(){
		/*
		lorsqu'une colonne à des dépendances
		on va remplir le contenu en fonction des valeurs trouvé dans les colonnes en rapport
		il faudrais commencer par remplir les colonnes les moins dépendantes
		*/

		var columns = this.columns;
		var graph = new this.Graph();

		columns.forEach(function(column){
			if( column.dependencies ){
				graph.add(column, column.dependencies.map(this.getColumn, this));
			}
		});

		if( graph.size ){
			var dependentColumns = graph.sort();

			dependentColumns.forEach(function(column){
				// seul les colonnes ayant des dépendances
				if( column.dependencies.length ){
					this.rows.forEach(function(row, index){
						var values = column.dependencies.map(function(column){
							return this.rows[index][column.index];
						}, this);
						this.rows.splice(column.index, column.compute.apply(column, values));
					});
				}
			}, this);
		}

		if( this.sortBy ) this.sort();

		this.computeWidths();
		var parts = [];
		if( this.className != 'compact' ) parts.push(this.drawTopLine());
		parts.push(this.drawTable());
		if( this.className != 'compact' ) parts.push(this.drawBottomLine());
		return parts.join('\n');
	}
});

Table.prototype.ansi.addFormat('border', 'grey');
Table.prototype.ansi.addFormat('header', 'cyan');

module.exports = Table;

/*

console.clear = function(){
	process.stdout.write('\u001B[2J\u001B[0;0f');
};

garder à l'esprit

process.stdout.on('resize')
process.stdout.columns // permet de connaitre la largeur de la fenêtre

autre manière
new Table(
	{id: 10, name: 'damien', email: 'dmail@gmail.com'},
	{id: 11, name: 'sandra', email, 'sandra@gmail.com'}
);
table.headers = 'auto';

new Table(
	{id: 10, email: 'damien@gmail.com', name: 'damien'}
)
table.headers = ['id', 'name', 'email'];
*/