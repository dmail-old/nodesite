/*
we doesn't support \n
https://github.com/Automattic/cli-table/blob/master/lib/index.

setCellAsComputedFromColumn()
setCellAsTotalOfColumn()

*/

require('core/string');
require('core/array');

var proto = require('proto');

var Cell = proto.create({
	row: null,
	column: null,
	value: null, // unformatted value

	meta: null, // unused, data about the cell
	dependencies: [],
	getter: null,
	setter: null,
	fixed: false, // the cell is fixed (it cannot be sorted or moved)
	//className: null,	
	content: null, // formatted value
	//style: {},
	//width: null, // sera set par layout manager

	constructor: function(row, column, value){
		this.row = row;
		this.column = column;
		this.value = value;
	},

	getSortValue: function(){
		// if fixed this cell must not be sorted
		return this.fixed ? 1 : this.value;
	},

	compute: function(){
		if( !this.fixed && this.getter ){
			this.value = this.getter.apply(this, this.dependencies.map(function(cell){
				return cell.value;
			}));
		}
	},

	format: function(){
		var value = String(this.value);

		if( !this.fixed && this.setter ){
			value = this.setter(value);
		}

		value = value.replace(/\n/g, '\\n');

		this.contentWidth = value.length;
		this.content = value;

		return value;
	}
});

var Table = proto.create({
	Comparer: require('Array.sortBy').Comparer,
	Graph: require('DependencyResolver'),
	cells: null,

	constructor: function(){
		this.cells = [];

		if( arguments.length ){
			this.addRows(Array.prototype.slice.call(arguments));
		}
	},

	createCell: function(rowIndex, columnIndex, meta){
		var cell = new Cell(rowIndex, columnIndex, meta);
		return cell;
	},

	addRow: function(cellRow){
		var rowIndex = this.cells.length;

		this.cells[rowIndex] = cellRow.map(function(cellMeta, columnIndex){
			return this.createCell(rowIndex, columnIndex, cellMeta);
		}, this);
	},

	addRows: function(cellRows){
		var i = 0, j = cellRows.length;
		for(;i<j;i++){
			this.addRow(cellRows[i]);
		}
	},

	countRow: function(){
		return this.cells.length;	
	},

	countColumn: function(){
		var firstRow = this.cells[0];
		return firstRow ? firstRow.length : 0;
	},

	getColumn: function(index){
		var type = typeof index;

		if( type === 'number' ){
			return index;
		}
		if( type === 'string' ){
			var firstRow = this.cells[0], i = firstRow.length;
			while(i-- && firstRow[i].value !== index);
			return i;
		}
		if( index instanceof Cell ){
			return index.column;
		}

		return -1;
	},

	getRow: function(index){
		var type = typeof index;

		if( type === 'number' ){
			return index;
		}
		if( type === 'string' ){
			var i = this.cells.length;
			while(i-- && this.cells[i].value !== index);
			return i;
		}
		if( index instanceof Cell ){
			return index.row;
		}

		return -1;
	},

	eachCell: function(fn, bind){
		var cellRows = this.cells, i = 0, j = cellRows.length, cellRow, k, l;
		for(;i<j;i++){
			cellRow = cellRows[i];
			k = 0;
			l = cellRow.length;
			for(;k<l;k++){
				fn.call(bind, cellRow[k]);
			}
		}
	},

	eachRowCell: function(row, fn, bind){
		row = this.getRow(row);

		var cellRow = this.cells[row], i = 0, j = cellRow.length;

		for(;i<j;i++){
			fn.call(bind, cellRow[i]);
		}
	},

	eachColumnCell: function(column, fn, bind){
		column = this.getColumn(column);

		var cellRows = this.cells, i = 0, j = cellRows.length, index = column;

		for(;i<j;i++){
			fn.call(bind, cellRows[i][index]);
		}
	},

	setColumnFormat: function(column, formatter){
		this.eachColumnCell(column, function(cell){
			cell.setter = formatter;
		});
	},

	setColumnAsComputedFromColumns: function(column, columnDependencies, computer){
		if( !(columnDependencies instanceof Array) ) columnDependencies = [columnDependencies];
		columnDependencies = columnDependencies.map(this.getColumn, this);

		this.eachColumnCell(column, function(cell){
			cell.dependencies = columnDependencies.map(function(otherColumn){
				return this.cells[cell.row][otherColumn];
			}, this);
			cell.getter = computer;
		}, this);
	},

	setColumnWidth: function(column, width){
		this.eachColumnCell(column, function(cell){
			cell.width = width;
		});
	},

	setRowClass: function(row, className){
		this.eachRowCell(row, function(cell){
			cell.className = className;
		});
	},

	fixRow: function(row){
		this.eachRowCell(row, function(cell){
			cell.fixed = true;
		});
	},

	sortRowsBy: function(){
		this.sortBy = arguments;
	},

	sort: function(args){
		var comparer = new this.Comparer(), i = 0, j = args.length, arg, order, column;

		for(;i<j;i+=2){
			arg = args[i];
			order = args[i + 1];
			column = this.getColumn(arg);
			comparer.addDistinction(function(row){
				return row[column].getSortValue();
			}, order);
		}

		this.cells = this.cells.sort(comparer.compare);
	},

	toString: function(){
		/*
		lorsqu'une colonne à des dépendances
		on va remplir le contenu en fonction des valeurs trouvé dans les colonnes en rapport
		il faudrais commencer par remplir les colonnes les moins dépendantes
		*/

		var graph = new this.Graph();

		this.eachCell(function(cell){
			graph.add(cell, cell.dependencies);
		});
		
		var orderedCells = graph.sort();

		// obtiens les valeurs des cellules dans le bon ordre
		orderedCells.forEach(function(cell){
			cell.compute();
		}, this);

		// génère le contenu formatté depuis la valeur de la celulle
		orderedCells.forEach(function(cell){
			cell.format();
		});

		if( this.sortBy ){
			this.sort(this.sortBy);
		}

		return new TableRenderer(this).toString();
	}
});

var ColumnLayout = proto.create({
	constructor: function(cellWidths){
		this.cellWidths = cellWidths;
		this.maxCellWidth = cellWidths.max();
		this.averageCellWidth = cellWidths.sum() / cellWidths.length;
		this.width = this.maxCellWidth;
	}
});

/*
will set a width to all cells

- table.layout
- else cell.style.width
- else cell.contentWidth
*/
var CellWidthManager = proto.create({
	minWidth: 3,

	constructor: function(tableRenderer){
		this.tableRenderer = tableRenderer;
		this.table = tableRenderer.table;
		this.type = tableRenderer.layout;

		this.columnCount = this.table.countColumn();
		this.offsetWidth = this.getOffsetWidth();
		this.availableWidth = this.getAvailableWidth();
		this.width = this.getWidth(tableRenderer.style.width);
		
		this.computeWidths();
	},

	getOffsetWidth: function(){
		// we decrease of 1px else the line-height is doubled in the console
		return process.stdout.columns - 1;
	},

	getAvailableWidth: function(){
		var renderer = this.tableRenderer, cumulativeInnerBorderSize, availableWidth;		

		if( this.columnCount ){
			cumulativeInnerBorderSize = (this.columnCount - 1) * this.tableRenderer.innerBorderSize;
		}
		else{
			cumulativeInnerBorderSize = 0;
		}

		availableWidth = this.offsetWidth - renderer.borderLeftSize - renderer.borderRightSize - cumulativeInnerBorderSize;

		return availableWidth;
	},

	isPercentage: function(value){
		return typeof value === 'string' && value.slice(-1) === '%';
	},

	percent: function(percent, value){
		percent = parseInt(percent.slice(0, -1), 10);
		return Math.floor((percent / 100) * value);
	},

	getWidth: function(widthStyle){
		var width;

		if( typeof widthStyle === 'string' ){
			if( widthStyle === 'auto' ){
				width = this.availableWidth;
			}
			if( this.isPercentage(widthStyle) ){
				width = this.percent(widthStyle, this.availableWidth);
			}
		}
		else if( typeof widthStyle === 'number' ){
			width = widthStyle;
		}

		return width;
	},	

	fixedWidth: function(){
		var width = this.width;
		var columnCount = this.columnCount;
		var cellWidth = width / columnCount;
		var modulo = width % columnCount;

		this.table.eachCell(function(cell){
			cell.style = this.tableRenderer.cellStyle;
			cell.width = cellWidth;
		}, this);

		if( modulo !== 0 ){
			this.table.eachColumnCell(columnCount - 1, function(cell){
				cell.width-= modulo;
			});
		}
	},

	getCellWidth: function(cell){
		cell.style = this.tableRenderer.cellStyle;

		var width;

		if( cell.style.width === 'auto' ){
			width = cell.contentWidth;
		}
		else if( typeof cell.style.width === 'number' ){
			width = cell.style.width;
		}
		else if( this.isPercentage(cell.style.width) ){
			width = this.percent(cell.style.width, this.availableWidth);
		}

		width+= cell.style.paddingLeft;
		width+= cell.style.paddingRight;

		if( typeof cell.style.minWidth === 'number' ) width = Math.max(cell.style.minWidth, width);
		if( typeof cell.style.maxWidth === 'number' ) width = Math.min(cell.style.maxWidth, width);		

		return width;
	},

	getCellsWidthInColumn: function(column){
		var widths = [];
		this.table.eachColumnCell(column, function(cell){
			widths.push(this.getCellWidth(cell));
		}, this);
		return widths;
	},

	autoWidth: function(){
		var columnCount = this.columnCount;
		var i = 0, j = columnCount;
		var columns = [];
		var column;
		var totalCellWidth = 0;
		var totalAverageCellWidth = 0;
		var diff;
		var tableWidth = this.width;
		var remainingOverflow;

		for(;i<j;i++){
			column = new ColumnLayout(this.getCellsWidthInColumn(i));
			columns.push(column);
			totalCellWidth+= column.maxCellWidth;
			// standard deviation would be useful in case some cell have very long texts
			totalAverageCellWidth+= column.averageCellWidth;
		}

		diff = totalCellWidth - tableWidth;

		// the columns are too large because of cells
		if( diff > 0 ){
			remainingOverflow = diff;
			var decreaseAmount;
			var coef;
			var largestColumn = null;
			var maxCellWidth;
			var width;

			columns.forEach(function(column){
				coef = column.averageCellWidth / totalAverageCellWidth;
				decreaseAmount = Math.floor(diff * coef);
				maxCellWidth = column.maxCellWidth;
				width = maxCellWidth - decreaseAmount;

				if( width < this.minWidth ){
					decreaseAmount = this.minWidth - maxCellWidth;
					width = this.minWidth;
				}

				remainingOverflow-= decreaseAmount;
				column.width = width;

				if( !largestColumn || width > largestColumn.width ){
					largestColumn = column;
				}
			}, this);

			// remove remainingoverflow from the largest column
			// (when Math.floor() for decreaseAmount lead to keep some width)
			if( remainingOverflow !== 0 && largestColumn ){
				largestColumn.width-= remainingOverflow;
			}
		}
		// the colmuns are too small, we increase their size proportionnaly
		else if( diff < 0 ){
			remainingOverflow = diff;
			var increaseAmount = Math.floor(Math.abs(diff+1) / columns.length);	

			columns.forEach(function(column){
				remainingOverflow+= increaseAmount;
				column.width+= increaseAmount;
			});

			if( remainingOverflow !== 0 ){
				columns[columns.length-1].width-= remainingOverflow + 1;
			}
		}

		while(columnCount--){
			this.table.setColumnWidth(columnCount, columns[columnCount].width);
		}
	},

	computeWidths: function(){
		if( this.type === 'fixed' ){
			this.fixedWidth();
		}
		else if( this.type === 'auto' ){
			this.autoWidth();
		}
	}
});

var TableRenderer = proto.create({
	ansi: require('ansi'),
	chars: {
		'top': '─',
		'topMid': '┬',
		'topLeft': '┌',
		'topRight': '┐',
		'bottom': '─',
		'bottomMid': '┴',
		'bottomLeft': '└',
		'bottomRight': '┘',
		'left': '│',
		'leftMid': '├',
		'mid': '─',
		'midMid': '┼',
		'right': '│',
		'rightMid': '┤',
		'middle': '│'
	},
	className: 'head',
	truncate: '…',
	layout: 'auto',  // 'auto' | 'fixed' (proportionnal)
	style: {
		width: '100%', // 'auto' | '0-100%' | Number
		head: 'header',
		border: 'border',
	},
	cellStyle: {
		width: 'auto',
		paddingLeft: 1,
		paddingRight: 1,
		textAlign: 'left',
		minWidth: 3,
		maxWidth: null//28,
	},

	constructor: function(table){
		var chars = this.chars;

		if( !chars.topLeft ) chars.topLeft = chars.top;
		if( !chars.topRight ) chars.topRight = chars.top;
		if( !chars.bottomLeft ) chars.bottomLeft = chars.bottom;
		if( !chars.bottomRight ) chars.bottomRight = chars.bottom;

		if( this.className === 'compact' ){
			this.borderLeftSize = 0;
			this.borderRightSize = 0;
		}
		else{
			this.borderLeftSize = this.chars.left.length;
			this.borderRightSize = this.chars.right.length;
		}
		this.innerBorderSize = this.chars.left.length;

		this.table = table;
		this.manager = new CellWidthManager(this);
	},

	getBorder: function(name){
		if( this.style.border ) return this.ansi.format(this.chars[name], this.style.border);
		return this.chars[name];
	},

	drawLine: function(char, left, right, mid){
		var line = '';
		var border = this.getBorder(char);
		var row = this.table.cells[0];

		row.forEach(function(cell, index, array){
			line+= border.repeat(cell.width);
			if( index != array.length - 1 ) line+= this.getBorder(mid);
		}, this);
		
		if( this.className != 'compact' ){
			line = this.getBorder(left) + line + this.getBorder(right);
		}

		return line;
	},

	drawSepLine: function(){
		return this.drawLine('mid', 'leftMid', 'rightMid', 'midMid');
	},

	drawTopLine: function(){
		return this.drawLine('top', 'topLeft', 'topRight', 'topMid');
	},

	drawBottomLine: function(){
		return this.drawLine('bottom', 'bottomLeft', 'bottomRight', 'bottomMid');
	},

	drawCell: function(rowIndex, columnIndex){
		var cell = this.table.cells[rowIndex][columnIndex];
		var width = cell.width;
		var textAlign = cell.style.textAlign;
		var contentWidth = cell.contentWidth;
		var content;

		width-= cell.style.paddingLeft;
		width-= cell.style.paddingRight;

		if( contentWidth === width ){
			content = cell.content;
		}
		else if( contentWidth > width ){
			content = cell.content.truncate(width, this.chars.truncate);
		}
		else{
			if( textAlign === 'left' ){
				content = cell.content.padRight(width - 1, ' ');
			}
			else if( textAlign === 'right' ){
				content = cell.content.padLeft(width - 1, ' ');
			}
			else{
				content = cell.content.pad(width - 1, ' ');
			}
		}

		if( cell.className ){
			content = this.ansi.format(content, cell.className);
		}	
		
		return [
			' '.repeat(cell.style.paddingLeft || 0),
			content,
			' '.repeat(cell.style.paddingRight || 0)
		].join('');
	},

	drawRow: function(rowIndex){
		var row = '', i = 0, j = this.table.countColumn();

		for(;i<j;i++){
			if( i !== 0 ) row+= this.getBorder('left');
			row+= this.drawCell(rowIndex, i);
		}
		if( this.className != 'compact' ){
			row = this.getBorder('left') + row + this.getBorder('right');
		}

		return row;
	},

	drawTable: function(){
		var table = '', i = 0, j = this.table.countRow();

		for(;i<j;i++){
			table+= this.drawRow(i);
			if( i != j - 1 ){
				table+= '\n';
				if( i === 0 || this.className === 'human' ){
					table+= this.drawSepLine();
					table+= '\n';
				}				
			}
		}

		return table;
	},

	toString: function(){
		var parts = [];
		if( this.className != 'compact' ) parts.push(this.drawTopLine());
		parts.push(this.drawTable());
		if( this.className != 'compact' ) parts.push(this.drawBottomLine());
		return parts.join('\n');
	}
});

TableRenderer.prototype.ansi.addFormat('border', 'grey');
TableRenderer.prototype.ansi.addFormat('header', 'cyan');

module.exports = Table;

/*
console.clear = function(){
	process.stdout.write('\u001B[2J\u001B[0;0f');
};
*/