
var proto = require('proto');
var debug = require('debug');
var toSize = require('./toSize');
var ColumnLayout = require('./ColumnLayout');

var TableLayout = proto.create({
	table: null,
	type: null,
	containerWidth: 0,
	availableWidth: 0,
	desiredWidth: 0, // sum of column width

	constructor: function(tableTemplate){
		this.table = tableTemplate;
		this.type = tableTemplate.layout;

		this.columnCount = tableTemplate.cells.length ? tableTemplate.cells[0].length : 0;
		this.containerWidth = this.getContainerWidth();
		this.availableWidth = this.getAvailableWidth();

		debug('table dimensions', 'container', this.containerWidth,
			'available', this.availableWidth, 'width', this.width);
	},

	getContainerWidth: function(){
		// we decrease of 1px else the line-height is doubled in the console
		return process.stdout.columns - 1;
	},

	getAvailableWidth: function(){
		var table = this.table, cumulativeInnerBorderSize, availableWidth;

		if( this.columnCount ){
			cumulativeInnerBorderSize = (this.columnCount - 1) * table.innerBorderSize;
		}
		else{
			cumulativeInnerBorderSize = 0;
		}

		availableWidth = this.containerWidth - table.borderLeftSize - table.borderRightSize - cumulativeInnerBorderSize;

		return availableWidth;
	},

	fixedWidth: function(columns){
		var styleWidth = this.table.style.width;
		var remainingWidth = styleWidth === 'auto' ? this.availableWidth : toSize(styleWidth, this.availableWidth);
		var resizableColumns = columns.filter(function(column){
			if( column.resizable === false ){
				remainingWidth-= column.width;
				return false;
			}
			return true;
		});
		var columnCount = resizableColumns.length;
		if( columnCount ){
			var columnWidth = remainingWidth / columnCount;
			var modulo = remainingWidth % columnCount;

			resizableColumns.forEach(function(column){
				column.setWidth(columnWidth);
			});
			if( modulo !== 0 ){
				resizableColumns[columnCount - 1].decreaseWidth(modulo);
			}
		}
	},

	autoWidth: function(columns){
		var styleWidth = this.table.style.width;
		var remainingWidth = styleWidth === 'auto' ? this.availableWidth : toSize(styleWidth, this.availableWidth);
		var diff = this.desiredWidth - remainingWidth;
		var remainingOverflow = diff;
		var resizableColumns;

		if( diff === 0 || (diff < 0 && styleWidth === 'auto') ) return;

		resizableColumns = columns.filter(function(column){
			return column.resizable === true;
		});

		// the columns are too large because of cells
		if( diff > 0 ){
			// standard deviation would be useful if few cell in a column have very long text
			var totalAverageCellWidth = resizableColumns.reduce(function(prev, column){
				return prev + column.averageCellWidth;
			}, 0);
			var largestColumn = null;

			resizableColumns.forEach(function(column, index){
				var coef = column.averageCellWidth / totalAverageCellWidth;
				var decreaseAmount = Math.floor(diff * coef);
				var oldWidth = column.width;
				var decreasedAmount = column.decreaseWidth(decreaseAmount);
				remainingOverflow-= decreasedAmount;

				if( !largestColumn || column.width > largestColumn.width ) largestColumn = column;

				debug('decreasing column width from', oldWidth, 'to', column.width, '(', decreasedAmount, ')');
			}, this);

			// remove remainingoverflow from the largest column
			// (when Math.floor() for decreaseAmount lead to keep some width)
			if( remainingOverflow !== 0 && largestColumn ){
				debug('there is a remaining overflow of', remainingOverflow);
				largestColumn.setWidth(largestColumn.width - remainingOverflow);
			}
		}
		// the colmuns are too small, we increase their size proportionnaly
		else if( diff < 0 ){		
			var increaseAmount = Math.floor(Math.abs(diff + 1) / resizableColumns.length);

			resizableColumns.forEach(function(column, index){
				var oldWidth = column.width;
				var increasedAmount = column.increaseWidth(increaseAmount);
				remainingOverflow+= increasedAmount;
				debug('increasing column width from', oldWidth, 'to', column.width, '(', increasedAmount, ')');
			});

			if( remainingOverflow !== 0 ){
				var lastColumn = resizableColumns[resizableColumns.length-1];
				lastColumn.increaseWidth(remainingOverflow);
			}
		}
	},

	computeWidths: function(){
		/*
		// en gros lorsqu'il y a trop de colonne faudrait slice() les colonnes
		// et dans la dernière colonne indiquer que la suite du tableau n'est pas affiché
		if( columnCount * this.minWidth > this.availableWidth  ){

		}
		*/

		var columnCount = this.columnCount, i = 0, j = columnCount;
		var columns = [], column, columnLayout;

		for(;i<j;i++){
			column = this.table.column(i);
			columnLayout = new ColumnLayout(column, this.availableWidth);
			this.desiredWidth+= columnLayout.width;
			columns.push(columnLayout);			
		}

		if( this.type === 'fixed' ){
			this.fixedWidth(columns);
		}
		else if( this.type === 'auto' ){
			this.autoWidth(columns);
		}

		columns.forEach(function(column, index){
			debug('setting column n°', index, 'width to', column.width);
			column.column.set('width', column.width);
		});
	}
});

module.exports = TableLayout;