/*

*/

var APP_MODULE_PATH = '../../app/node_modules';
var instance = require(APP_MODULE_PATH + '/Object.instance');

var Stream = require('stream');
var PassThrough = Stream.PassThrough;
var TransformStream = require('stream').Transform;
var Formatters = require('./LogFormatters');

var LogStream = instance.extend.call(TransformStream.prototype, {	
	fileSystem: require('fs'),
	formatters: {
		'json': Formatters.json,
		'colored' : Formatters.colored,
		'raw': Formatters.raw,
	},
	formats: null,

	level: 'info',
	levels: ['info', 'debug', 'warn', 'error', 'fatal'],
	// options
	filePath: null,
	console: true,

	init: function(options){
		this.constructor.apply(this, arguments); // or TransformStream.apply(this, arguments)
		this._writableState.objectMode = true;
		this._readableState.objectMode = true;

		this.formats = {};

		if( typeof options == 'string' ){
			options = {filePath: options};
		}
		for(var key in options){
			this[key] = options[key];
		}

		if( typeof this.filePath == 'string' ){
			this.pipe(this.createFileStream(this.filePath));
		}
		if( this.console === true ){
			this.pipe(process.stdout);
		}
	},

	_transform: function(chunk, encoding, done){

		// when string are written to this stream we check if we can restore a log from a JSON object
		var string, result;

		if( Buffer.isBuffer(chunk) ){
			string = chunk.toString();
		}
		else if( typeof chunk === 'string' ){
			string = chunk;
		}
		else if( typeof chunk == 'object' ){
			result = chunk;
		}

		if( string && string[0] == '{' ){
			try{
				result = JSON.parse(string);
			}
			catch(e){
				result = chunk;
			}
		}
		else{
			result = chunk;
		}

		this.push(result);
		done();
	},

	getStream: function(type){
		var stream;

		if( type in this.formats ){
			stream = this.formats[type];
		}
		else{
			stream = this.formatters[type].new();
			this.formats[type] = stream;

			/*var self = this;
			stream.on('pipe', function(writableStream){
				console.log('pipe colored', this._readableState.pipesCount);	
			});
			stream.on('unpipe', function(){
				if( this._readableState.pipesCount === 0 ){
					self.unpipe(stream);
				}
			});
			*/

			this.pipe(stream);
		}

		return stream;
	},

	pipe: function(stream, options){
		// use coloredStream for console
		if( stream.isTTY ){
			this.getStream('colored').pipe(stream, options);
		}
		// use rawStream for files
		else if( typeof stream.path == 'string' ){
			this.getStream('raw').pipe(stream, options);
		}
		// use JSON stream if the stream does not support objects
		else if( stream._writableState.objectMode === false ){
			this.getStream('json').pipe(stream, options);
		}
		// use this stream, emitting object
		else{
			this.constructor.prototype.pipe.call(this, stream, options);
		}
	},

	createFileStream: function(path){
		return this.fileSystem.createWriteStream(this.filePath, {flags: 'a', encoding: 'utf8', mode: 0666});
	},

	getLevelIndex: function(level){
		return this.levels.indexOf(level);
	},

	canLog: function(level){
		return this.getLevelIndex(level) >= this.getLevelIndex(this.level);
	},

	log: function(level, message, data){
		if( this.canLog(level) ){
			if( arguments.length > 3 || typeof data != 'object' ){
				data = Array.prototype.slice.call(arguments, 2);
			}

			return this.write({
				level: level,
				message: message,
				data: data
			});
		}
		return false;
	}
});

LogStream.formatters.colored.styles = LogStream.styles = {
	'info': {color: 'green'},
	'help': {color: 'cyan'},
	'warn': {color: 'yellow', font: 'bold'},
	'debug': {color: 'grey', font: 'bold'},
	'error': {color: 'red', font: 'bold'}
};

LogStream.levels.forEach(function(level){
	LogStream[level] = function(){
		return this.log.apply(this, [level].concat(Array.apply(Array, arguments)));
	};
});

module.exports = LogStream;