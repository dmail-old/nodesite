/*

Il y a un problème lorsque j'écris dans la console tout est mis dans un buffer
ce même buffer peut donc écrire plusieur log à la suite les uns des autres, dans ce cas je ne peux pas récup
le log et il s'affiche au format JSON, ce qui est moche

*/

var proto = require('proto');
var Stream = require('stream');
var PassThrough = Stream.PassThrough;
var TransformStream = require('stream').Transform;
var Formatters = require('./LogFormatters');

var LogStream = proto.createFrom(PassThrough.prototype, {	
	Log: require('./Log'),
	fileSystem: require('fs'),
	formatters: {
		'json': Formatters.json,
		'colored': Formatters.colored,
		'raw': Formatters.raw,
	},
	formats: null,

	level: 'log',
	levels: ['log', 'info', 'debug', 'warn', 'error', 'fatal'],
	// options
	filePath: null,
	console: true,

	init: function(options){
		this.constructor.apply(this, arguments);

		this._writableState.objectMode = true;
		this._readableState.objectMode = true;

		this.formats = {};

		if( typeof options == 'string' ){
			options = {filePath: options};
		}
		for(var key in options){
			this[key] = options[key];
		}

		if( typeof this.filePath == 'string' ){
			this.pipe(this.createFileStream(this.filePath));
		}
		if( this.console === true ){
			this.pipe(process.stdout);
		}
	},

	/*
	_transform: function(chunk, encoding, done){
		
		
		// when string are written to this stream we check if we can restore a log from a JSON object
		var string, result;

		if( Buffer.isBuffer(chunk) ){
			string = chunk.toString();
		}
		else if( typeof chunk === 'string' ){
			string = chunk;
		}
		else if( typeof chunk == 'object' ){
			result = chunk;
		}		
		
		if( string && string[0] == '{' ){
			try{
				result = JSON.parse(string);
			}
			catch(e){
				result = chunk;
			}
		}
		else{
			result = chunk;
		}		

		this.push(chunk, encoding);
		done();
	},
	*/

	getStream: function(type){
		var stream;

		if( type in this.formats ){
			stream = this.formats[type];
		}
		else{
			stream = this.formatters[type].new();
			this.formats[type] = stream;

			/*var self = this;
			stream.on('pipe', function(writableStream){
				console.log('pipe colored', this._readableState.pipesCount);	
			});
			stream.on('unpipe', function(){
				if( this._readableState.pipesCount === 0 ){
					self.unpipe(stream);
				}
			});
			*/

			this.pipe(stream);
		}

		return stream;
	},

	pipe: function(stream, options){
		// use coloredStream for console
		if( stream.isTTY ){
			this.getStream('colored').pipe(stream, options);
		}
		// use rawStream for files
		else if( typeof stream.path == 'string' ){
			this.getStream('raw').pipe(stream, options);
		}
		// use JSON stream if the stream does not support objects
		else if( stream._writableState.objectMode === false ){
			this.getStream('json').pipe(stream, options);
		}
		// use this stream, emitting object
		else{
			this.constructor.prototype.pipe.call(this, stream, options);
		}
	},

	createFileStream: function(path){
		return this.fileSystem.createWriteStream(this.filePath, {flags: 'a', encoding: 'utf8', mode: 0666});
	},

	getLevelIndex: function(level){
		return this.levels.indexOf(level);
	},

	canWrite: function(level){
		return this.getLevelIndex(level) >= this.getLevelIndex(this.level);
	},

	createLog: function(message, data, styles){
		var log = this.Log.new(message);

		if( arguments.length === 1 ){
			// cas particulier où on crée un log qui inspecte message
			// et non pas un logdynamique avec template et tout
		}
		else{
			if( styles ) log.registerStyles(styles);
			log.exec(data);
		}

		return log;
	},

	writeLog: function(log, fn){
		if( this.canWrite(log.level) ){
			return this.write(log, fn);
		}
		return false;
	}
});

LogStream.levels.forEach(function(level){
	LogStream[level] = function(message, data, styles, fn){
		if( typeof styles == 'function' ){
			fn = styles;
			styles = null;
		}

		var log = this.createLog(message, data, styles);
		log.level = level;
		return this.writeLog(log, fn);
	};
});

module.exports = LogStream;
