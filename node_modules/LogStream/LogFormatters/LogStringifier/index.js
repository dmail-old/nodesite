var proto = require('proto');
var LogStringifier = proto.create({
	stackTrace: require('stackTrace'),
	ansi: require('ansi'),
	inspect: require('util').inspect,
	fileSystem: require('fs'),

	autoReturn: true,
	regexp: /{(.*?)}/g,
	styles: {},
	depth: 2,
	showHidden: false,

	options: null,
	optionNames: ['colorize'],
	colorize: true,
	level: null,
	message: null,
	data: null,
	dataIsArray: false,

	init: function(log, options){
		this.level = log.level;
		this.message = log.message;
		this.data = log.data;

		if( options ){
			this.options = options;
			this.optionNames.forEach(this.initOption, this);
		}

		if( this.data instanceof Array ){
			this.dataIsArray = true;
			this.hasReplacement = this.hasArrayReplacement;
			this.replacement = this.arrayReplacement;
		}
		else{
			this.dataIsArray = false;
			this.hasReplacement = this.hasObjectReplacement;
			this.replacement = this.objectReplacement;
		}
	},

	initOption: function(name){
		if( name in this.options ) this[name] = this.options[name];
	},

	stringify: function(item){
		return this.inspect(item, {
			showHidden: this.showHidden,
			depth: this.depth,
			colors: this.colorize,
			customInspect: true
		});
	},

	getMessageAsString: function(){
		var message = this.message;

		if( typeof message != 'string' ){
			message = this.stringify(message);
		}

		return message;
	},

	// TODO: rewrite this function
	createDebugMessage: function(message){
		/*
		var call, wrap, lineFile, lineNumber, lineContent, levelPrefix;

		call = this.stackTrace.get()[1];
		lineFile = call.getFileName();
		lineNumber = call.getFileNumber();
		lineContent = this.stackTrace.readFileLine(lineFile, lineNumber);
		lineContent = lineContent.replace(/\n|\r/, '');
		message = message.replace(/\n|\r/g, function(match){ return match + '{debug}: '; });

		wrap = '\
			{debug}: \n\
			{debug}: {lineContent} ({lineFile: {lineNumber}})\n\
			{debug}: {message}\n\
			{debug}: \
		';

		return this._render(wrap, {
			debug: 'debug',
			message: message,
			lineContent: lineContent,
			lineFile: lineFile,
			lineNumber: lineNumber
		});
		*/
		return message;
	},

	createLevelMessage: function(level, message){
		if( level === 'debug' ){
			return this.createDebugMessage(message);
		}
		return this.stylize(level, level) + ': ' + message;
	},

	stylize: function(str, styleName){
		if( this.colorize ){
			if( styleName in this.styles ){
				str = this.ansi.stylizeAll(str, this.styles[styleName]);
			}
		}
		return str;
	},

	hasArrayReplacement: function(key){
		return this.index in this.data;
	},

	arrayReplacement: function(key){
		return this.format(this.data[this.index]);
	},

	hasObjectReplacement: function(key){
		return key in this.data;
	},	

	objectReplacement: function(key){
		return this.format(this.data[key]);
	},

	replacer: function(match, key){
		var value;
		
		if( this.hasReplacement(key) ){
			value = this.replacement(key);
			value = this.stylize(value, key);
		}
		else{
			value = match;
		}

		this.index++;

		return value;
	},

	replace: function(message, replacer, bind){
		this.index = 0;
		if( typeof bind != 'undefined' ) replacer = replacer.bind(bind);
		else replacer = replacer.bind(this);

		return message.replace(this.regexp, replacer);
	},

	format: function(value){
		//return require('util').inspect(value);

		if( typeof value == 'string' ) return value;
		try{
			return JSON.stringify(value);
		}
		catch(e){
			return '[Circular]';
		}
	},

	toJSON: function(){
		var message = this.getMessageAsString();
		var level = this.level;
		var data = this.data;
		var jsonData;

		/* create a short version of the data

		to resume calling
		logger.log('info', 'name: {name}', {name: 'damien', age:10});
		must ignore the age property to shorten the data passed to the streams
		logger.log('info', 'name: {name}', {name: 'damien', age:10});
		*/

		if( data == null ){
			jsonData = null;
		}
		else{
			if( this.dataIsArray ){
				jsonData = [];
				this.replace(message, function(match){
					if( this.index in this.data ){
						jsonData[this.index] = this.format(this.data[this.index]);
					}
					this.index++;
					return match;
				});
			}
			else{
				jsonData = {};
				this.replace(message, function(match, key){
					if( key in this.data ){
						jsonData[key] = this.format(this.data[key]);
					}
					return match;
				});
			}			
		}

		return {
			message: message,
			level: level,
			data: jsonData
		};
	},

	toString: function(){
		var message = this.getMessageAsString(), level = this.level, data = this.data;

		message = this.createLevelMessage(level, message);
		if( data !== null ){
			message = this.replace(message, this.replacer);
		}
		if( this.autoReturn ) message+= '\n';

		return message;
	}
});

module.exports = LogStringifier;