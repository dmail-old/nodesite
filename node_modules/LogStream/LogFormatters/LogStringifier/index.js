// https://github.com/visionmedia/callsite/blob/master/lib/__stack.js
Object.defineProperty(global, '__stack', {
	get: function(){
		var orig = Error.prepareStackTrace;
		Error.prepareStackTrace = function(_, stack){ return stack; };
		var err = new Error();
		Error.captureStackTrace(err, arguments.callee);
		var stack = err.stack;
		Error.prepareStackTrace = orig;
		return stack;
	}
});

var LogStringifier = {
	ansi: require('ansi'),
	inspect: require('util').inspect,
	fileSystem: require('fs'),

	autoReturn: true,
	regexp: /{(.*?)}/g,
	styles: {},
	depth: 2,
	showHidden: false,

	options: null,
	optionNames: ['colorize'],
	colorize: true,
	level: null,
	message: null,
	data: null,

	init: function(log, options){
		this.level = log.level;
		this.message = log.message;
		this.data = log.data;

		if( options ){
			this.options = options;
			this.optionNames.forEach(this.initOption, this);
		}

		if( this.data instanceof Array ){
			this.index = 0;
			this.replacer = this.replaceArray;
		}
		else if( typeof data == 'object' ){
			this.replacer = this.replaceObject;
		}
		else{
			this.replacer = this.replaceOther;
		}
	},

	initOption: function(name){
		if( name in this.options ) this[name] = this.options[name];
	},

	// TODO: rewrite this function
	createDebugMessage: function(message){
		/*
		var call, wrap, lineFile, lineNumber, fileContent, lineContent, levelPrefix;

		call = global.__stack[1];
		lineFile = call.getFileName();
		lineNumber = call.getFileNumber();
		fileContent = this.fileSystem.readFileSync(lineFile, 'utf8');
		lineContent = fileContent.split('\n')[lineNumber];
		lineContent = lineContent.replace(/\n|\r/, '');
		message = message.replace(/\n|\r/g, function(match){ return match + '{debug}: '; });

		wrap = '\
			{debug}: \n\
			{debug}: {lineContent} ({lineFile: {lineNumber}})\n\
			{debug}: {message}\n\
			{debug}: \
		';

		return this._render(wrap, {
			debug: 'debug',
			message: message,
			lineContent: lineContent,
			lineFile: lineFile,
			lineNumber: lineNumber
		});
		*/
		return message;
	},

	createLevelMessage: function(level, message){
		if( level === 'debug' ){
			return this.createDebugMessage(message);
		}
		return this.stylize(level, level) + ': ' + message;
	},

	stylize: function(str, styleName){
		if( this.colorize ){
			if( styleName in this.styles ){
				str = this.ansi.stylizeAll(str, this.styles[styleName]);
			}
		}
		return str;
	},

	replaceArray: function(match, key){
		var value;
		if( this.index in this.data ){
			value = this.data[this.index];
			value = this.stylize(value, key);
		}
		this.index++;
		return value;
	},

	replaceObject: function(match, key){
		var value;
		if( key in this.data ){
			value = this.data[key];
			value = this.stylize(value, key);
		}

		return value;
	},

	replaceOther: function(match, key){
		return match;
	},

	replace: function(match, key){
		return this.replacer.call(this, match, key);
	},

	stringify: function(item){
		return this.inspect(item, {
			showHidden: this.showHidden,
			depth: this.depth,
			colors: this.colorize,
			customInspect: true
		});
	},

	toString: function(){
		var message = this.message, level = this.level, data = this.data;

		if( typeof message != 'string' ){
			message = this.stringify(message);
		}

		message = this.createLevelMessage(level, message);

		if( data !== null ){
			message = message.replace(this.regexp, this.replace.bind(this));
		}

		if( this.autoReturn ) message+= '\n';

		return message;
	}
};

module.exports = LogStringifier;