proto
=============

Use your objects as prototypes.

## Example

```javascript
var proto = require('proto');

var User = proto.create({
	name: null,
	
	constructor: function(name){
		this.name = name;
	},
	
	get firstLetter(){
		return this.name[0];
	}
});

var Admin = User.create({
	type: 'admin'
});

// create a user
var user = User.new('foo');

Object.getPrototypeOf(user); // User
User.isPrototypeOf(user); // true
user.firstLetter; // 'f'

// create an admin
var admin = Admin.new('bar');

Object.getPrototypeOf(admin); // Admin
User.isPrototypeOf(admin); // true
admin.firstLetter; // 'b'
```

## Requirements

- [property](../property)

## Browser compatibility

All browsers are supported but stuff* related to custom properties depends on [Object.defineProperty compat](http://kangax.github.io/es5-compat-table/#Object.defineProperty) :
 - Firefox 5+
 - Chrome 4+
 - Internet Explorer 9+
 - Opera 11.6+
 - Safari 5.1+
 
(*) In an environment without Object.defineProperty basic stuff works but the following cannot be used (get firstLetter(), Object.defineProperty, Object.getOwnPropertyDescriptor, ...)

## supplement(...)

Define properties in arguments on this. Uses [propertyArgumentsAPI](#propertyargumentsapi) and support custom property.

```javascript
var a = proto.create();
var b = {name: 'damien'};
var c = {
	get value(){
		return 'foo';
	}
};

// add b and c properties to a
a.supplement(b, c);
a.name; // 'damien'
a.value; // 'foo'
```

## create(...)

Return an object linked by prototype to this. See [Object.create](http://msdn.microsoft.com/fr-fr/library/ff925952%28v=vs.94%29.aspx).  
Arguments passed to create are added to object with supplement.

```javascript
var instance = proto.create({name: 'damien'});

Object.getPrototypeOf(instance); // proto
instance.hasOwnProperty('name'); // false
instance.name; // 'damien'
```

## new(...)

Create an object linked by prototype to this, calls object.init() with supplied arguments and returns object.

```javascript
var User = proto.create({foo: 'bar', constructor: function(name){ this.name = name; }});
var user = User.new('damien');

user.hasOwnProperty('name'); // true
user.hasOwnProperty('foo'); // false
```

## propertyArgumentsAPI

Properties can be passed in arguments like follows:

```javascript
var a = proto.create();

// object
a.supplement({foo: 'bar'});
a.foo; // 'bar'

// string
a.supplement('foo', 'bar');
a.foo; // 'bar'

// function
var User = function(){}; User.prototype.foo = 'bar';
a.supplement(User);
a.foo; // 'bar'
```

## Calling a parent method

Wrong version:

```javascript
var User = proto.create({
	supplement: function(){
		Object.getPrototypeOf(this).supplement.call(this);
	}
});
var Admin = User.create();

Admin.supplement(); // calls endlessly User.supplement()
```

Right version:

```javascript
var User = proto.create({
	supplement: function(){
		proto.supplement.call(this);
	}
});
var Admin = User.create();

Admin.supplement(); // calls User.supplement() and proto.supplement()
```

In short you can't rely on Object.getPrototypeOf(this) to access the parent because `this` can be anything.

## Custom instantiation logic

You can define how instance are created by redefining the 'new' method:

```javascript
var Parser = proto.create({
	cache: {},
	
	hasCache: function(expression){
		return expression in this.cache;
	},
	
	new: function(expression){
		// returns an existing cached instance
		if( this.hasCache(expression) ){
			return this.cache[expression];
		}
		// return the newly cached instance
		else{
			return this.cache[expression] = proto.new.call(this, expression);
		}
	},
	
	expression: null,
	constructor: function(expression){
		this.expression = null;
	}
});

var parser_a = Parser.new('hello');
var parser_b = Parser.new('hello');
var parser_c = Parser.new('world');

parser_a == parser_b; // true
parser_a == parser_c; // false
Parser.cache['hello'] == parser_a; // true
Parser.cache['world'] == parser_c; // true
```

## Structure advices

I use the following structure when declaring my objects and I recommend to use it:

```javascript
var Parser = proto.create({
	// Properties used by the prototype (Parser)
	cache: {}
	
	// Methods used by the prototype (Parser)
	hasCache: function(){},
	new: function(){},
	
	// Properties used by the instance
	expression: null,

	// Methods used by the instance
	constructor: function(){}
});
```

I always declare all properties used by my object at least by setting them to null (like expression: null above).  
First, because it gives you a quick overview of your object. Second, it makes JavaScript faster* (missing ref).
