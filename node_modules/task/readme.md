# task

Build on top of promise get more control

## Examples

```javascript
Task.create(function(){ return 'foo'; }).spawn().then(console.log); // 'foo'
Task.create(function(value){ return Promise.resolve(value); }).spawn(value).then(console.log); // 'bar'

var task = Task.create(function(value){
  this.exec(function increment(){ return value + 1; });
  this.exec(function decrement(val){ return val - 1; });
  return value + 5;
});

var process = task.spawn(10);

process.then(function(value){
  value; // 15
  process.children[0].value; // 9
  process.children[1].value; // 14 (because decrement used val not value)
  process.duration; // 0
});
process.children.length; // 2
```

## parallel(tasks, reaction)

All task are runned in parallel and their result is collected

```javascript
// parallel resolution
Task.parallel([
  function increment(a){
    return a + 1;
  },
  function decrement(a){
    return a - 1;
  }
]).spawn(10).then(console.log); // [9, 11]
```

## serie(tasks, reaction)

The next task waits for the previous to complete, useful when your task are dependant.

```javascript
// parallel resolution
Task.serie([
  function increment(a){
    return a + 1;
  },
  function decrement(){
    return this.find('increment').value - 1;
  }
]).spawn(10).then(console.log); // [9, 10]
```

## reduce(tasks, reaction)

The next task waits for the previous to complete and use the previous task result.

```javascript
// parallel resolution
Task.serie([
  function increment(a){
    return a + 1;
  },
  function decrement(a){
    return a - 1;
  }
]).spawn(10).then(console.log); // 10
```

## create(run, reaction)

run is a function responsible to return a value and can register subtasks

## spawn(value)

create a process for this task
