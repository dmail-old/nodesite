var proto = require('proto');
require('promise');
require('promise/exec');
var Notifier = require('notifier');

var Task = proto.extend({
	isPaused: false,
	isCancelled: false,
	useDebug: true,
	notifierNames: ['started', 'cancelled', 'paused', 'resumed', 'progressed', 'completed', 'failed', 'ended'],
	args: [],

	constructor: function(run, name){
		if( arguments.length === 0 ){
			throw new Error('missing executor function');
		}
		if( typeof run != 'function' ){
			throw new TypeError('function expected for task');
		}

		this.state = 'created';
		this.run = run;
		this.bind = this;
		this.name = name || run.name;

		Notifier.assignNotifiers.apply(this, this.notifierNames);

		this.promise = new Promise(function(resolve, reject){
			this.ended.add(resolve);
			this.failed.add(reject);
		}.bind(this));
	},

	debug: function(){
		if( this.useDebug ){
			console.log.apply(console, arguments);
		}
	},

	toString: function(){
		return '[Object Task ' + this.name + ']';
	},

	exec: function(){
		this.args = arguments;
	},

	afterEnd: function(){
		this.ended.notify(this.value);
		if( this.previous ){
			this.previous.end(this.value);
		}
	},

	afterFail: function(){
		this.failed.notify(this.value);
		if( this.previous ){
			this.previous.fail(this.value);
		}
	},

	afterComplete: function(){
		this.completed.notify(this.value);

		if( this.next ){
			this.next.exec(this.value);
			this.next.start();
		}
		else{
			this.end(this.value);
		}
	},

	end: function(value){
		if( this.state === 'completed' && !this.isCancelled ){
			this.debug(this.name, 'ended');

			this.state = 'ended';
			this.value = value;

			if( this.isPaused === false ){
				this.afterEnd();
			}
		}
	},

	complete: function(value){
		if( this.state === 'started' && !this.isCancelled ){
			this.debug(this.name, 'completed with', value);

			this.state = 'completed';
			this.value = value;

			if( Task.isPrototypeOf(value) ){
				this.chain(value);
			}

			if( this.isPaused === false ){
				this.afterComplete();
			}
		}
	},

	fail: function(value){
		if( this.state === 'started' && !this.isCancelled ){
			this.debug(this.name, 'failed');

			this.state = 'failed';
			this.value = value;

			if( this.isPaused === false ){
				this.afterFail();
			}
		}
	},

	pause: function(){
		if( this.isPaused === false ){
			if( this.state != 'ended' ){ // pause has no effect after end()
				this.debug(this.name, 'paused');

				// a task can be in completed state only it has next task else it's goes to ended state immediatly
				if( this.state === 'completed' ){
					this.next.pause();
				}

				this.isPaused = true;
				this.paused.notify();
			}
		}
	},

	resume: function(){
		if( this.isPaused === true ){
			this.debug(this.name, 'resumed');

			this.isPaused = false;
			this.resumed.notify();

			if( this.state === 'completed' ){
				if( this.next.isPaused ){
					this.next.resume();
				}
				else{
					this.afterComplete();
				}
			}
			else if( this.state === 'failed' ){
				this.afterFail();
			}
			else if( this.state === 'ended' ){
				this.afterEnd();
			}
		}
	},

	cancel: function(){
		if( this.isCancelled === false ){
			this.debug(this.name, 'cancelled');

			this.isCancelled = true;
			this.cancelled.notify();
			if( this.next ){
				this.next.cancel();
			}
			if( this.previous ){
				this.previous.cancel();
			}
		}
	},

	start: function(){
		if( this.state === 'created' && this.isCancelled === false ){
			Promise.exec(this.run, this.bind, this.args).then(
				this.complete.bind(this),
				this.fail.bind(this)
			);

			this.state = 'started';
			this.started.notify();
			this.debug(this.name, 'started');
		}
	},

	getOrCreate: function(task){
		return Task.isPrototypeOf(task) ? task : new this.constructor(task);
	},

	chain: function(task){
		if( this.next ){
			return this.next.chain(task);
		}

		task = this.getOrCreate(task);
		this.next = task;
		this.next.previous = this;

		return this.next;
	},

	then: function(onEnd, onFailure){
		return this.promise.then(onEnd, onFailure);
	},

	catch: function(onFailure){
		return this.then(null, onFailure);
	}
});

Task = Task.constructor;
module.exports = Task;

Task.pipe = function(tasks, bind){
	var pipeTask = Task.create(function pipeTask(){
		var i = 0, j = tasks.length, task = this;

		for(;i<j;i++){
			task = task.chain(tasks[i]);
			if( bind ) task.bind = bind;
		}
	});

	pipeTask.start();

	return pipeTask;
};

require('promise/map');
Task.all = function(tasks){
	var task = Task.create(function allTask(){
		return Promise.map(tasks, function(task){
			task = Task.prototype.getOrCreate(task);

			this.tasks.push(task);
			task.start();
			return task;
		}, this);
	});

	task.tasks = [];
	task.cancel = function(){
		this.tasks.forEach(function(task){
			task.cancel();
		});
		Task.cancel.call(this);
	};
	task.pause = function(){
		this.tasks.forEach(function(task){
			task.pause();
		});
		Task.pause.call(this);
	};
	task.resume = function(){
		this.tasks.forEach(function(task){
			task.resume();
		});
		Task.resume.call(this);
	};

	task.start();

	return task;
};

Task.pipe([
	function first(){
		return Promise.resolve('foo');
	},
	function second(value){
		return value + 'bar';
	}
]).then(console.log);

/*
Task.all([
	function foo(){
		return Promise.resolve('foo');
	},
	function bar(){
		return Promise.resolve('bar');
	}
]).then(console.log);
*/

/*
var collector = {
	readdir: function(path){
		return new Task(function(){
			return 'bar';
		});
	},

	collect: function(path){
		return Task.reduce([
			function stat(path){
				return {
						isDirectory: function(){
							return path === 'foo';
						},

						isFile: function(){
							return path === 'bar';
						}
					};
				};
			},
			function scan(stat){
				if( stat.isDirectory() ){
					return Task.map(paths, this.collect);
				}
				else if( stat.isFile() ){
					return path;
				}
			}
		], this);


		return this.stat(path).chain(this.scan);
	}
};
*/

/*
var test = {
	willBe: function(thenable, expect){
		return Promise.resolve(thenable).then(function(value){
			if( value != expect ){
				throw new Error(value + ' not equal to ' + expect);
			}
		});
	}
};
var tests = {};

tests['basic task dependency'] = function(){
	var task = Task.spawn(function(){
		return Task.pipe([
			function(){
				return Promise.resolve('foo');
			},
			function(value){
				return value + 'bar';
			}
		]);
	});

	return test.willBe(task, 'foobar');
};
*/

/*
collect: function(path){
		return this.stat(path).then(function(stat){
			if( stat.isDirectory() ){
				if( this.filterFolder(path) ){
					return this.readdir(path).then(function(names){
						var paths = names.map(function(name){
							return path + this.PATH.sep + name;
						}, this);

						paths = paths.filter(this.filterFolder, this);

						// return Task.map(paths, this.collect);

						return Promise.map(paths, function(path){
							return this.collect(path);
						}, this);
					}.bind(this));
				}
			}
			else if( stat.isFile() ){
				if( this.hasModuleSignature(path) && this.filterFile(path) ){
					this.modulePaths.push(path);
				}
			}
		}.bind(this));
	},
*/

/*
var unitTests = [];
Object.keys(tests).forEach(function(key){
	unitTests.push({
		name: key,
		fn: tests[key]
	});
});

require('promise/mapReduce');
Promise.mapReduce(unitTests, function(unitTest){
	return unitTest.fn();
}).then(function(){
	console.log('task test passed');
}, function(error){
	console.log('task test failed', error, error.stack);
});

process.stdin.resume();
*/

/*
tests['recover from failed task'] = function(){
	test.willBe(Task.error(new Error('failed')).catch(function(error){
		return error;
	}).then(function(){
		return 'ok';
	}), 'ok');
};
*/

/*
tests['cancel before start has effect'] = function(){
	var foo = 'foo';
	var task = new Task(function(){
		foo = 'bar';
	});

	task.cancel();
	task.start();

	return test.willBe(Promise.resolve(foo), 'foo');
};

tests['cancel after start has no effect'] = function(){
	var foo = 'foo';
	var task = new Task(function(){
		foo = 'bar';
	});

	task.start();
	task.cancel();

	return test.willBe(Promise.resolve(foo), 'bar');
};
*/

/*
no implemented yet
tests['timeout test'] = function(){
	var task = new Task(function(){

	});

	task.sleep(1000);
};
*/

/*
not implemented yet (task.delay delay the completion of the task by X ms)
tests['delay'] = function(){
	var now = new Date();
	var task = Task.end(10);
	task.delay(100);
};

 it("can be canceled", function () {
		var now = Date.now();
		var canceled = false;
		var task = Task.defer(function () {
			canceled = true;
		}).out;
		var delayed = task.delay(100);
		delayed.throw();
		expect(canceled).toBe(true);
		return delayed.catch(function (error) {
			expect(Date.now()).toBeNear(now, 10); // as opposed to + 100
			expect(error && error.message).toBe("Consumer canceled task");
		});
	});
*/