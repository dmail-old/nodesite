var proto = require('proto');
require('promise');
require('array/prototype/find');

Promise.apply = function(fn, bind, args){
	return new Promise(function(resolve){
		resolve(fn.apply(bind, args));
	});
};

var TaskProcess = proto.extend({
	state: 'created', // 'created', 'started', 'blocked', 'waiting', 'resolved', 'rejected'
	current: null,
	mode: 'parallel',

	time: true,
	canReact: true,

	constructor: function(task){
		this.task = task;
		this.run = this.task.run;
		this.reaction = this.task.reaction;

		this.promise = new Promise(function(resolve, reject){
			this._resolve = resolve;
			this._reject = reject;
		}.bind(this));
	},

	toString: function(){
		return '[Object TaskProcess]';
	},

	then: function(onResolve, onReject){
		return this.promise.then(onResolve, onReject);
	},

	hasReaction: function(method){
		return this.canReact && this.reaction && method in this.reaction;
	},

	react: function(method, value){
		if( this.hasReaction(method) ){
			this.reaction[method].call(this, value);
		}
	},

	progress: function(childProcess){
		if( this.state == 'started' ){
			this.react('progress', childProcess);
		}
	},

	done: function(){
		if( this.startDate ){
			this.endDate = new Date();
			this.duration = this.endDate - this.startDate;
		}
		this.react('done', this.value);
	},

	resolve: function(){
		if( this.state == 'started' ){
			this.state = 'resolved';
			this.done();
			this.react('pass', this.value);
			this._resolve(this.value);
		}
	},

	reject: function(value){
		if( this.state == 'started' ){
			this.state = 'rejected';
			this.value = value;
			this.done();
			this.react('fail', value);
			this._reject(value);		
		}
	},

	createChildProcess: function(task){
		if( typeof task === 'function' ) task = Task.create(task);

 		var process = task.createProcess();

		//this.state = 'blocked'; // blocked by a subprocess
		process.reaction = this.reaction ? this.reaction[task.name] : null;

		this.children.push(process);

		process.promise.then(function(value){
			this.progress(process);
		}.bind(this));

		return process;		
	},

	find: function(name){
		return this.children.find(function(childProcess){
			return childProcess.task.name == name;
		});
	},

	exec: function(task){
		var childProcess = this.createChildProcess(task);
		return childProcess;
	},

	cancel: function(){
		this.state = 'cancelled';
		this.children.forEach(function(childProcess){
			childProcess.cancel();
		});
	},

	start: function(value){
		this.state = 'started';
		this.children = [];
		if( this.time ) this.startDate = new Date();
		this.react('start', value);
		this.startValue = value;

		Promise.apply(this.run, this, arguments).then(function(value){
			this.value = value;

			var promise;

			if( this.mode === 'serie' ){
				promise = Promise.mapSerie(this.children, function(child){
					return child.start(value).promise;
				}, this);
			}
			else if( this.mode === 'reduce' ){
				// prev devrait valoir kk chose ici
				promise = Promise.mapReduce(this.children, function(child, index, array, previousValue){
					return child.start(previousValue).promise;
				}, this, value);
			}
			else if( this.mode === 'parallel' ){
				promise = Promise.map(this.children, function(child){
					return child.start(value).promise;
				}, this);
			}
			else{
				throw new Error('unknown subprocess resolution mode');
			}

			promise.then(
				this.resolve.bind(this),
				this.reject.bind(this)
			);

		}.bind(this));		

		return this;
	}
});

var Task = proto.extend({
	reaction: null,
	name: null,

	constructor: function(run, reaction){
		this.run = run;
		this.name = run.name;
		this.reaction = reaction;
	},

	toString: function(){
		return '[Object Task ' + this.name + ']';
	},

	createProcess: function(){
		return TaskProcess.create(this);
	},

	spawn: function(value){
		var taskProcess = this.createProcess();

		taskProcess.start(value);

		return taskProcess;
	}
});

var forOf = require('forOf');

Task.parallel = function(tasks, reaction){
	return Task.create(function(){
		this.mode = 'parallel';		
		
		this.value = [];
		forOf(tasks, function(task, index){
			this.exec(task).then(function(value){
				this.value[index] = value;
			}.bind(this));
		}, this);

		return this.value;

	}, reaction);
};

Task.serie = function(tasks, reaction){
	return Task.create(function(){
		this.mode = 'serie';

		this.value = [];
		forOf(tasks, function(task, index){
			this.exec(task).then(function(value){
				this.value[index] = value;
			}.bind(this));
		}, this);

		return this.value;

	}, reaction);
};

// or task.pipe
Task.reduce = function(tasks, reaction){
	return Task.create(function(value){
		this.mode = 'reduce';
		
		forOf(tasks, function(task, index){
			this.exec(task).then(function(value){
				this.value = value;
			}.bind(this));
		}, this);

		return value;

	}, reaction);
};

module.exports = Task;