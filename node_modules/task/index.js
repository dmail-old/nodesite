/*
Missing the progress() method and logic which is why I created Task
*/

var proto = require('proto');
var Notifier = require('notifier');
var isThenable = require('object/is-thenable');
var callThenable = require('object/call-thenable');

var Task = proto.extend({
	state: 'pending', // 'pending', 'completed', 'failed'
	next: null, // the task became the next task
	previous: null,
	onCompletion: null,
	onFailure: null,

	isPaused: false,
	isCancelled: false,
	useDebug: !true,
	notifierNames: ['cancelled', 'paused', 'resumed', 'progressed', 'completed', 'failed'],

	constructor: function(name){
		this.state = 'pending';
		this.name = name;

		Notifier.assignNotifiers.apply(this, this.notifierNames);
	},

	debug: function(){
		if( this.useDebug ){
			console.log.apply(console, arguments);
		}
	},

	toString: function(){
		return '[Object Task ' + this.name + ']';
	},

	clean: function(){
		if( this.next ){
			this.next.adoptState(this);
		}

		/*
		for garbage collect
		this.onCompletion = null;
		this.onFailure = null;
		this.bind = null;
		*/
	},

	afterFailure: function(){
		this.failed.notify(this.value);
		this.clean();		
	},

	afterCompletion: function(){
		this.completed.notify(this.value);
		this.clean();
	},

	complete: function(value){
		if( this.state === 'pending' && !this.isCancelled ){
			if( Task.isPrototypeOf(value) ){
				this.then(value);
			}
			
			if( isThenable(value) ){
				callThenable(value, this.complete.bind(this), this.fail.bind(this));
			}
			else{
				this.debug(this.name, 'completed with', value);
				this.state = 'completed';
				this.value = value;

				if( this.isPaused === false ){
					this.afterCompletion();
				}
			}
		}

		return this;
	},

	fail: function(value){
		if( this.state === 'pending' && !this.isCancelled ){
			this.debug(this.name, 'failed');
			this.state = 'failed';
			this.value = value;

			if( this.isPaused === false ){
				this.afterFailure();
			}
		}

		return this;
	},

	pause: function(){
		if( this.isPaused === false ){
			this.debug(this.name, 'paused');
			this.isPaused = true;
			this.paused.notify();
		}
		if( this.next ){
			this.next.pause();
		}

		return this;
	},

	resume: function(){
		if( this.isPaused === true ){
			this.debug(this.name, 'resumed');
			this.isPaused = false;
			this.resumed.notify();

			if( this.next ){
				this.next.resume();
			}

			if( this.state === 'completed' ){
				this.afterCompletion();
			}
			else if( this.state === 'failed' ){
				this.afterFailure();
			}
		}

		return this;
	},

	cancel: function(){
		if( this.next ){
			return this.next.cancel();
		}

		if( this.state === 'pending' && this.isCancelled === false ){
			this.debug(this.name, 'cancelled');
			this.isCancelled = true;
			this.cancelled.notify();
			this.clean();
		}
		return this;
	},

	adoptState: function(task){
		var isCompleted, fn, value, ret, error;

		if( task.isCancelled ){
			this.cancel();
		}
		else if( task.isPaused ){
			this.pause();
		}
		else{
			value = task.value;
			isCompleted = task.state === 'completed';
			fn = isCompleted ? this.onCompletion : this.onFailure;

			if( fn != null ){
				try{
					ret = fn.call(this.bind, value);
				}
				catch(e){
					error = e;
				}

				if( error ){
					isCompleted = false;
					value = error;
				}
				else{
					isCompleted = true;
					value = ret;
				}
			}

			if( isCompleted ){
				this.complete(value);
			}
			else{
				if( fn === null ){
					console.warn('unhandled task failure', value);
				}
				this.fail(value);
			}
		}
	},

	then: function(onCompletion, onFailure, bind){
		if( this.next ){
			return this.next.then.apply(this.next, arguments);
		}

		var task = new this.constructor();

		task.onCompletion = onCompletion;
		task.onFailure = onFailure;
		task.bind = bind || this.bind || task;
		task.previous = this;
		this.next = task;

		if( this.state !== 'pending' ){
			setImmediate(function(){
				task.adoptState(this);
				//task.adoptState.bind(task, this) else delay fails
			}.bind(this));
		}

		return task;
	},

	catch: function(onFailure, bind){
		return this.then(null, onFailure, bind);
	},

	// Returns a task completed with this task after some ms
	delay: function(ms){
		var task = this.then();

		var timer = setTimeout(function(){
			task.adoptState = Task.prototype.adoptState;
			task.adoptState(this);
		}.bind(this), ms);

		task.adoptState = function(){};

		// just for perf (avoid to task.complete even if it has no effect)
		task.clean = function(){
			clearTimeout(timer);
			this.constructor.prototype.clean.call(this);
		};

		return task;
	},

	// The `timeout` method will automatically fails a task if it takes longer than a given delay in miliseconds.
	timeout: function(ms){
		var timer = setTimeout(function(){
			var error = new Error('task too slow (more than '+ ms +' ms');
			error.code = 'TASK_TIMEOUT';

			this.fail(error);
		}.bind(this));

		// for perf too
		this.clean = function(){
			clearTimeout(timer);
			this.constructor.prototype.clean.call(this);
		};

		return this;
	},

	done: function(onCompletion, onFailure, bind){
		if( this.next ){
			return this.next.done.apply(this.next, arguments);
		}

		if( this.state === 'pending' ){
			if( onCompletion ) this.completed.addOnce(onCompletion, bind);
			if( onFailure ) this.failed.addOnce(onFailure, bind);
		}
		else{
			setImmediate(function(){
				if( this.state === 'completed' && onCompletion ){
					onCompletion.call(bind, this.value);
				}
				else if( onFailure){
					onFailure.call(bind, this.value);
				}
			}.bind(this));
		}

		return this;
	}
});

Task = Task.constructor;

Task.complete = function(value){
	var task;

	if( this.isPrototypeOf(value) ){
		task = value;
	}
	else{
		task = new Task().complete(value);
	}

	return task;
};

Task.fail = function(value){
	return new Task().fail(value);
};

Task.delay = function(ms, value){
	return Task.complete(value).delay(ms);
};

var forOf = require('for-of');
var TaskList = proto.extend.call(Task, {
	constructor: function(iterable, mode, bind){
		TaskList.super.constructor.call(this);

		this.tasks = [];
		this.pendingCount = 0;
		this.mode = mode;
		this.bind = bind;

		if( iterable ){
			forOf(iterable, this.add, this);
		}
	},

	cancelTasks: function(){
		this.tasks.forEach(function(task){
			task.cancel();
		});
	},

	pauseTasks: function(){
		this.tasks.forEach(function(task){
			task.pause();
		});
	},

	resumeTasks: function(){
		this.tasks.forEach(function(task){
			task.resume();
		});
	},	

	cancel: function(){
		this.cancelTasks();
		return TaskList.super.cancel.call(this);
	},

	pause: function(){
		this.pauseTasks();
		return TaskList.super.pause.call(this);
	},

	resume: function(){
		this.resumeTasks();
		return TaskList.super.resume.call(this);
	},	

	onTaskCancellation: function(){
		if( this.mode === 'race' || this.mode === 'any' ){
			this.pendingCount--;
			if( this.pendingCount === 0 ){
				this.complete(); // no task completed or failed
			}
		}
		else if( this.mode === 'all' ){
			this.cancel();
		}
	},

	onTaskCompletion: function(value){
		if( this.mode === 'race' || this.mode === 'any' ){
			this.complete(value);
			this.cancelTasks();
		}
		else if( this.mode === 'all' ){
			this.pendingCount--;
			if( this.pendingCount === 0 ){
				this.complete(this.tasks.map(function(task){
					return task.value;
				}));
			}
		}
	},

	onTaskFailure: function(value){
		if( this.mode === 'race' || this.mode === 'all' ){
			this.fail(value);
			this.cancelTasks();
		}
		// only the last failed task can make the task fail
		else if( this.mode === 'any' ) {
			if( this.pendingCount === 0 ){
				this.fail(value);
			}
		}
	},

	add: function(value){
		var task = Task.complete(value); // cast value to a task

		this.pendingCount++;
		task.cancelled.addOnce(this.onTaskCancellation, this);
		task.done(
			this.onTaskCompletion,
			this.onTaskFailure,
			this
		);

		this.tasks.push(task);

		return task;
	}
});

// The `all` function accepts an array of tasks, or values that can be coerced
// into tasks, and produces a task that when completed will produce an array of
// the individual completion values.
Task.all = function(iterable, bind){
	return TaskList.create(iterable, 'all', bind);
};

// The `race` method accepts an array of tasks, or value coercable to tasks, and
// returns a task that will receive the value of the first task that
// either completes or fails.
// Afterward, all remaining tasks will be cancelled.
Task.race = function(iterable, bind){
	return TaskList.create(iterable, 'race', bind);
};

// The `any` method accepts an array of tasks, or value coercable to tasks, and
// returns a task that will receive the value from the first task that
// completes with a value.
// After one succeeds, all remaining tasks will be cancelled.
// If one of the tasks fails, it will be ignored.
// If all tasks fail, this task will fail with the last error.
Task.any = function(iterable, bind){
	return TaskList.create(iterable, 'any', bind);
};

Task.reduce = function(iterable, bind, initialValue){
	var task = Task.complete(initialValue);

	forOf(iterable, function(fn){
		task = task.then(fn, null, bind);
	});

	return task;
};

module.exports = Task;