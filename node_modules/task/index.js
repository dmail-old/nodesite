/*
ptet utilisé promise.race pour le timeout
parce quesinon la promesse n'est pas settled lorsque le timeout se produit
ce qui devrait être le cas
*/

var proto = require('proto');
require('promise');

var Task = proto.extend({
	state: null, // 'created', 'passed', 'failed', 'cancelled', 'expired'
	name: null,
	startValue: null,
	value: null,  // an intermediate value or endValue
	endValue: null,
	reaction: null,
	task: null, // the current task being runned

	canReact: !false,
	time: true,
	timeout: 0,
	timer: null,

	constructor: function(executor, value, reaction){
		this.state = 'created';
		this.name = executor.name;
		this.value = this.startValue = value;
		this.executor = executor;
		this.reaction = reaction;
	},

	hasReaction: function(method){
		return this.canReact && this.reaction && method in this.reaction;
	},

	react: function(method, value){
		if( this.hasReaction(method) ){
			this.reaction[method].call(this, value);
		}
	},

	done: function(value){
		if( this.time ) this.duration = new Date() - this.startDate;
		this.value = this.endValue = value;
		this.react('done', value);
	},

	pass: function(value){
		this.state = 'passed';
		this.done(value);
		this.react('pass', value);
	},

	fail: function(value){
		this.state = 'failed';
		this.done(value);
		this.react('fail', value);
	},

	progress: function(value){
		this.value = value;
		this.react('progress', value);
	},

	expire: function(){
		if( this.task ){
			this.task.expire();
		}

		this.state = 'expired';
		this.clearTimeout();

		var value = new Error('task is too slow');
		this.fail(value);
	},

	cancel: function(){
		if( this.task ){
			this.task.cancel();
		}
		this.state = 'cancelled';
		this.react('cancel');
	},

	resolve: function(value){
		if( this.state == 'created' ){
			if( value && Task.isPrototypeOf(value) ){
				var task = value;

				if( this.task ){
					this.progress(task.value);
				}

				this.task = task;
				task.value = this.value;
				task.reaction = this.reaction ? this.reaction[task.name] : null;
				task.start();

				return task.promise.then(this.resolver, this.rejecter);
			}
			this.pass(value);
		}
		return value;
	},

	reject: function(value){
		if( this.state == 'created' ){
			this.fail(value);
		}
		return Promise.reject(value);
	},

	start: function(){
		if( this.time ) this.startDate = new Date();
		if( this.timeout > 0 ) this.setTimeout(this.timeout);

		this.resolver = this.resolve.bind(this);
		this.rejecter = this.reject.bind(this);

		this.react('start', this.value);
		this.promise = Promise.resolve(this.executor.call(this, this.value)).then(this.resolver, this.rejecter);

		return this.promise;
	}
});

module.exports = Task;