var proto = require('proto');
require('promise');
require('array/prototype/find');
require('promise/map');
require('promise/mapSerie');
require('promise/mapReduce');

Promise.apply = function(fn, bind, args){
	return new Promise(function(resolve){
		resolve(fn.apply(bind, args));
	});
};

var TaskProcess = proto.extend({
	state: 'created', // 'created', 'started', 'blocked', 'waiting', 'resolved', 'rejected'
	current: null,
	mode: 'reduce',

	parent: null,
	previous: null,
	next: null,

	time: true,
	canReact: true,

	constructor: function(task, value){
		this.task = task;
		this.run = this.task.run;
		this.bind = this;
		this.reaction = this.task.reaction;
		this.children = [];
		this.startValue = this.value = value;

		this.promise = new Promise(function(resolve, reject){
			this._resolve = resolve;
			this._reject = reject;
		}.bind(this));
	},

	toString: function(){
		return '[Object TaskProcess]';
	},

	then: function(onResolve, onReject){
		return this.promise.then(onResolve, onReject);
	},

	hasReaction: function(method){
		return this.canReact && this.reaction && method in this.reaction;
	},

	react: function(method, value){
		if( this.hasReaction(method) ){
			this.reaction[method].call(this, value);
		}
	},

	progress: function(childProcess){
		if( this.state == 'started' ){
			this.react('progress', childProcess);
		}
	},

	done: function(){
		if( this.startDate ){
			this.endDate = new Date();
			this.duration = this.endDate - this.startDate;
		}
		this.react('done', this.value);
	},

	resolve: function(value){
		if( this.state == 'started' ){
			this.state = 'resolved';
			this.value = value;
			this.done();
			this.react('pass', this.value);
			this._resolve(this.value);

			if( this.parent ){
				this.parent.progress(this);
			}
		}
	},

	reject: function(value){
		if( this.state == 'started' ){
			this.state = 'rejected';
			this.value = value;
			this.done();
			this.react('fail', value);
			this._reject(value);
		}
	},

	createChildProcess: function(task, value){
		if( typeof task === 'function' ) task = Task.create(task);

 		var process = task.createProcess(value);

		//this.state = 'blocked'; // blocked by a subprocess
		process.reaction = this.reaction ? this.reaction[task.name] : null;
		process.parent = this;
		process.previous = this.children.length ? this.children[this.children.length - 1] : null;
		process.next = null;
		if( process.previous ) process.previous.next = process;

		this.children.push(process);

		return process;
	},

	find: function(name){
		return this.children.find(function(childProcess){
			return childProcess.task.name == name;
		});
	},

	exec: function(task, value){
		var childProcess = this.createChildProcess(task, value);
		return childProcess;
	},

	cancel: function(){
		this.state = 'cancelled';
		this.children.forEach(function(childProcess){
			childProcess.cancel();
		});
	},

	resolveChildren: function(){
		var promise;

		if( this.mode === 'serie' ){
			promise = Promise.mapSerie(this.children, function(child){
				return child.start().promise;
			}, this);
		}
		else if( this.mode === 'reduce' ){
			promise = Promise.mapReduce(this.children, function(child, index, array, previousValue){
				child.value = previousValue;
				return child.start().promise;
			}, this, this.value);
		}
		else if( this.mode === 'parallel' ){
			promise = Promise.map(this.children, function(child){
				return child.start().promise;
			}, this);
		}
		else{
			throw new Error('unknown subprocess resolution mode');
		}

		promise.then(
			this.resolve.bind(this),
			this.reject.bind(this)
		);
	},

	map: function(iterable){
		this.mode = 'parallel';

		iterable.forEach(function(value){
			this.exec(this.task, value);
		}, this);
	},

	start: function(){
		this.state = 'started';
		if( this.time ) this.startDate = new Date();
		this.react('start', this.value);

		var args = [this.value];

		var runTask = function(){
			Promise.apply(this.run, this.bind, args).then(handleResult);
		}.bind(this);

		var handleResult = function(value){
			this.value = value;

			if( Task.isPrototypeOf(value) ){
				this.run = value.run; // exec the process as if it was this process
				runTask();
			}
			else{
				this.resolveChildren(value);
			}
		}.bind(this);

		runTask();

		return this;
	}
});

var Task = proto.extend({
	reaction: null,
	name: null,

	constructor: function(run, reaction){
		this.run = run;
		this.name = run.name;
		this.reaction = reaction;
	},

	toString: function(){
		return '[Object Task ' + this.name + ']';
	},

	createProcess: function(value){
		return TaskProcess.create(this, value);
	},

	spawn: function(value){
		var taskProcess = this.createProcess(value);

		taskProcess.start();

		return taskProcess;
	}
});

var forOf = require('for-of');

Task.parallel = function(tasks, reaction){
	return Task.create(function(){
		this.mode = 'parallel';

		this.value = [];
		forOf(tasks, function(task, index){
			this.exec(task).then(function(value){
				this.value[index] = value;
			}.bind(this));
		}, this);

		return this.value;

	}, reaction);
};

Task.serie = function(tasks, reaction){
	return Task.create(function(){
		this.mode = 'serie';

		this.value = [];
		forOf(tasks, function(task, index){
			this.exec(task).then(function(value){
				this.value[index] = value;
			}.bind(this));
		}, this);

		return this.value;

	}, reaction);
};

// or task.pipe
Task.reduce = function(tasks, reaction){
	return Task.create(function(value){
		this.mode = 'reduce';

		forOf(tasks, function(task, index){
			this.exec(task).then(function(value){
				this.value = value;
			}.bind(this));
		}, this);

		return value;

	}, reaction);
};

var i = 1;
var collect = Task.create(function collectRun(value){
	if( i !== 0 ){
		i--;
		this.map(['a', 'b']);
	}

	return Promise.resolve(value);
});

var process = collect.spawn(10);

process.then(function(value){
	console.log(process);
});

module.exports = Task;