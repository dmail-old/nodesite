var Task = require('./task');
var proto = require('proto');
var forOf = require('for-of');
require('task/complete');

var TaskList = proto.extend.call(Task, {
	constructor: function(iterable, mode, bind){
		TaskList.super.constructor.call(this);

		this.tasks = [];
		this.pendingCount = 0;
		this.mode = mode;
		this.bind = bind;

		if( iterable ){
			forOf(iterable, this.add, this);
		}
	},

	cancelTasks: function(){
		this.tasks.forEach(function(task){
			task.cancel();
		});
	},

	pauseTasks: function(){
		this.tasks.forEach(function(task){
			task.pause();
		});
	},

	resumeTasks: function(){
		this.tasks.forEach(function(task){
			task.resume();
		});
	},

	cancel: function(){
		this.cancelTasks();
		return TaskList.super.cancel.call(this);
	},

	pause: function(){
		this.pauseTasks();
		return TaskList.super.pause.call(this);
	},

	resume: function(){
		this.resumeTasks();
		return TaskList.super.resume.call(this);
	},

	onTaskCancellation: function(task){
		if( this.mode === 'race' || this.mode === 'any' ){
			this.pendingCount--;
			if( this.pendingCount === 0 ){
				this.complete(); // no task completed or failed
			}
		}
		else if( this.mode === 'all' ){
			this.debug('all cancelled by individual cancellation');
			this.cancel();
		}
	},

	onTaskCompletion: function(task){
		if( this.mode === 'race' || this.mode === 'any' ){
			this.complete(task.value);
			this.cancelTasks();
		}
		else if( this.mode === 'all' ){
			this.pendingCount--;
			if( this.pendingCount === 0 ){
				var values = this.tasks.map(function(task){
					return task.value;
				});
				this.complete(values);
			}
		}
	},

	onTaskFailure: function(task){
		if( this.mode === 'race' || this.mode === 'all' ){
			this.debug('all has failed');
			this.fail(task.value);
			this.cancelTasks();
		}
		// only the last failed task can make the task fail
		else if( this.mode === 'any' ) {
			if( this.pendingCount === 0 ){
				this.fail(task.value);
			}
		}
	},

	add: function(value){
		var task = Task.complete(value); // cast value to a task

		this.pendingCount++;

		task.cancelled.addOnce(this.onTaskCancellation, this);
		task.completed.addOnce(this.onTaskCompletion, this);
		task.failed.addOnce(this.onTaskFailure, this);

		this.tasks.push(task);

		return task;
	}
});

module.exports = TaskList;