var proto = require('proto');
var Notifier = require('notifier');
var isThenable = require('object/is-thenable');
var callThenable = require('object/call-thenable');

var Task = proto.extend({
	state: 'pending', // 'pending', 'completed', 'failed'
	next: null, // the task became the next task
	previous: null,
	onCompletion: null,
	onFailure: null,

	isPaused: false,
	isCancelled: false,
	useDebug: !true,
	notifierNames: ['cancelled', 'paused', 'resumed', 'progressed', 'completed', 'failed'],

	constructor: function(name){
		this.state = 'pending';
		this.name = name;

		Notifier.assignNotifiers.apply(this, this.notifierNames);
	},

	debug: function(){
		if( this.useDebug ){
			console.log.apply(console, arguments);
		}
	},

	toString: function(){
		return '[Object Task ' + this.name + ']';
	},

	adoptState: function(task){
		var isCompleted, fn, value, ret, error;

		if( task.isCancelled ){
			this.cancel();
		}
		else if( task.isPaused ){
			this.pause();
		}
		else{
			value = task.value;
			isCompleted = task.state === 'completed';
			fn = isCompleted ? this.onCompletion : this.onFailure;

			if( fn != null ){
				try{
					ret = fn.call(this.bind, value);
				}
				catch(e){
					error = e;
				}

				if( error ){
					isCompleted = false;
					value = error;
				}
				else{
					isCompleted = true;
					value = ret;
				}
			}

			if( isCompleted ){
				this.complete(value);
			}
			else{
				if( fn === null ){
					console.warn('unhandled task failure', value);
				}
				this.fail(value);
			}
		}
	},

	clean: function(){
		if( this.next ){
			this.next.adoptState(this);
		}

		/*
		for garbage collect
		this.onCompletion = null;
		this.onFailure = null;
		this.bind = null;
		*/
	},

	afterFailure: function(){
		this.failed.notify(this.value);
		this.clean();
	},

	afterCompletion: function(){
		this.completed.notify(this.value);
		this.clean();
	},

	complete: function(value){
		if( this.state === 'pending' && !this.isCancelled ){
			var isTask = Task.isPrototypeOf(value);

			if( !isTask || isThenable(value) ){
				callThenable(value, this.complete.bind(this), this.fail.bind(this));
			}
			else{
				if( isTask ){
					this.then(value);
				}

				this.debug(this.name, 'completed with', value);
				this.state = 'completed';
				this.value = value;

				if( this.isPaused === false ){
					this.afterCompletion();
				}
			}
		}

		return this;
	},

	fail: function(value){
		if( this.state === 'pending' && !this.isCancelled ){
			this.debug(this.name, 'failed');
			this.state = 'failed';
			this.value = value;

			if( this.isPaused === false ){
				this.afterFailure();
			}
		}

		return this;
	},

	pause: function(){
		if( this.isPaused === false ){
			this.debug(this.name, 'paused');
			this.isPaused = true;
			this.paused.notify();
		}
		if( this.next ){
			this.next.pause();
		}

		return this;
	},

	resume: function(){
		if( this.isPaused === true ){
			this.debug(this.name, 'resumed');
			this.isPaused = false;
			this.resumed.notify();

			if( this.next ){
				this.next.resume();
			}

			if( this.state === 'completed' ){
				this.afterCompletion();
			}
			else if( this.state === 'failed' ){
				this.afterFailure();
			}
		}

		return this;
	},

	cancel: function(){
		if( this.next ){
			return this.next.cancel();
		}

		if( this.state === 'pending' && this.isCancelled === false ){
			this.debug(this.name, 'cancelled');
			this.isCancelled = true;
			this.cancelled.notify();
			this.clean();
		}
		return this;
	},

	chain: function(task){
		if( this.next ){
			return this.next.chain(task);
		}

		task.bind = task.bind || this.bind;
		task.previous = this;
		this.next = task;

		if( this.state !== 'pending' ){
			setImmediate(function(){
				task.adoptState(this);
				//task.adoptState.bind(task, this) else delay fails
			}.bind(this));
		}

		return task;
	},

	then: function(onCompletion, onFailure, bind){
		var task = new this.constructor();

		task.onCompletion = onCompletion;
		task.onFailure = onFailure;
		task.bind = bind;

		return this.chain(task);
	},

	catch: function(onFailure, bind){
		return this.then(null, onFailure, bind);
	},

	// Returns a task completed with this task after some ms
	delay: function(ms){
		var task = this.then();

		var timer = setTimeout(function(){
			task.adoptState = Task.prototype.adoptState;
			task.adoptState(this);
		}.bind(this), ms);

		task.adoptState = function(){

		};

		// clean timer
		task.clean = function(){
			clearTimeout(timer);
			return this.constructor.prototype.clean.call(this);
		};

		return task;
	},

	// The `timeout` method will automatically fails a task if it takes longer than a given delay in miliseconds.
	timeout: function(ms){
		var timer = setTimeout(function(){
			var error = new Error('task too slow (more than '+ ms +' ms');
			error.code = 'TASK_TIMEOUT';

			this.fail(error);
		}.bind(this));

		// clean timer (wrap function in case task is a delayed task, see above)
		var clean = this.clean;
		this.clean = function(){
			clearTimeout(timer);
			return clean.call(this);
		};

		return this;
	},

	done: function(onCompletion, onFailure, bind){
		if( this.next ){
			return this.next.done.apply(this.next, arguments);
		}

		if( this.state === 'pending' ){
			if( onCompletion ) this.completed.addOnce(onCompletion, bind);
			if( onFailure ) this.failed.addOnce(onFailure, bind);
		}
		else{
			setImmediate(function(){
				if( this.state === 'completed' && onCompletion ){
					onCompletion.call(bind, this.value);
				}
				else if( onFailure){
					onFailure.call(bind, this.value);
				}
			}.bind(this));
		}

		return this;
	}
});

Task = Task.constructor;

module.exports = Task;