var proto = require('proto');
var Notifier = require('notifier');
var isThenable = require('object/is-thenable');
var callThenable = require('object/call-thenable');

/*
// see memorize http://millermedeiros.github.io/js-signals/docs/symbols/Signal.html
en ajoutant la possibilité de curried parameters comme ici
https://github.com/millermedeiros/js-signals/blob/master/src/SignalBinding.js#L80
plus besoin de subclass

suffirais de faire

this.completed = Notifier.create('completed');
this.completed.memorize = true;
this.completed.args = [this];

sauf que pour pause / resume
faut que lorsqu'on pause on forget resume (sinon resumed pense qu'il est toujours mémorisé et va fire)
et que lorsqu'on resume on forget pause

var TaskNotifier = proto.extend.call(Notifier, {
	notified: false,

	toString: function(){
		return '[Object Notifier active:'+ this.active +' size:'+ this.size +']';
	},

	prevent: function(){
		this.stopped = true;
		return this;
	},

	constructor: function(task, name){
		this.task = task;
		TaskNotifier.super.constructor.call(this, name);
	},

	add: function(){
		var listener = TaskNotifier.super.add.apply(this, arguments);
		// immediatly call listener when already notified
		if( listener && this.notified ){
			this.applyListener(listener, [this.task]);
		}
		return listener;
	},

	notify: function(){
		this.notified = true;
		return TaskNotifier.super.notify.call(this, this.task);
	}
});
*/

var Task = proto.extend({
	state: 'pending', // 'pending', 'completed', 'failed'
	next: null, // the task became the next task
	previous: null,
	current: null,
	onCompletion: null,
	onFailure: null,

	isPaused: false,
	isCancelled: false,
	useDebug: !true,
	notifierNames: ['cancelled', 'paused', 'resumed', 'progressed', 'completed', 'failed'],

	constructor: function(name){
		this.state = 'pending';
		this.name = name;

		Notifier.assignNotifiers.apply(this, this.notifierNames);
	},

	debug: function(){
		if( this.useDebug ){
			console.log.apply(console, arguments);
		}
	},

	toString: function(){
		return '[Object Task ' + this.name + ']';
	},

	adoptState: function(task){
		var isCompleted, fn, value, ret, error;

		if( task.isCancelled ){
			this.cancel();
		}
		else if( task.isPaused ){
			this.pause();
		}
		else{
			value = task.value;
			isCompleted = task.state === 'completed';
			fn = isCompleted ? this.onCompletion : this.onFailure;

			if( fn ){
				try{
					ret = fn.call(this.bind, value);
				}
				catch(e){
					error = e;
				}

				if( error ){
					isCompleted = false;
					value = error;
				}
				else{
					isCompleted = true;
					value = ret;
				}
			}

			if( isCompleted ){
				this.complete(value);
			}
			else{
				//unhandled à réfléchir
				//if( fn === null ){
				//	console.warn('unhandled task failure', value, Boolean(this.next));
				//}
				this.fail(value);
			}
		}
	},

	clean: function(){
		if( this.next ){
			this.next.adoptState(this);
		}

		/*
		for garbage collect
		this.onCompletion = null;
		this.onFailure = null;
		this.bind = null;
		this.current = null;
		*/
	},

	afterFailure: function(){
		this.failed.notify(this.value);
		this.clean();
	},

	afterCompletion: function(){
		this.completed.notify(this.value);
		this.clean();
	},

	resolveCompletion: function(value){
		var isTask = Task.isPrototypeOf(value);

		if( isTask ){
			if( value === this ){
				this.fail(new TypeError('A task cannot be completed with itself'));
			}
			else{
				if( this.current ){
					value.previous = this.current;
					this.current.next = value;
				}

				this.current = value;
				this.current.bind = this.current.bind || this.bind;

				if( this.isPaused ){
					this.current.pause();
				}
				else if( this.isCancelled ){
					this.current.cancel();
				}
				else{
					this.current.then(this.resolveCompletion, this.fail, this);
				}
			}
		}
		else if( isThenable(value) ){
			callThenable(value, this.resolveCompletion.bind(this), this.fail.bind(this));
		}
		else{
			this.debug(this.name, 'completed with', value);
			this.isBlocked = false;
			this.state = 'completed';
			this.value = value;

			if( this.isPaused === false ){
				this.afterCompletion();
			}
		}
	},

	complete: function(value){
		if( this.state === 'pending' && !this.isCancelled && !this.isBlocked ){
			this.isBlocked = true;
			this.resolveCompletion(value);
		}

		return this;
	},

	fail: function(value){
		if( this.state === 'pending' && !this.isCancelled ){
			this.debug(this.name, 'failed');
			this.state = 'failed';
			this.value = value;

			if( this.isPaused === false ){
				this.afterFailure();
			}
		}

		return this;
	},

	pause: function(){
		if( this.state === 'pending' && this.isPaused === false ){
			if( this.current ){
				this.current.pause();
			}

			this.debug(this.name, 'paused');
			this.isPaused = true;
			this.paused.notify();
		}

		return this;
	},

	resume: function(){
		if( this.isPaused === true ){
			this.debug(this.name, 'resumed');
			this.isPaused = false;
			this.resumed.notify();

			if( this.state === 'completed' ){
				this.afterCompletion();
			}
			else if( this.state === 'failed' ){
				this.afterFailure();
			}
			else if( this.current ){
				this.current.resume();
			}
		}

		return this;
	},

	cancel: function(){
		if( this.state === 'pending' && this.isCancelled === false ){
			if( this.current ){
				this.current.cancel();
			}

			this.debug(this.name, 'cancelled');
			this.isCancelled = true;
			this.cancelled.notify();
			this.clean();
		}
		return this;
	},

	chain: function(task){
		task.bind = task.bind || this.bind;
		task.previous = this;
		this.next = task;

		if( this.state !== 'pending' ){
			setImmediate(function(){
				task.adoptState(this);
				//task.adoptState.bind(task, this) else delay fails
			}.bind(this));
		}

		return task;
	},

	then: function(onCompletion, onFailure, bind){
		if( onCompletion && typeof onCompletion != 'function' ){
			throw new TypeError('onCompletion must be a function ' + onCompletion + ' given');
		}
		if( onFailure && typeof onFailure != 'function' ){
			throw new TypeError('onFailure must be a function ' + onFailure + ' given');
		}

		var task = new this.constructor();

		task.name = 'task by then() call';
		task.onCompletion = onCompletion;
		task.onFailure = onFailure;
		task.bind = bind;

		return this.chain(task);
	},

	catch: function(onFailure, bind){
		return this.then(null, onFailure, bind);
	},

	// Returns a task completed with this task after some ms
	delay: function(ms){
		var task = this.then();

		var timer = setTimeout(function(){
			task.adoptState = Task.prototype.adoptState;
			task.adoptState(this);
		}.bind(this), ms);

		task.adoptState = function(){

		};

		// clean timer
		task.clean = function(){
			clearTimeout(timer);
			return this.constructor.prototype.clean.call(this);
		};

		return task;
	},

	// The `timeout` method will automatically fails a task if it takes longer than a given delay in miliseconds.
	timeout: function(ms){
		var timer = setTimeout(function(){
			var error = new Error('task too slow (more than '+ ms +' ms');
			error.code = 'TASK_TIMEOUT';

			this.fail(error);
		}.bind(this));

		// clean timer (wrap function in case task is a delayed task, see above)
		var clean = this.clean;
		this.clean = function(){
			clearTimeout(timer);
			return clean.call(this);
		};

		return this;
	},

	// now useless
	done: function(onCompletion, onFailure, bind){
		if( this.state === 'pending' ){
			if( onCompletion ) this.completed.addOnce(onCompletion, bind);
			if( onFailure ) this.failed.addOnce(onFailure, bind);
		}
		else{
			setImmediate(function(){
				if( this.state === 'completed' && onCompletion ){
					onCompletion.call(bind, this.value);
				}
				else if( onFailure){
					onFailure.call(bind, this.value);
				}
			}.bind(this));
		}

		return this;
	}
});

Task = Task.constructor;

module.exports = Task;