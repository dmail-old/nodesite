/*
we could add Task.prototype.map, Task.prototype.reduce
Task.prototype.spread which are equivalent to then
but avoid then explicit then call
*/

var proto = require('proto');
var Notifier = require('notifier');
var isThenable = require('object/is-thenable');
var callThenable = require('object/call-thenable');

var Task = proto.extend({
	useDebug: !false,
	weak: !true, // when task is over all pointers are removed for memory usage
	notifierNames: ['cancelled', 'paused', 'resumed', 'progressed', 'completed', 'failed'],
	state: 'pending', // 'pending', 'completed', 'failed'
	isPaused: false,
	isCancelled: false,

	onCompletion: null,
	onFailure: null,
	bind: null, // context of onCompletion & onFailure
	current: null, // when onCompletion returns a task, it becomes the current task
	next: null, // then create a dependant task waiting for this one

	constructor: function(name){
		this.state = 'pending';
		this.name = name;

		this.notifierNames.forEach(function(name){
			this[name] = Notifier.create(name);
			this[name].memorize = true;
			this[name].args = [this];
		}, this);
	},

	debug: function(){
		if( this.useDebug ){
			console.log.apply(console, Array.prototype.map.call(arguments, String));
		}
	},

	toString: function(){
		return '[Task ' + this.name + ', state: '+ this.state +']';
	},

	clean: function(){
		if( this.next ){
			this.next.adoptState(this);
		}

		// release pointers for garbage collect
		if( this.weak ){
			this.onCompletion = null;
			this.onFailure = null;
			this.bind = null;
			this.current = null;
			this.next = null;
			this.notifiersNames.forEach(function(name){
				this[name].clean();
				this[name] = null;
			}, this);
		}
	},

	afterFailure: function(){
		this.failed.notify();
		this.clean();
	},

	afterCompletion: function(){
		this.completed.notify();
		this.clean();
	},

	adoptState: function(task){
		var value = task.value;
		var isCompleted = task.state === 'completed';
		var fn = isCompleted ? this.onCompletion : this.onFailure;
		var ret;
		var error;

		if( fn ){
			try{
				ret = fn.call(this.bind, value);
			}
			catch(e){
				error = e;
			}

			if( error ){
				isCompleted = false;
				value = error;
			}
			else{
				isCompleted = true;
				value = ret;
			}
		}

		if( isCompleted ){
			this.debug(this, 'completed with', value);

			this.isBlocked = false;
			this.complete(value);
		}
		else{
			//unhandled à réfléchir
			//if( fn === null ){
			//	console.warn('unhandled task failure', value, Boolean(this.next));
			//}
			this.fail(value);
		}
	},

	adopt: function(task, immediatly){
		if( task.state === 'pending' ){
			if( task.isCancelled ){
				this.debug(this, 'cancelled by', task);
				this.cancel();
			}
			else{
				this.debug(this, 'listening for', task);

				// on se moque si la task est paused/resumed
				// par contre complete/fail/cancel ça nous intérèsse

				task.cancelled.addOnce(this.cancel, this);
				task.completed.addOnce(function(task){
					this.debug(this, 'did complete');
					return;

					this.isBlocked = false;
					this.complete(task.value);
				}, this);
				task.failed.addOnce(function(task){
					this.fail(task.value);
				}, this);
			}
		}
		else{
			if( immediatly ){
				this.debug(this, 'become', task);

				this.adoptState(task);
			}
			// set the task state asap, not immediatly
			else{
				this.debug(this, 'will become', task, 'asap');

				setImmediate(function(){
					this.adopt(task, true);
					//task.adoptState.bind(task, this) else delay fails
				}.bind(this));
			}
		}
	},

	resolveCompletion: function(value){
		var isTask = Task.isPrototypeOf(value);

		if( isTask ){
			if( value === this ){
				this.fail(new TypeError('A task cannot be completed with itself'));
			}
			else{
				this.current = value;
				this.adopt(value);
			}
		}
		else if( isThenable(value) ){
			callThenable(value, this.resolveCompletion.bind(this), this.fail.bind(this));
		}
		else{
			this.debug(this.name, 'completed with', value);
			this.isBlocked = false;
			this.state = 'completed';
			this.value = value;

			if( this.isPaused === false ){
				this.afterCompletion();
			}
		}
	},

	complete: function(value){
		if( this.state === 'pending' && !this.isCancelled && !this.isBlocked ){
			this.isBlocked = true;
			this.resolveCompletion(value);
		}

		return this;
	},

	fail: function(value){
		if( this.state === 'pending' && !this.isCancelled ){
			this.debug(this.name, 'failed');
			this.state = 'failed';
			this.value = value;

			if( this.isPaused === false ){
				this.afterFailure();
			}
		}

		return this;
	},

	pause: function(){
		if( this.state === 'pending' && this.isPaused === false ){
			if( this.current ){
				this.current.pause();
			}

			this.debug(this.name, 'paused');
			this.isPaused = true;
			this.resumed.forget();
			this.paused.notify();
		}

		return this;
	},

	resume: function(){
		if( this.isPaused === true ){
			this.debug(this.name, 'resumed');
			this.isPaused = false;
			this.paused.forget();
			this.resumed.notify();

			if( this.state === 'completed' ){
				this.afterCompletion();
			}
			else if( this.state === 'failed' ){
				this.afterFailure();
			}
			else if( this.current ){
				this.current.resume();
			}
		}

		return this;
	},

	cancel: function(){
		// cancel is noop on a settled task
		if( this.state === 'pending' && this.isCancelled === false ){
			if( this.current ){
				this.current.cancel();
			}

			this.debug(this.name, 'cancelled');
			this.isCancelled = true;
			this.cancelled.notify();
			this.clean();
		}

		return this;
	},

	then: function(onCompletion, onFailure, bind){
		if( onCompletion && typeof onCompletion != 'function' ){
			throw new TypeError('onCompletion must be a function ' + onCompletion + ' given');
		}
		if( onFailure && typeof onFailure != 'function' ){
			throw new TypeError('onFailure must be a function ' + onFailure + ' given');
		}

		var task = new this.constructor();

		task.name = (onCompletion ? onCompletion.name : '') || 'task by then() call';
		task.onCompletion = onCompletion;
		task.onFailure = onFailure;
		task.bind = bind;
		task.adopt(this);

		this.next = task;

		return task;
	},

	catch: function(onFailure, bind){
		return this.then(null, onFailure, bind);
	}
});

Task = Task.constructor;

module.exports = Task;