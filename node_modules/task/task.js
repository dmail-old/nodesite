/*

paus ene marche pas correctement

*/

var proto = require('proto');
var isThenable = require('object/is-thenable');
var callThenable = require('object/call-thenable');

var Task = proto.extend({
	useDebug: !false,
	weak: !true, // when task is over all pointers are removed for memory usage
	state: 'pending', // 'pending', 'completed', 'failed'
	isPaused: false,
	isCancelled: false,

	next: null,
	previous: null, // a previous task, cancelling/pausing/resuming this task will affect the previous
	pendingList: null,

	completionTransformer: null,
	failureTransformer: null,
	cancellationListener: null,
	pausingListener: null,
	resumingListener: null,
	bind: null, // context of the four previous methods

	constructor: function(name){
		this.state = 'pending';
		this.name = name;
	},

	toString: function(){
		return '[Task ' + this.name + ', state: '+ this.state +']';
	},

	listen: function(name, fn){

	},

	notify: function(){
		// listener.call(this.bind, this);
	},

	debug: function(){
		if( this.useDebug ){
			console.log.apply(console, Array.prototype.map.call(arguments, String));
		}
	},

	// called on completion/failure/cancellation
	clean: function(){
		// not needed anymore
		this.previous = null;
		this.next = null;

		if( this.pendingList ){
			this.pendingList.forEach(function(pending){
				pending.adopt(this);
			}, this);
			this.pendingList = null;
		}

		// release pointers for garbage collect
		if( this.weak ){
			this.completionTransformer = null;
			this.failureTransformer = null;
			this.bind = null;
		}
	},

	afterFailure: function(){
		//this.failed.notify();
		this.clean();
	},

	afterCompletion: function(){
		//this.completed.notify();
		this.clean();
	},

	adoptState: function(task){
		var value = task.value;
		var isCompleted = task.state === 'completed';
		var transformer = isCompleted ? this.completionTransformer : this.failureTransformer;
		var ret;
		var error;

		if( transformer ){
			try{
				this.debug(this, 'called with', value);
				ret = transformer.call(this.bind, value);
			}
			catch(e){
				error = e;
			}

			if( error ){
				isCompleted = false;
				value = error;
			}
			else{
				isCompleted = true;
				value = ret;
			}
		}

		if( isCompleted ){
			this.debug(this, 'completed with', value);
			this.isBlocked = false;
			this.complete(value);
		}
		else{
			//unhandled à réfléchir
			//if( fn === null ){
			//	console.warn('unhandled task failure', value, Boolean(this.next));
			//}
			this.fail(value);
		}
	},

	adopt: function(task, immediatly){
		// si task est paused/resumed on fait rien en fait

		if( task.state === 'pending' ){
			if( task.isCancelled ){
				this.debug(this, 'cancelled by', task);
				this.cancel();
			}
			else{
				this.debug(this, 'depends on', task);
				task.pendingList = task.pendingList || [];
				task.pendingList.push(this);
			}
		}
		else{
			if( immediatly ){
				this.adoptState(task);
			}
			// set the task state asap, not immediatly
			else{
				setImmediate(function(){
					this.adopt(task, true);
					//task.adoptState.bind(task, this) else delay fails
				}.bind(this));
			}
		}
	},

	resolveCompletion: function(value){
		var isTask = Task.isPrototypeOf(value);

		if( isTask ){
			if( value === this ){
				this.fail(new TypeError('A task cannot be completed with itself'));
			}
			else{
				this.insert(value);
			}
		}
		else if( isThenable(value) ){
			callThenable(value, this.resolveCompletion.bind(this), this.fail.bind(this));
		}
		else{
			this.isBlocked = false;
			this.state = 'completed';
			this.value = value;

			if( this.isPaused === false ){
				this.afterCompletion();
			}
			else{
				this.debug('completion of', this, 'prevented by pause');
			}
		}
	},

	complete: function(value){
		if( this.state === 'pending' && !this.isCancelled && !this.isBlocked ){
			this.isBlocked = true;
			this.resolveCompletion(value);
		}

		return this;
	},

	fail: function(value){
		if( this.state === 'pending' && !this.isCancelled ){
			this.debug(this.name, 'failed');
			this.state = 'failed';
			this.value = value;

			if( this.isPaused === false ){
				this.afterFailure();
			}
		}

		return this;
	},

	pause: function(){
		if( this.state === 'pending' && this.isPaused === false ){
			this.debug(this.name, 'paused');
			this.isPaused = true;

			if( this.previous ){
				this.previous.pause();
			}
			if( this.next ){
				this.next.pause();
			}			
			this.notify('pause');
		}

		return this;
	},

	resume: function(){
		if( this.isPaused === true ){
			this.debug(this.name, 'resumed');
			this.isPaused = false;
			this.notify('resume');

			if( this.state === 'completed' ){
				this.afterCompletion();
			}
			else if( this.state === 'failed' ){
				this.afterFailure();
			}

			if( this.previous ){
				this.previous.resume();
			}
			if( this.next ){
				this.next.resume();
			}
		}

		return this;
	},

	cancel: function(){
		if( this.state === 'pending' && this.isCancelled === false ){
			this.debug(this.name, 'cancelled');
			this.isCancelled = true;

			if( this.previous ){
				this.previous.cancel();
			}
			else if( this.next ){
				this.next.cancel();
			}

			this.notify('cancel');
			this.clean();
		}

		return this;
	},

	chain: function(task){
		if( this.next ){
			throw new Error(this, 'already got the next task', this.next);
		}

		task.previous = this;
		this.next = task;
		task.adopt(this);

		return task;
	},

	insert: function(task){
		task.previous = this;
		if( this.next ){
			this.next.previous = task;
		}
		this.next = task;

		return task;
	},

	createTask: function(completionTransformer, failureTransformer, bind){
		if( completionTransformer && typeof completionTransformer != 'function' ){
			throw new TypeError('completionTransformer must be a function ' + completionTransformer + ' given');
		}
		if( failureTransformer && typeof failureTransformer != 'function' ){
			throw new TypeError('failureTransformer must be a function ' + failureTransformer + ' given');
		}

		var task = new this.constructor();

		task.name = completionTransformer ? completionTransformer.name : '';
		task.completionTransformer = completionTransformer;
		task.failureTransformer = failureTransformer;
		task.bind = bind;

		return task;
	},

	join: function(completionTransformer, failureTransformer, bind){
		var task = this.createTask(completionTransformer, failureTransformer, bind);
		this.chain(task);
		return task;
	},

	then: function(completionTransformer, failureTransformer, bind){
		var task = this.createTask(completionTransformer, failureTransformer, bind);
		task.adopt(this);
		return task;
	},

	catch: function(failureTransformer, bind){
		return this.then(null, failureTransformer, bind);
	}
});

Task = Task.constructor;

module.exports = Task;