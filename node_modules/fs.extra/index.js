/* global util *//*call callback on every file of source directorycallback(error, path, stat, next)*/var FS = require('fs');var extra = module.exports;extra.iterate = function(source, callback){	source = source.replace(/\/$/, '');	FS.readdir(source, function(error, names){		if( error ) return callback(error);		var name;		function onstat(error, stat){			if( error ) return callback(error);			callback(null, name, stat, next);		}		function next(){			if( names.length === 0 ){				callback(null);			}			else{				name = names.shift();				FS.lstat(source + '/' + name, onstat);			}		}		next();	});};extra.rmdirRecursive = function(source, callback){	var path;	function remove(error, name, stat, next){		if( error ) return callback(error);		if( !name ) return FS.rmdir(source, callback);		path = source + '/' + name;		if( stat.isDirectory() ){			extra.rmdirRecursive(path, next);		}		else{			FS.unlink(path, next);		}	}	extra.iterate(source, remove);};function loaddirectory(source, recursive, callback){	var childNodes = [], child;	function load(error, name, stat, next){		if( error ) return callback(error);		if( !name ) return callback(null, childNodes);		child = {			name: name,			stat: stat		};		childNodes.push(child);		if( recursive && stat.isDirectory() ){			extra.loaddirRecursive(source + '/' + name, function(error, files){				if( error ) return callback(error);				child.childNodes = files;				next();			});		}		else{			next();		}	}	extra.iterate(source, load);}extra.loaddir = function(source, callback){ return loaddirectory(source, false, callback); };extra.loaddirRecursive = function(source, callback){ return loaddirectory(source, true, callback); };extra.copy = function(source, destination, callback){	FS.stat(destination, function(error){		if( !error ) return callback(new Error('File ' + destination + ' exists.'));		FS.stat(source, function(error, stat){			if( error ) return callback(error);			if( stat.isSymbolicLink() ) FS.readlink(source, function(error, link){ FS.symlink(link, destination, callback); });			else util.pump(FS.createReadStream(source), FS.createWriteStream(destination), callback);		});	});};extra.copydirRecursive = function(source, destination, callback){	FS.stat(source, function(error, sourceStat){		if( error ) return callback(error);		FS.mkdir(destination, sourceStat.mode, function(error){			if( error ) return callback(error);			extra.iterate(source, function(error, name, stat, next){				if( error ) return callback(error);				if( !name ) return callback();				var path = source + '/' + name;				var copy = destination + '/' + name;				if( stat.isDirectory() ) return extra.copydirRecursive(path, copy, next);				extra.copy(path, copy, next);			});		});	});};var PATH = require('path');extra.collectSync = function(path, filter, bind, depth){	if( typeof depth !== 'number' ) depth = 0;	//path = PATH.resolve(path);	var paths = [];	var stat = FS.statSync(path);	var result = filter ? filter.call(bind, path, stat, depth) : true;	if( result !== false ){		if( result === true ) paths.push(path);		if( stat.isDirectory() ){			FS.readdirSync(path).forEach(function(file){				paths = paths.concat(extra.collectSync(path + PATH.sep + file, filter, bind, depth++));			});		}	}	return paths;};extra.collectFileSync = function(path){	return extra.collectSync(path, function(path, stat){		return stat.isDirectory() ? 'ignore' : true;	});};extra.readdirSyncRecursive = function(dir, filter, bind, depth){	var paths = extra.collectSync(dir, filter, bind, depth);	paths.shift();	return paths;};module.exports = extra;