/*

Créer un logger pour admin.js
un pour server.js pour les requêtes
donne comme option d'aussi logger les messages dans un fichier

*/

// https://github.com/visionmedia/callsite/blob/master/lib/__stack.js
Object.defineProperty(global, '__stack', {
	get: function(){
		var orig = Error.prepareStackTrace;
		Error.prepareStackTrace = function(_, stack){ return stack; };
		var err = new Error();
		Error.captureStackTrace(err, arguments.callee);
		var stack = err.stack;
		Error.prepareStackTrace = orig;
		return stack;
	}
});

var Logger = {
	ansi: require('ansi'),
	fileSystem: require('fs'),
	inspect: require('util').inspect,
	regexp: /{(.*?)}/,
	streams: null,
	styles: {},
	level: 'info',
	levels: ['info', 'debug', 'warn', 'error', 'fatal'],

	// options
	
	filePath: null,
	console: true,
	
	colorize: true,
	depth: 2,
	showHidden: false,

	init: function(options){
		this.streams = [];

		if( typeof options == 'string' ){
			options = {filePath: options};
		}

		for(var key in options){
			this[key] = options[key];
		}

		if( typeof this.filePath == 'string' ){
			this.addStream(this.createStream(this.filePath));
		}
		if( this.console === true ){
			this.addStream(this.createStream(process.stdout));
		}
	},

	createStream: function(stream){

		if( typeof stream == 'string' ){
			return this.fileSystem.createWriteStream(stream, {flags: 'a', encoding: 'utf8', mode: 0666});
		}
		if( typeof stream == 'undefined' ){
			return process.stdout;
		}
		if( stream.write || stream.read ){ // instanceof Stream.Writable || stream instanceof Stream.Readable ){
			return stream;
		}
		
		throw new TypeError('stream expected');
	},

	addStream: function(stream){
		this.streams.push(stream);
	},

	stylize: function(str, styleName){
		if( styleName in this.styles ){
			str = this.ansi.stylizeAll(str, this.styles[styleName]);
		}
		return str;
	},

	_render: function(string, data, stylize){
		var self = this, i = 0;

		return string.replace(this.regexp, function(match, key){
			var value;

			if( data instanceof Array && i in data ){
				value = data[i];
				if( stylize ) value = self.stylize(value, key);
			}
			else if( key in data ){
				value = data[key];
				if( stylize ) value = self.stylize(value, key);
			}
			else{
				value = match;
			}

			i++;

			return value;
		});
	},

	render: function(level, message, data, stylize){
		if( typeof message != 'string' ){
			if( stylize ){
				stylize = !this.colorize;
				this.colorize = true;
			}

			message = this.stringify(message);

			if( stylize ) this.colorize = false;
		}

		message = this.createLevelMessage(level, message, stylize);

		if( data !== null ) message = this._render(message, data, stylize);	

		return message;
	},

	createDebugMessage: function(message, stylize){
		var call, wrap, lineFile, lineNumber, fileContent, lineContent, levelPrefix;

		call = global.__stack[1];
		lineFile = call.getFileName();
		lineNumber = call.getFileNumber();
		fileContent = this.fileSystem.readFileSync(lineFile, 'utf8');
		lineContent = fileContent.split('\n')[lineNumber];
		lineContent = lineContent.replace(/\n|\r/, '');
		message = message.replace(/\n|\r/g, function(match){ return match + '{debug}: '; });

		wrap = '\
			{debug}: \n\
			{debug}: {lineContent} ({lineFile: {lineNumber}})\n\
			{debug}: {message}\n\
			{debug}: \
		';

		return this._render(wrap, {
			debug: 'debug',
			message: message,
			lineContent: lineContent,
			lineFile: lineFile,
			lineNumber: lineNumber
		}, stylize);
	},

	createLevelMessage: function(level, message, stylize){
		if( level === 'debug' ){
			return this.createDebugMessage(message, stylize);
		}
		if( stylize ){
			return this.stylize(level, level) + ': ' + message;
		}
		return level + ': ' + message;
	},

	write: function(level, message, data){
		var i = 0, j = this.streams.length, stream, stylized, raw;

		for(;i<j;i++){
			stream = this.streams[i];
			
			// use ansi for console streams
			if( stream.isTTY ){
				stylized = stylized || this.render(message, data, true);
				stream.write(stylized);
			}
			// and raw data for other streams
			else{
				raw = raw || this.render(message, data, false);
				stream.write(raw);
			}
		}

		return true;
	},

	stringify: function(item){
		return this.inspect(item, {
			showHidden: this.showHidden,
			depth: this.depth,
			colors: this.colorize,
			customInspect: true
		});
	},

	getLevelIndex: function(level){
		return this.levels.indexOf(level);
	},

	canLog: function(level){
		return this.getLevelIndex(level) >= this.getLevelIndex(this.level);
	},

	log: function(level, message, data){
		if( this.canLog(level) ){
			if( arguments.length > 3 || typeof data != 'object' ){
				data = Array.prototype.slice.call(arguments, 2);
			}

			this.write(level, message, data);
			return true;
		}
		return false;
	}
};

Logger.styles = {
	'info': {color: 'green'},
	'help': {color: 'cyan'},
	'warn': {color: 'yellow', font: 'bold'},
	'debug': {color: 'grey', font: 'bold'},
	'error': {color: 'red', font: 'bold'}
};

Logger.levels.forEach(function(level){
	Logger[level] = function(){
		return this.log.apply(this, [level].concat(Array.apply(Array, arguments)));
	};
});

module.exports = Logger;