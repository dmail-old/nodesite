/*
MORE: a process could say the node version he want to run in, then using nvm we could spwan
the process into the right node env
*/
var Emitter = require('Emitter');
var FileObserver = require('FileObserver');
var proto = require('proto');
var argv = require('argv');
require('object/assign');

var NodeProcess = proto.extend(Emitter, {
	Path: require('path'),
	childProcess: require('child_process'),
	args: [],
	env: {},
	state: 'created', // created, started, killed, restarting
	process: null,
	ctime: null,
	hasRestartFile: false,
	restartFiles: null,
	console: console,

	constructor: function(path, configPath){
		Emitter.call(this);
		this.path = this.Path.resolve(process.cwd(), path);
		this.restartFiles = [];

		configPath = configPath || this.path + '.config.js';

		try{
			configPath = require.resolve(configPath);
		}
		catch(e){
			// no config file
		}

		if( configPath ){
			this.configPath = configPath;
			this.observeFile(configPath);
		}
	},

	setConfig: function(config){
		this.config = config;

		if( config.path ) this.path = this.Path.resolve(process.cwd(), config.path);
		if( config.restartFiles ){
			this.restartFiles = this.getRestartFiles(config.restartFiles);
			this.restartFiles.forEach(this.observeFile, this);
		}
		if( config.log ) this.log = true;
		if( config.events ) this.on(config.events);
		if( config.args ) this.args = config.args;
		if( config.env ) this.env = config.env;
	},

	unsetConfig: function(){
		var config = this.config;

		this.log = false;
		if( config.events ) this.off(config.events);
		this.restartFiles.forEach(this.unobserveFile, this);
		this.config = null;
	},

	log: function(){
		this.console.log.apply(this.console, arguments);
	},

	warn: function(){
		this.console.warn.apply(this.console, arguments);
	},

	onFileChange: function(path){
		this.emit('fileChange', path);

		if( path === this.configPath ){
			this.unsetConfig();
		}

		if( path in require.cache ){
			delete require.cache[path];
			this.warn(path, 'module modified, restarting...');

			// reload the module
			// dependening on the env, an antivirus maybe scanning the file
			// because it was modified recently, thus locking access to the file

			var attemptInterval = 10;
			var maxAttempt = 10;
			var count = 0;
			var self = this;

			function reload(){
				var error;

				try{
					require(path);
				}
				catch(e){
					error = e;
				}

				if( error ){
					if( error.code === 'EBUSY'){
						if( count >= maxAttempt ){
							console.log('File is busy');
							throw error;
						}
						else{
							count++;
							setTimeout(reload, attemptInterval);
						}
					}
					else{
						throw error;
					}
				}
				else{
					self.restart();
				}
			}

			reload();
		}
		else{
			this.warn(path, 'file modified, restarting...');
			this.restart();
		}
	},

	getRestartFiles: function(filePaths){
		var paths = [];
		var extraFS = require('fs.extra');
		var i = 0, j = filePaths.length;
		this.hasRestartFile = true;
		for(;i<j;i++){
			extraFS.collectFileSync(filePaths[i]).forEach(function(path){
				paths.push(path);
			}, this);
		}
		return paths;
	},

	observeFile: function(path){
		FileObserver.prototype.observe(path, this.onFileChange, this);
	},

	unobserveFile: function(path){
		FileObserver.prototype.unobserve(path, this.onFileChange, this);
	},

	isWindows: function(){
		return process.platform === 'win32';
	},

	start: function(){
		if( this.state == 'started' || this.state == 'restarting' ){
			throw new TypeError('cannot start, wrong process state' + this.state);
		}

		if( !this.config && this.configPath ){
			this.setConfig(require(this.configPath));
		}

		var preparedArgs = argv.prepare(this.args);

		//console.log('set cwd to', this.Path.dirname(this.path));

		this.process = this.childProcess.fork(this.path, preparedArgs, {
			cwd: this.Path.dirname(this.path),
			env: this.env
		});
		this.ctime = Number(new Date());

		this.process.on('exit', this.onexit.bind(this));
		this.process.on('message', this.onmessage.bind(this));

		this.state = 'started';
		this.emit('start');
	},

	restart: function(){
		if( this.state == 'started' ){
			this.state = 'restarting';
			if( this.isWindows() ){
				this.kill();
			}
			else{
				this.kill('SIGUSR2');
			}
		}
		else if( this.state != 'restarting' ){
			this.emit('restart');
			this.start();
		}
	},

	kill: function(signal){
		this.emit('kill', signal);
		this.process.kill(signal);
	},

	onexit: function(code, signal){
		if( this.state == 'restarting' ) signal = 'SIGUSR2';
		// this is nasty, but it gives it windows support
		else if( this.isWindows() && signal == 'SIGTERM' ) signal = 'SIGUSR2';
		// asked to restart
		else if( code == 2 ) signal = 'SIGUSR2';

		this.process = null;
		this.state = 'killed';

		// exit the monitor, but do it gracefully
		if( signal == 'SIGUSR2' ){
			this.restart();
		}
		// clean exit - wait until file change to restart
		else if( code === 0 ){
			if( this.hasRestartFile ){
				this.log('nodeprocess stopped');
			}
			this.emit('stop');
		}
		else{
			if( this.hasRestartFile ){
				this.console.error('nodeprocess crashed');
			}
			this.emit('crash');
		}
	},

	send: function(message, handle){
		this.process.send(message, handle);
	},

	onmessage: function(message, handle){
		if( message.type ){
			this.emit(message.type, message.event);
		}
	}
});

module.exports = NodeProcess;
