/*
https://gist.github.com/six8/1732686
// Depth first search
// As given in http://en.wikipedia.org/wiki/Topological_sorting

https://github.com/eknkc/tsort/blob/master/index.js

var a = {}, b = {}, c = {};

var graph = new Graph();

graph.add(a, b, c);
graph.add(c, b);
graph.sort();

-> b, c, a

graph.add(a, b);
graph.add(b, a)

-> error

je regarde mon objet, à je sais qu'il a besoin de b et c
je regarde mon object c, je sais qu'il a besoin de b

		http://en.wikipedia.org/wiki/Topological_sorting
		L ← Empty list that will contain the sorted nodes
while there are unmarked nodes do
    select an unmarked node n
    visit(n) 
function visit(node n)
    if n has a temporary mark then stop (not a DAG)
    if n is not marked (i.e. has not been visited yet) then
        mark n temporarily
        for each node m with an edge from n to m do
            visit(m)
        mark n permanently
        unmark n temporarily
        add n to head of L

*/

var proto = require('proto');

var Node = proto.create({
	edges: null,

	constructor: function(object){
		this.object = object;
	}
});

var Graph = proto.create({
	constructor: function(){
		this.nodes = [];
	},

	get size(){
		return this.nodes.length;
	},

	findIndex: function(object){
		var i = this.nodes.length;
		while(i-- && this.nodes[i].object !== object );
		return i;
	},

	getOrCreateNode: function(object){
		var index = this.findIndex(object), node;
			
		if( index === -1 ){
			node = new Node(object);
			this.nodes.push(node);
		}
		else{
			node = this.nodes[index];
		}

		return node;
	},

	add: function(object, dependencies){
		var node = this.getOrCreateNode(object);
		if( dependencies ) node.edges = dependencies.map(this.getOrCreateNode, this);		
		return this;
	},

	sort: function(){
        var tempIndex, sorted = [], markedNodes = [], temporaryMarkedNodes = [];

        function visit(node){
			if( temporaryMarkedNodes.indexOf(node) !== -1 ){
				throw new Error('There is a cycle in the graph. It is not possible to derive a topological sort.');
			}
			if( markedNodes.indexOf(node) === -1 ){
				tempIndex = temporaryMarkedNodes.length;
				temporaryMarkedNodes[tempIndex] = node;
				if( node.edges ) node.edges.forEach(visit);
				markedNodes.push(node);
				temporaryMarkedNodes.splice(tempIndex, 1);
				sorted.push(node.object);
			}
		}

		this.nodes.forEach(visit);

		return sorted;
	}
});

module.exports = Graph;