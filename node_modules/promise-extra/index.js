require('Promise');
var forOf = require('forOf');
require('Iterator.map');

var methods = {
	// same as reduce but collect the resolved values and return them
	serie: function(iterable, bind, initialValue){
		var promise = Promise.resolve(initialValue), values = [];

		forOf(iterable, function(fn){
			if( typeof bind !== 'undefined' ) fn = fn.bind(bind);
			promise = promise.then(fn);
			promise.then(
				function(value){
					values.push(value);
					return value;
				},
				// we add an empty function to listen for promise rejection
				// else the promise rejection is considered unhandled
				function(){}
			);
		});

		return promise.then(function(){
			return values;
		});
	},

	// each iterable value is considered as a then() call
	reduce: function(iterable, bind, initialValue){
		var promise = Promise.resolve(initialValue);

		forOf(iterable, function(fn){
			if( typeof bind !== 'undefined' ) fn = fn.bind(bind);
			promise = promise.then(fn);
		});

		return promise;
	},

	// return a promise fullfilled on first fullfilled promise or rejected on last rejected promise
	first: function(iterable, bind, initialValue){
		var initialPromise = Promise.resolve(initialValue);

		return new Promise(function(resolve, reject){
			var iterator = iterable[Symbol.iterator](), next, fn, reason;

			function rej(value){
				reason = value;
				next = iterator.next();

				if( next.done ){
					reject(reason);
				}
				else{
					fn = next.value;
					if( typeof bind !== 'undefined' ) fn = fn.bind(bind);

					initialPromise.then(fn).then(
						resolve,
						rej
					);
				}
			}

			rej();

		});
	},

	// each iterable value is mapped and considered as a then() call and return an array of resolved values
	map: function(iterable, map, bind, initialValue){
		iterable = Iterator.map(iterable, function(value, index, iterable){
			return map.bind(bind, value, index, iterable);
		}, bind);

		return this.serie(iterable, undefined, initialValue);
	},

	// same as map but values are not collected
	mapReduce: function(iterable, map, bind, initialValue){
		iterable = Iterator.map(iterable, function(value, index, iterable){
			return map.bind(bind, value, index, iterable);
		}, bind);

		return this.reduce(iterable, undefined, initialValue);
	},

	mapFirst: function(iterable, map, bind, initialValue){
		iterable = Iterator.map(iterable, function(value, index, iterable){
			return map.bind(bind, value, index, iterable);
		}, bind);

		return this.first(iterable, undefined, initialValue);
	},

	from: function(fn, bind){
		return new Promise(function fromExecutor(resolve, reject){
			fn.call(bind, function(error, result){
				if( error ) reject(error);
				else resolve(result);
			});
		});
	},

	fromStream: function(stream){
		var buffers = [];

		return new Promise(function(resolve, reject){
			stream.on('data', function(data){
				buffers.push(data);
			});
			stream.on('end', function(){
				resolve(Buffer.concat(buffers));
			});
			stream.on('error', reject);
		});
	}
};

var debug = require('debug');

/*
Return a promise fullfilled on first non null resolved promise or non null rejected promise
*/

Promise.route = function(iterable, bind, initialValue){
	var initialPromise = Promise.resolve(initialValue);

	return new Promise(function(resolve, reject){
		var iterator = iterable[Symbol.iterator](), next, fn, promise, rejected = false, value;

		function nextPromise(){
			next = iterator.next();

			if( next.done ){
				if( rejected ){
					debug('rejected route', value);
					reject(value);
				}
				else{
					// ptet qu'on va considérer que la route échoue puisque aucune route n'a match
					debug('resolved route', value);
					resolve(value);
				}
			}
			else{
				fn = next.value;

				if( rejected ){
					if( fn.length < 2 ) return nextPromise();

					debug('calling error middleware');
					promise = initialPromise.then(function(initialValue){
						return fn.call(bind, initialValue, value);
					});
				}
				else{
					if( typeof bind !== 'undefined' ) fn = fn.bind(bind);
					promise = initialPromise.then(fn);
				}

				promise.then(
					function(resolvedValue){
						debug('resolved middleware', resolvedValue);
						rejected = false;
						value = resolvedValue;
						if( resolvedValue != null ) resolve(resolvedValue);
						else nextPromise();
					},
					function(reason){
						debug('rejected middleware', reason);
						rejected = true;
						value = reason;
						nextPromise();
					}
				);
			}
		}

		nextPromise();
	});
};

module.exports = methods;
for(var name in methods) Promise[name] = methods[name];