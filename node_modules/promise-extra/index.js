require('Promise');
var forOf = require('forOf');
require('Iterator.map');

var methods = {
	// same as reduce but collect the resolved values and return them
	serie: function(iterable, bind, initialValue){
		var promise = Promise.resolve(initialValue), values = [];

		forOf(iterable, function(fn){
			if( typeof bind !== 'undefined' ) fn = fn.bind(bind);
			promise = promise.then(fn);
			promise.then(
				function(value){
					values.push(value);
					return value;
				},
				// we add an empty function to listen for promise rejection
				// else the promise rejection is considered unhandled
				function(){}
			);
		});

		return promise.then(function(){
			return values;
		});
	},

	// each iterable value is considered as a then() call
	reduce: function(iterable, bind, initialValue){
		var promise = Promise.resolve(initialValue);

		forOf(iterable, function(fn){
			if( typeof bind !== 'undefined' ) fn = fn.bind(bind);
			promise = promise.then(fn);
		});

		return promise;
	},

	// return a promise fullfilled on first fullfilled promise or rejected on last rejected promise
	first: function(iterable, bind, initialValue){
		var initialPromise = Promise.resolve(initialValue);

		return new Promise(function(resolve, reject){
			var iterator = iterable[Symbol.iterator](), next, fn, reason;

			function rej(value){
				reason = value;
				next = iterator.next();

				if( next.done ){
					reject(reason);
				}
				else{
					fn = next.value;
					if( typeof bind !== 'undefined' ) fn = fn.bind(bind);

					initialPromise.then(fn).then(
						resolve,
						rej
					);
				}
			}

			rej();

		});
	},

	// each iterable value is mapped and considered as a then() call and return an array of resolved values
	map: function(iterable, map, bind, initialValue){
		iterable = Iterator.map(iterable, function(value, index, iterable){
			return map.bind(bind, value, index, iterable);
		}, bind);

		return this.serie(iterable, undefined, initialValue);
	},

	// same as map but values are not collected
	mapReduce: function(iterable, map, bind, initialValue){
		iterable = Iterator.map(iterable, function(value, index, iterable){
			return map.bind(bind, value, index, iterable);
		}, bind);

		return this.reduce(iterable, undefined, initialValue);
	},

	mapFirst: function(iterable, map, bind, initialValue){
		iterable = Iterator.map(iterable, function(value, index, iterable){
			return map.bind(bind, value, index, iterable);
		}, bind);

		return this.first(iterable, undefined, initialValue);
	},

	from: function(fn, bind){
		return new Promise(function fromExecutor(resolve, reject){
			fn.call(bind, function(error, result){
				if( error ) reject(error);
				else resolve(result);
			});
		});
	},

	fromStream: function(stream){
		var buffers = [];

		return new Promise(function(resolve, reject){
			stream.on('data', function(data){
				buffers.push(data);
			});
			stream.on('end', function(){
				resolve(Buffer.concat(buffers));
			});
			stream.on('error', reject);
		});
	}
};

module.exports = methods;
for(var name in methods) Promise[name] = methods[name];